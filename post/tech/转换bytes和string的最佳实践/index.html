<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>转换bytes和string的最佳实践 | 绝知</title>
<meta name=keywords content="golang,string"><meta name=description content='
本文golang源码为1.18版本

标准转换
使用标准转换是最常见的选择
package main

func main() {
	s := "Hello, world!"
  	// string转byte数组
	b := []byte(s)
  	// byte数组转string
	s2 := string(b)
}
该转换语句会被go编译器翻译为runtime层的方法调用，其中[]byte到string的转换对应/src/runtime/string.go:81处的slicebytetostring函数；而string到[]byte的转换对应的则是/src/runtime/string.go:172处的stringtoslicebyte函数。
先来看看比较简单的stringtoslicebyte函数，tmpBuf类型是个大小为32的byte数组。
// The constant is known to the compiler.
// There is no fundamental theory behind this number. 🤣
const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte

func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
        // 如果没有缓冲区或缓冲区大小不足，需要申请内存
		b = rawbyteslice(len(s))
	}
    // 复制数据
	copy(b, s)
	return b
}

func rawbyteslice(size int) (b []byte) {
    // 容量计算，考虑内存对齐，寻找大小最匹配的内存块
	cap := roundupsize(uintptr(size))
    // 使用mallocgc申请对应大小的内存
	p := mallocgc(cap, nil, false)
    // 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}
	// 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append
	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。'><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.278e8b2dd0edae6a4a4d865210e46385ee100556bcf14ba56506e7501326056e.css integrity="sha256-J46LLdDtrmpKTYZSEORjhe4QBVa88UulZQbnUBMmBW4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="转换bytes和string的最佳实践"><meta property="og:description" content='
本文golang源码为1.18版本

标准转换
使用标准转换是最常见的选择
package main

func main() {
	s := "Hello, world!"
  	// string转byte数组
	b := []byte(s)
  	// byte数组转string
	s2 := string(b)
}
该转换语句会被go编译器翻译为runtime层的方法调用，其中[]byte到string的转换对应/src/runtime/string.go:81处的slicebytetostring函数；而string到[]byte的转换对应的则是/src/runtime/string.go:172处的stringtoslicebyte函数。
先来看看比较简单的stringtoslicebyte函数，tmpBuf类型是个大小为32的byte数组。
// The constant is known to the compiler.
// There is no fundamental theory behind this number. 🤣
const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte

func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
        // 如果没有缓冲区或缓冲区大小不足，需要申请内存
		b = rawbyteslice(len(s))
	}
    // 复制数据
	copy(b, s)
	return b
}

func rawbyteslice(size int) (b []byte) {
    // 容量计算，考虑内存对齐，寻找大小最匹配的内存块
	cap := roundupsize(uintptr(size))
    // 使用mallocgc申请对应大小的内存
	p := mallocgc(cap, nil, false)
    // 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}
	// 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append
	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。'><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-01T19:34:04+08:00"><meta property="article:modified_time" content="2023-02-01T19:34:04+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="转换bytes和string的最佳实践"><meta name=twitter:description content='
本文golang源码为1.18版本

标准转换
使用标准转换是最常见的选择
package main

func main() {
	s := "Hello, world!"
  	// string转byte数组
	b := []byte(s)
  	// byte数组转string
	s2 := string(b)
}
该转换语句会被go编译器翻译为runtime层的方法调用，其中[]byte到string的转换对应/src/runtime/string.go:81处的slicebytetostring函数；而string到[]byte的转换对应的则是/src/runtime/string.go:172处的stringtoslicebyte函数。
先来看看比较简单的stringtoslicebyte函数，tmpBuf类型是个大小为32的byte数组。
// The constant is known to the compiler.
// There is no fundamental theory behind this number. 🤣
const tmpStringBufSize = 32

type tmpBuf [tmpStringBufSize]byte

func stringtoslicebyte(buf *tmpBuf, s string) []byte {
	var b []byte
	if buf != nil && len(s) <= len(buf) {
		*buf = tmpBuf{}
		b = buf[:len(s)]
	} else {
        // 如果没有缓冲区或缓冲区大小不足，需要申请内存
		b = rawbyteslice(len(s))
	}
    // 复制数据
	copy(b, s)
	return b
}

func rawbyteslice(size int) (b []byte) {
    // 容量计算，考虑内存对齐，寻找大小最匹配的内存块
	cap := roundupsize(uintptr(size))
    // 使用mallocgc申请对应大小的内存
	p := mallocgc(cap, nil, false)
    // 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存
	if cap != uintptr(size) {
		memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size))
	}
	// 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append
	*(*slice)(unsafe.Pointer(&amp;b)) = slice{p, size, int(cap)}
	return
}
当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"转换bytes和string的最佳实践","item":"https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"转换bytes和string的最佳实践","name":"转换bytes和string的最佳实践","description":" 本文golang源码为1.18版本\n标准转换 使用标准转换是最常见的选择\npackage main func main() { s := \u0026#34;Hello, world!\u0026#34; // string转byte数组 b := []byte(s) // byte数组转string s2 := string(b) } 该转换语句会被go编译器翻译为runtime层的方法调用，其中[]byte到string的转换对应/src/runtime/string.go:81处的slicebytetostring函数；而string到[]byte的转换对应的则是/src/runtime/string.go:172处的stringtoslicebyte函数。\n先来看看比较简单的stringtoslicebyte函数，tmpBuf类型是个大小为32的byte数组。\n// The constant is known to the compiler. // There is no fundamental theory behind this number. 🤣 const tmpStringBufSize = 32 type tmpBuf [tmpStringBufSize]byte func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026amp;\u0026amp; len(s) \u0026lt;= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { // 如果没有缓冲区或缓冲区大小不足，需要申请内存 b = rawbyteslice(len(s)) } // 复制数据 copy(b, s) return b } func rawbyteslice(size int) (b []byte) { // 容量计算，考虑内存对齐，寻找大小最匹配的内存块 cap := roundupsize(uintptr(size)) // 使用mallocgc申请对应大小的内存 p := mallocgc(cap, nil, false) // 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存 if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } // 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append *(*slice)(unsafe.Pointer(\u0026amp;b)) = slice{p, size, int(cap)} return } 当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。\n","keywords":["golang","string"],"articleBody":" 本文golang源码为1.18版本\n标准转换 使用标准转换是最常见的选择\npackage main func main() { s := \"Hello, world!\" // string转byte数组 b := []byte(s) // byte数组转string s2 := string(b) } 该转换语句会被go编译器翻译为runtime层的方法调用，其中[]byte到string的转换对应/src/runtime/string.go:81处的slicebytetostring函数；而string到[]byte的转换对应的则是/src/runtime/string.go:172处的stringtoslicebyte函数。\n先来看看比较简单的stringtoslicebyte函数，tmpBuf类型是个大小为32的byte数组。\n// The constant is known to the compiler. // There is no fundamental theory behind this number. 🤣 const tmpStringBufSize = 32 type tmpBuf [tmpStringBufSize]byte func stringtoslicebyte(buf *tmpBuf, s string) []byte { var b []byte if buf != nil \u0026\u0026 len(s) \u003c= len(buf) { *buf = tmpBuf{} b = buf[:len(s)] } else { // 如果没有缓冲区或缓冲区大小不足，需要申请内存 b = rawbyteslice(len(s)) } // 复制数据 copy(b, s) return b } func rawbyteslice(size int) (b []byte) { // 容量计算，考虑内存对齐，寻找大小最匹配的内存块 cap := roundupsize(uintptr(size)) // 使用mallocgc申请对应大小的内存 p := mallocgc(cap, nil, false) // 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存 if cap != uintptr(size) { memclrNoHeapPointers(add(p, uintptr(size)), cap-uintptr(size)) } // 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, int(cap)} return } 当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。\n再看看slicebytetostring函数，\n// ptr指向slice的第一个元素，n是slice的长度 func slicebytetostring(buf *tmpBuf, ptr *byte, n int) (str string) { if n == 0 { return \"\" } ... // 如果只有单个byte，返回值字符串中的数据指针str直接指向预分配好的一块静态内存区 if n == 1 { // staticuint64s是一个uint64数组，里面一个个值都对应着单个byte的int8值，提供此种情况下的str不可修改的指向 p := unsafe.Pointer(\u0026staticuint64s[*ptr]) if goarch.BigEndian { p = add(p, 7) } // 填充返回数据 stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = 1 return } var p unsafe.Pointer if buf != nil \u0026\u0026 n \u003c= len(buf) { p = unsafe.Pointer(buf) } else { // 缓冲区不存在或者不够时，分配内存 p = mallocgc(uintptr(n), nil, false) } stringStructOf(\u0026str).str = p stringStructOf(\u0026str).len = n // 使用memmove复制数据 memmove(p, unsafe.Pointer(ptr), uintptr(n)) return } 关于staticuint64s的一段测试代码:\npackage main import \"unsafe\" var staticuint64s = [...]uint64{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, } type stringStruct struct { str unsafe.Pointer len int } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } func main() { var s string stringStructOf(\u0026s).str = unsafe.Pointer(\u0026staticuint64s[80]) stringStructOf(\u0026s).len = 1 println(s) } 使用标准转换是最简单也是最安全的，但从上面的源码可以看到，string和[]byte的两个相互转换，都可能出现新的内存分配，并且一定要进行内存的复制。这样的转换在性能敏感的场景下无法满足要求，还好我们还有其他的转换黑魔法😈。\n零拷贝转换 编译器转换 其实在上文提到的两个函数旁边，还有一个特殊的函数——slicebytetostringtmp(src/runtime/string.go:154)\n// slicebytetostringtmp returns a \"string\" referring to the actual []byte bytes. // // Callers need to ensure that the returned string will not be used after // the calling goroutine modifies the original slice or synchronizes with // another goroutine. // // The function is only called when instrumenting // and otherwise intrinsified by the compiler. // // Some internal compiler optimizations use this function. // - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)] // where k is []byte, T1 to Tn is a nesting of struct and array literals. // - Used for \"\u003c\"+string(b)+\"\u003e\" concatenation where b is []byte. // - Used for string(b)==\"foo\" comparison where b is []byte. func slicebytetostringtmp(ptr *byte, n int) (str string) { if raceenabled \u0026\u0026 n \u003e 0 { racereadrangepc(unsafe.Pointer(ptr), uintptr(n), getcallerpc(), abi.FuncPCABIInternal(slicebytetostringtmp)) } if msanenabled \u0026\u0026 n \u003e 0 { msanread(unsafe.Pointer(ptr), uintptr(n)) } if asanenabled \u0026\u0026 n \u003e 0 { asanread(unsafe.Pointer(ptr), uintptr(n)) } stringStructOf(\u0026str).str = unsafe.Pointer(ptr) stringStructOf(\u0026str).len = n return } 抛开无需关心的代码，核心代码只有两句:\nstringStructOf(\u0026str).str = unsafe.Pointer(ptr) stringStructOf(\u0026str).len = n 返回字符串的数据指针str直接指向了[]byte的首地址，而长度直接取[]byte长度。能够如此转换的根本原因是string的底层类型和slice的底层类型内存分布相似，所以可以直接通过修改指针的方式进行转换。\n// src/runtime/string.go:238 type stringStruct struct { str unsafe.Pointer len int } // src/runtime/slice.go:15 type slice struct { array unsafe.Pointer len int cap int } 可见，两个结构体的前两个字段内存分布是完全一致的，并且string的底层数据类型和[]byte一致，所以unsafe.Pointer对应的实际指针都是*byte。这样的转换实际上就是指针的转换，不需要进行内存的分配和复制，所以效率非常高。\n但是使用这样的代码是有风险的，上文中的代码我特意把注释也贴出来了，注释里第二段明确写到，调用者需要保证，在修改或与其他g同步了原[]byte后，返回的string不会再被使用。这是因为你强行创造的这个string所对应的底层数据并不安全，创造出该string后，你可以直接对原[]byte进行修改，这违背了go语言字符串不可修改的原则，将会产生无法捕获的错误。\n所以这个方法go没有暴露给开发者，仅在源码内部可使用，供编译器在某些适用场景优化性能。\n以上两种转换的性能对比:\npackage main import ( \"testing\" ) const LEN = 33 func getBytes() []byte { var b []byte for i := 0; i \u003c LEN; i++ { b = append(b, ' ') } return b } func BenchmarkByte2StringOrigin(b *testing.B) { bytes := getBytes() for i := 0; i \u003c b.N; i++ { s := string(bytes) _ = s } } func BenchmarkByte2StringTmp(b *testing.B) { bytes := getBytes() for i := 0; i \u003c b.N; i++ { s := slicebytetostringtmp(bytes) _ = s } } // 依赖代码 type stringStruct struct { str unsafe.Pointer len int } func stringStructOf(sp *string) *stringStruct { return (*stringStruct)(unsafe.Pointer(sp)) } func slicebytetostringtmp(b []byte) (str string) { stringStructOf(\u0026str).str = unsafe.Pointer(\u0026b[0]) stringStructOf(\u0026str).len = len(b) return } 和之前源码看到的一致，对于标准转换，长度32是一个分水岭，长度大于32时，就会出现内存分配，同时操作耗时也显著增加。并且随着slice长度的增加，和指针转换的性能差距会越来越大。\n自己实现——unsafe.Pointer 虽然slicebytetostringtmp我们无法使用，但是通过使用unsafe包，我们可以自行构造类似的指针转换。\n先来一个最简单的版本:\nfunc String2bytesEasy(s string) []byte { return *(*[]byte)(unsafe.Pointer(\u0026s)) } func Bytes2StringEasy(b []byte) string { return *(*string)(unsafe.Pointer(\u0026b)) } 直接使用unsafe.Pointer作为中间类型进行强转，非常快速，但是会有一个小问题，String2bytesEasy函数中，返回的slice中cap字段是没有赋值的，因为string类型只有两个字段，而slice有三个，未赋值的cap字段的值是随机的，取决于那一块内存的值。\n优化版本:\n// src/reflect/value.go:2670 type StringHeader struct { Data uintptr Len int } // src/reflect/value.go:2681 type SliceHeader struct { Data uintptr Len int Cap int } func String2bytes(s string) []byte { stringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) bh := reflect.SliceHeader{ Data: stringHeader.Data, Len: stringHeader.Len, Cap: stringHeader.Len, } return *(*[]byte)(unsafe.Pointer(\u0026bh)) } 这个版本用到了reflect包中的两个类型StringHeader和SliceHeader，它们分别是string和slice的runtime层形态。通过这样的转换后，我们得以直接操作它们的字段。\n通过全部的三个字段赋值，最终得到的是一个完整的slice。\n但是这里的代码还隐藏了一个深层次的问题 继续深挖，这里的关键是我们创建的中间变量bh，特殊点在于它的类型reflect.SliceHeader。如果你打开过源码的unsafe包，在Point类型的开头有一大堆注释(以下仅部分):\n// (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer. // // As in the previous case, the reflect data structures SliceHeader and StringHeader // declare the field Data as a uintptr to keep callers from changing the result to // an arbitrary type without first importing \"unsafe\". However, this means that // SliceHeader and StringHeader are only valid when interpreting the content // of an actual slice or string value. // //\tvar s string //\thdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) // case 1 //\thdr.Data = uintptr(unsafe.Pointer(p)) // case 6 (this case) //\thdr.Len = n // // In this usage hdr.Data is really an alternate way to refer to the underlying // pointer in the string header, not a uintptr variable itself. // // In general, reflect.SliceHeader and reflect.StringHeader should be used // only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual // slices or strings, never as plain structs. // A program should not declare or allocate variables of these struct types. // //\t// INVALID: a directly-declared header will not hold Data as a reference. //\tvar hdr reflect.StringHeader //\thdr.Data = uintptr(unsafe.Pointer(p)) //\thdr.Len = n //\ts := *(*string)(unsafe.Pointer(\u0026hdr)) // p possibly already lost // 重点就是这一句——INVALID: a directly-declared header will not hold Data as a reference.\n翻译过来就是，一个直接声明的header不会将Data作为引用。\n解释一下，Header的Data字段类型是uintptr而不是unsafe.Pointer，这两个类型的其中一个差别就是，go的gc不会记录uintptr的引用，这一点在SliceHeader和StringHeader的定义处也有注释进行了说明，它们俩的定义上方都有这么一段:\n// Moreover, the Data field is not sufficient to guarantee the data // it references will not be garbage collected, so programs must keep // a separate, correctly typed pointer to the underlying data. 这意味着gc在清理内存时并不知道还存在一个Header的Data字段指向了这块内存，就可能会导致在转换的过程中，底层数据已经被gc给清理。\n对应上面的例子中:\nfunc String2bytes(s string) []byte { stringHeader := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) bh := reflect.SliceHeader{ Data: stringHeader.Data, Len: stringHeader.Len, Cap: stringHeader.Len, } // 在执行这一步之前，stringHeader已经没有了用处，而bh没有产生引用，此时gc认为是可以进行回收的 return *(*[]byte)(unsafe.Pointer(\u0026bh)) } 避免这个问题的方法也很简单，避开directly-declared就可以了，注释中也给了一个正确例子:\nvar s string hdr := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) // case 1 hdr.Data = uintptr(unsafe.Pointer(p)) // case 6 (this case) hdr.Len = n 这里先创建了临时变量s，再基于s进行转换得到的header指针，所以这里并不存在一个实际的header，对hdr的赋值操作其实是在直接操作字符串s，所以也就没有了gc追踪不到的问题了。\n贴一个优化代码示例:\nfunc b2s(b []byte) string { return *(*string)(unsafe.Pointer(\u0026b)) } func S2b(s string) (b []byte) { bh := (*reflect.SliceHeader)(unsafe.Pointer(\u0026b)) sh := (*reflect.StringHeader)(unsafe.Pointer(\u0026s)) bh.Data = sh.Data bh.Len = sh.Len bh.Cap = sh.Len return b } 补充 关于这个问题，我还找到一个go源码库的issue：Feature: provide no-copy conversion from []byte to string，虽然issue的发起者是想问为什么没有官方提供的转换函数，但是他提供的代码有着和我所给的反例代码一样的问题，并且被其他用户指出来了，并且这个问题得到了go的组织成员的肯定：\n有趣的是，go101(应该有人认识吧)还在下面提出即使避开了header的直接定义，还是需要使用runtime.KeepAlive来保证gc不会回收数据，这就与我本文观点冲突了🤣。\n不过好在这条在下面被反对了👀\n至于为什么不把reflect包中header的Data字段改为unsafe.Pointer来解决这个问题，也有了解释：\n这里面提到的另外的issue:\nunsafe: add Slice(ptr *T, len anyIntegerType) []T\nproposal: spec: disallow T\u003c-\u003euintptr conversion for type T unsafe.Pointer\n另外，我觉得该issue的发起人说的话挺有道理的，这段转换的代码藏了很深的坑，没有对源码有一定了解的人完全无法发现，而官方又没有提供转换的最佳实践，以致于网络上出现了各种自行实现的版本，而其中许多的实现都是存在问题的。\n幸好，这个问题在Go2迎来了转机。\n展望未来，Go1.20 在go1.20rc中的这个提交，为slice和string的转换提供了新的选择，该提交在unsafe包中新增了四个函数https://github.com/golang/go/blob/release-branch.go1.20/src/unsafe/unsafe.go:\n// The function Slice returns a slice whose underlying array starts at ptr // and whose length and capacity are len. // Slice(ptr, len) is equivalent to // //\t(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:] // // except that, as a special case, if ptr is nil and len is zero, // Slice returns nil. // // The len argument must be of integer type or an untyped constant. // A constant len argument must be non-negative and representable by a value of type int; // if it is an untyped constant it is given type int. // At run time, if len is negative, or if ptr is nil and len is not zero, // a run-time panic occurs. func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType // SliceData returns a pointer to the underlying array of the argument // slice. // - If cap(slice) \u003e 0, SliceData returns \u0026slice[:1][0]. // - If slice == nil, SliceData returns nil. // - Otherwise, SliceData returns a non-nil pointer to an // unspecified memory address. func SliceData(slice []ArbitraryType) *ArbitraryType // String returns a string value whose underlying bytes // start at ptr and whose length is len. // // The len argument must be of integer type or an untyped constant. // A constant len argument must be non-negative and representable by a value of type int; // if it is an untyped constant it is given type int. // At run time, if len is negative, or if ptr is nil and len is not zero, // a run-time panic occurs. // // Since Go strings are immutable, the bytes passed to String // must not be modified afterwards. func String(ptr *byte, len IntegerType) string // StringData returns a pointer to the underlying bytes of str. // For an empty string the return value is unspecified, and may be nil. // // Since Go strings are immutable, the bytes returned by StringData // must not be modified. func StringData(str string) *byte 由于unsafe包的特殊性，其函数的具体实现是通过汇编等手段实现的，所以你在这里只能看到函数签名。\n简单介绍下四个函数的作用:\nSlice：返回一个slice，其底层数组的起始地址即为参数ptr所指向的地址，slice的len和cap都为参数len。 SliceData: 返回一个指向该slice底层数组的指针。 String：返回一个string，其底层的byte数组的起始地址即为参数ptr所指向的地址，长度为参数len。 StringData: 返回参数str底层byte数组的指针。 这四个函数提供的功能非常基础，不过组合起来就能实现我们想要的字符串转换功能了,如果不想安装go1.20rc，你可以在这里去试用这四个函数:\npackage main import ( \"fmt\" \"unsafe\" ) func main() { str := \"hello world!\" bt := unsafe.Slice(unsafe.StringData(str), len(str)) fmt.Println(bt) } 有了这个写法，reflect的headers就可以弃用了。\n附上三种转换的benchmark(IDE可能会报错，但是没事，go1.20可以执行)：\npackage main import ( \"testing\" \"unsafe\" ) const LEN = 33 func getBytes() []byte { var b []byte for i := 0; i \u003c LEN; i++ { b = append(b, ' ') } return b } func getStr() string { return string(getBytes()) } func BenchmarkString2Slice(b *testing.B) { str := getStr() for i := 0; i \u003c b.N; i++ { bt := []byte(str) _ = bt } } func BenchmarkString2SliceReflect(b *testing.B) { str := getStr() for i := 0; i \u003c b.N; i++ { bt := *(*[]byte)(unsafe.Pointer(\u0026str)) _ = bt } } func BenchmarkString2SliceUnsafe(b *testing.B) { str := getStr() for i := 0; i \u003c b.N; i++ { bt := unsafe.Slice(unsafe.StringData(str), len(str)) _ = bt } } func BenchmarkSlice2String(b *testing.B) { bytes := getBytes() for i := 0; i \u003c b.N; i++ { ss := string(bytes) _ = ss } } func BenchmarkSlice2StringReflect(b *testing.B) { bytes := getBytes() for i := 0; i \u003c b.N; i++ { ss := *(*string)(unsafe.Pointer(\u0026bytes)) _ = ss } } func BenchmarkSlice2StringUnsafe(b *testing.B) { bytes := getBytes() for i := 0; i \u003c b.N; i++ { ss := unsafe.String(unsafe.SliceData(bytes), len(bytes)) _ = ss } } ","wordCount":"1812","inLanguage":"zh","datePublished":"2023-02-01T19:34:04+08:00","dateModified":"2023-02-01T19:34:04+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},"publisher":{"@type":"Organization","name":"绝知","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="绝知 (Alt + H)">绝知</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>转换bytes和string的最佳实践</h1><div class=post-meta><span title='2023-02-01 19:34:04 +0800 +0800'>2023-02-01</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%a0%87%e5%87%86%e8%bd%ac%e6%8d%a2 aria-label=标准转换>标准转换</a></li><li><a href=#%e9%9b%b6%e6%8b%b7%e8%b4%9d%e8%bd%ac%e6%8d%a2 aria-label=零拷贝转换>零拷贝转换</a><ul><li><a href=#%e7%bc%96%e8%af%91%e5%99%a8%e8%bd%ac%e6%8d%a2 aria-label=编译器转换>编译器转换</a></li></ul></li><li><a href=#%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0unsafepointer aria-label=自己实现——unsafe.Pointer>自己实现——unsafe.Pointer</a><ul><li><a href=#%e8%a1%a5%e5%85%85 aria-label=补充>补充</a></li></ul></li><li><a href=#%e5%b1%95%e6%9c%9b%e6%9c%aa%e6%9d%a5go120 aria-label=展望未来，Go1.20>展望未来，Go1.20</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>本文golang源码为1.18版本</p></blockquote><h2 id=标准转换>标准转换<a hidden class=anchor aria-hidden=true href=#标准转换>#</a></h2><p>使用标准转换是最常见的选择</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>s</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;Hello, world!&#34;</span>
</span></span><span style=display:flex><span>  	<span style=color:#7f848e>// string转byte数组</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> []<span style=color:#e5c07b>byte</span>(<span style=color:#e06c75>s</span>)
</span></span><span style=display:flex><span>  	<span style=color:#7f848e>// byte数组转string</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>s2</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>string</span>(<span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>该转换语句会被go编译器翻译为runtime层的方法调用，其中<code>[]byte</code>到<code>string</code>的转换对应<code>/src/runtime/string.go:81</code>处的<code>slicebytetostring</code>函数；而<code>string</code>到<code>[]byte</code>的转换对应的则是<code>/src/runtime/string.go:172</code>处的<code>stringtoslicebyte</code>函数。</p><p>先来看看比较简单的<code>stringtoslicebyte</code>函数，<code>tmpBuf</code>类型是个大小为32的<code>byte</code>数组。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// The constant is known to the compiler.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// There is no fundamental theory behind this number. 🤣</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>const</span> <span style=color:#e06c75>tmpStringBufSize</span> = <span style=color:#d19a66>32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>tmpBuf</span> [<span style=color:#e06c75>tmpStringBufSize</span>]<span style=color:#e5c07b>byte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>stringtoslicebyte</span>(<span style=color:#e06c75>buf</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>tmpBuf</span>, <span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>buf</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>s</span>) <span style=color:#56b6c2>&lt;=</span> <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>buf</span>) {
</span></span><span style=display:flex><span>		<span style=color:#56b6c2>*</span><span style=color:#e06c75>buf</span> = <span style=color:#e06c75>tmpBuf</span>{}
</span></span><span style=display:flex><span>		<span style=color:#e06c75>b</span> = <span style=color:#e06c75>buf</span>[:<span style=color:#e5c07b>len</span>(<span style=color:#e06c75>s</span>)]
</span></span><span style=display:flex><span>	} <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 如果没有缓冲区或缓冲区大小不足，需要申请内存</span>
</span></span><span style=display:flex><span>		<span style=color:#e06c75>b</span> = <span style=color:#61afef;font-weight:700>rawbyteslice</span>(<span style=color:#e5c07b>len</span>(<span style=color:#e06c75>s</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 复制数据</span>
</span></span><span style=display:flex><span>	<span style=color:#e5c07b>copy</span>(<span style=color:#e06c75>b</span>, <span style=color:#e06c75>s</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>rawbyteslice</span>(<span style=color:#e06c75>size</span> <span style=color:#e5c07b>int</span>) (<span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>) {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 容量计算，考虑内存对齐，寻找大小最匹配的内存块</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>cap</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>roundupsize</span>(<span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>size</span>))
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 使用mallocgc申请对应大小的内存</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>p</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>mallocgc</span>(<span style=color:#e06c75>cap</span>, <span style=color:#e5c07b>nil</span>, <span style=color:#e5c07b>false</span>)
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果要申请的size和最终计算得到的cap大小不一致，cap只会比size更大，清理掉多余的内存</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>cap</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>size</span>) {
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>memclrNoHeapPointers</span>(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>p</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>size</span>)), <span style=color:#e06c75>cap</span><span style=color:#56b6c2>-</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>size</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 将b指向这片申请好的内存。该slice不为空，故外部使用copy进行覆盖而不是append</span>
</span></span><span style=display:flex><span>	<span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>slice</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>)) = <span style=color:#e06c75>slice</span>{<span style=color:#e06c75>p</span>, <span style=color:#e06c75>size</span>, <span style=color:#e5c07b>int</span>(<span style=color:#e06c75>cap</span>)}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当需要转换的字符串长度小于32时，只会进行内存复制，而大于32的话，除了复制操作，还需要分配内存。</p><p>再看看<code>slicebytetostring</code>函数，</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// ptr指向slice的第一个元素，n是slice的长度</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>slicebytetostring</span>(<span style=color:#e06c75>buf</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>tmpBuf</span>, <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>byte</span>, <span style=color:#e06c75>n</span> <span style=color:#e5c07b>int</span>) (<span style=color:#e06c75>str</span> <span style=color:#e5c07b>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>n</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span> <span style=color:#98c379>&#34;&#34;</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>...</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果只有单个byte，返回值字符串中的数据指针str直接指向预分配好的一块静态内存区</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>n</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>1</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// staticuint64s是一个uint64数组，里面一个个值都对应着单个byte的int8值，提供此种情况下的str不可修改的指向</span>
</span></span><span style=display:flex><span>		<span style=color:#e06c75>p</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>staticuint64s</span>[<span style=color:#56b6c2>*</span><span style=color:#e06c75>ptr</span>])
</span></span><span style=display:flex><span>		<span style=color:#c678dd>if</span> <span style=color:#e06c75>goarch</span>.<span style=color:#e06c75>BigEndian</span> {
</span></span><span style=display:flex><span>			<span style=color:#e06c75>p</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>p</span>, <span style=color:#d19a66>7</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 填充返回数据</span>
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>p</span>
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>len</span> = <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>		<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>p</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>buf</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>n</span> <span style=color:#56b6c2>&lt;=</span> <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>buf</span>) {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>p</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>buf</span>)
</span></span><span style=display:flex><span>	} <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 缓冲区不存在或者不够时，分配内存</span>
</span></span><span style=display:flex><span>		<span style=color:#e06c75>p</span> = <span style=color:#61afef;font-weight:700>mallocgc</span>(<span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>n</span>), <span style=color:#e5c07b>nil</span>, <span style=color:#e5c07b>false</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>p</span>
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>len</span> = <span style=color:#e06c75>n</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 使用memmove复制数据</span>
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>memmove</span>(<span style=color:#e06c75>p</span>, <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>), <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>关于<code>staticuint64s</code>的一段测试代码:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> <span style=color:#98c379>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>var</span> <span style=color:#e06c75>staticuint64s</span> = [<span style=color:#56b6c2>...</span>]<span style=color:#e5c07b>uint64</span>{
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x00</span>, <span style=color:#d19a66>0x01</span>, <span style=color:#d19a66>0x02</span>, <span style=color:#d19a66>0x03</span>, <span style=color:#d19a66>0x04</span>, <span style=color:#d19a66>0x05</span>, <span style=color:#d19a66>0x06</span>, <span style=color:#d19a66>0x07</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x08</span>, <span style=color:#d19a66>0x09</span>, <span style=color:#d19a66>0x0a</span>, <span style=color:#d19a66>0x0b</span>, <span style=color:#d19a66>0x0c</span>, <span style=color:#d19a66>0x0d</span>, <span style=color:#d19a66>0x0e</span>, <span style=color:#d19a66>0x0f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x10</span>, <span style=color:#d19a66>0x11</span>, <span style=color:#d19a66>0x12</span>, <span style=color:#d19a66>0x13</span>, <span style=color:#d19a66>0x14</span>, <span style=color:#d19a66>0x15</span>, <span style=color:#d19a66>0x16</span>, <span style=color:#d19a66>0x17</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x18</span>, <span style=color:#d19a66>0x19</span>, <span style=color:#d19a66>0x1a</span>, <span style=color:#d19a66>0x1b</span>, <span style=color:#d19a66>0x1c</span>, <span style=color:#d19a66>0x1d</span>, <span style=color:#d19a66>0x1e</span>, <span style=color:#d19a66>0x1f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x20</span>, <span style=color:#d19a66>0x21</span>, <span style=color:#d19a66>0x22</span>, <span style=color:#d19a66>0x23</span>, <span style=color:#d19a66>0x24</span>, <span style=color:#d19a66>0x25</span>, <span style=color:#d19a66>0x26</span>, <span style=color:#d19a66>0x27</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x28</span>, <span style=color:#d19a66>0x29</span>, <span style=color:#d19a66>0x2a</span>, <span style=color:#d19a66>0x2b</span>, <span style=color:#d19a66>0x2c</span>, <span style=color:#d19a66>0x2d</span>, <span style=color:#d19a66>0x2e</span>, <span style=color:#d19a66>0x2f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x30</span>, <span style=color:#d19a66>0x31</span>, <span style=color:#d19a66>0x32</span>, <span style=color:#d19a66>0x33</span>, <span style=color:#d19a66>0x34</span>, <span style=color:#d19a66>0x35</span>, <span style=color:#d19a66>0x36</span>, <span style=color:#d19a66>0x37</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x38</span>, <span style=color:#d19a66>0x39</span>, <span style=color:#d19a66>0x3a</span>, <span style=color:#d19a66>0x3b</span>, <span style=color:#d19a66>0x3c</span>, <span style=color:#d19a66>0x3d</span>, <span style=color:#d19a66>0x3e</span>, <span style=color:#d19a66>0x3f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x40</span>, <span style=color:#d19a66>0x41</span>, <span style=color:#d19a66>0x42</span>, <span style=color:#d19a66>0x43</span>, <span style=color:#d19a66>0x44</span>, <span style=color:#d19a66>0x45</span>, <span style=color:#d19a66>0x46</span>, <span style=color:#d19a66>0x47</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x48</span>, <span style=color:#d19a66>0x49</span>, <span style=color:#d19a66>0x4a</span>, <span style=color:#d19a66>0x4b</span>, <span style=color:#d19a66>0x4c</span>, <span style=color:#d19a66>0x4d</span>, <span style=color:#d19a66>0x4e</span>, <span style=color:#d19a66>0x4f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x50</span>, <span style=color:#d19a66>0x51</span>, <span style=color:#d19a66>0x52</span>, <span style=color:#d19a66>0x53</span>, <span style=color:#d19a66>0x54</span>, <span style=color:#d19a66>0x55</span>, <span style=color:#d19a66>0x56</span>, <span style=color:#d19a66>0x57</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x58</span>, <span style=color:#d19a66>0x59</span>, <span style=color:#d19a66>0x5a</span>, <span style=color:#d19a66>0x5b</span>, <span style=color:#d19a66>0x5c</span>, <span style=color:#d19a66>0x5d</span>, <span style=color:#d19a66>0x5e</span>, <span style=color:#d19a66>0x5f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x60</span>, <span style=color:#d19a66>0x61</span>, <span style=color:#d19a66>0x62</span>, <span style=color:#d19a66>0x63</span>, <span style=color:#d19a66>0x64</span>, <span style=color:#d19a66>0x65</span>, <span style=color:#d19a66>0x66</span>, <span style=color:#d19a66>0x67</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x68</span>, <span style=color:#d19a66>0x69</span>, <span style=color:#d19a66>0x6a</span>, <span style=color:#d19a66>0x6b</span>, <span style=color:#d19a66>0x6c</span>, <span style=color:#d19a66>0x6d</span>, <span style=color:#d19a66>0x6e</span>, <span style=color:#d19a66>0x6f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x70</span>, <span style=color:#d19a66>0x71</span>, <span style=color:#d19a66>0x72</span>, <span style=color:#d19a66>0x73</span>, <span style=color:#d19a66>0x74</span>, <span style=color:#d19a66>0x75</span>, <span style=color:#d19a66>0x76</span>, <span style=color:#d19a66>0x77</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x78</span>, <span style=color:#d19a66>0x79</span>, <span style=color:#d19a66>0x7a</span>, <span style=color:#d19a66>0x7b</span>, <span style=color:#d19a66>0x7c</span>, <span style=color:#d19a66>0x7d</span>, <span style=color:#d19a66>0x7e</span>, <span style=color:#d19a66>0x7f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x80</span>, <span style=color:#d19a66>0x81</span>, <span style=color:#d19a66>0x82</span>, <span style=color:#d19a66>0x83</span>, <span style=color:#d19a66>0x84</span>, <span style=color:#d19a66>0x85</span>, <span style=color:#d19a66>0x86</span>, <span style=color:#d19a66>0x87</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x88</span>, <span style=color:#d19a66>0x89</span>, <span style=color:#d19a66>0x8a</span>, <span style=color:#d19a66>0x8b</span>, <span style=color:#d19a66>0x8c</span>, <span style=color:#d19a66>0x8d</span>, <span style=color:#d19a66>0x8e</span>, <span style=color:#d19a66>0x8f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x90</span>, <span style=color:#d19a66>0x91</span>, <span style=color:#d19a66>0x92</span>, <span style=color:#d19a66>0x93</span>, <span style=color:#d19a66>0x94</span>, <span style=color:#d19a66>0x95</span>, <span style=color:#d19a66>0x96</span>, <span style=color:#d19a66>0x97</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0x98</span>, <span style=color:#d19a66>0x99</span>, <span style=color:#d19a66>0x9a</span>, <span style=color:#d19a66>0x9b</span>, <span style=color:#d19a66>0x9c</span>, <span style=color:#d19a66>0x9d</span>, <span style=color:#d19a66>0x9e</span>, <span style=color:#d19a66>0x9f</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xa0</span>, <span style=color:#d19a66>0xa1</span>, <span style=color:#d19a66>0xa2</span>, <span style=color:#d19a66>0xa3</span>, <span style=color:#d19a66>0xa4</span>, <span style=color:#d19a66>0xa5</span>, <span style=color:#d19a66>0xa6</span>, <span style=color:#d19a66>0xa7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xa8</span>, <span style=color:#d19a66>0xa9</span>, <span style=color:#d19a66>0xaa</span>, <span style=color:#d19a66>0xab</span>, <span style=color:#d19a66>0xac</span>, <span style=color:#d19a66>0xad</span>, <span style=color:#d19a66>0xae</span>, <span style=color:#d19a66>0xaf</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xb0</span>, <span style=color:#d19a66>0xb1</span>, <span style=color:#d19a66>0xb2</span>, <span style=color:#d19a66>0xb3</span>, <span style=color:#d19a66>0xb4</span>, <span style=color:#d19a66>0xb5</span>, <span style=color:#d19a66>0xb6</span>, <span style=color:#d19a66>0xb7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xb8</span>, <span style=color:#d19a66>0xb9</span>, <span style=color:#d19a66>0xba</span>, <span style=color:#d19a66>0xbb</span>, <span style=color:#d19a66>0xbc</span>, <span style=color:#d19a66>0xbd</span>, <span style=color:#d19a66>0xbe</span>, <span style=color:#d19a66>0xbf</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xc0</span>, <span style=color:#d19a66>0xc1</span>, <span style=color:#d19a66>0xc2</span>, <span style=color:#d19a66>0xc3</span>, <span style=color:#d19a66>0xc4</span>, <span style=color:#d19a66>0xc5</span>, <span style=color:#d19a66>0xc6</span>, <span style=color:#d19a66>0xc7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xc8</span>, <span style=color:#d19a66>0xc9</span>, <span style=color:#d19a66>0xca</span>, <span style=color:#d19a66>0xcb</span>, <span style=color:#d19a66>0xcc</span>, <span style=color:#d19a66>0xcd</span>, <span style=color:#d19a66>0xce</span>, <span style=color:#d19a66>0xcf</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xd0</span>, <span style=color:#d19a66>0xd1</span>, <span style=color:#d19a66>0xd2</span>, <span style=color:#d19a66>0xd3</span>, <span style=color:#d19a66>0xd4</span>, <span style=color:#d19a66>0xd5</span>, <span style=color:#d19a66>0xd6</span>, <span style=color:#d19a66>0xd7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xd8</span>, <span style=color:#d19a66>0xd9</span>, <span style=color:#d19a66>0xda</span>, <span style=color:#d19a66>0xdb</span>, <span style=color:#d19a66>0xdc</span>, <span style=color:#d19a66>0xdd</span>, <span style=color:#d19a66>0xde</span>, <span style=color:#d19a66>0xdf</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xe0</span>, <span style=color:#d19a66>0xe1</span>, <span style=color:#d19a66>0xe2</span>, <span style=color:#d19a66>0xe3</span>, <span style=color:#d19a66>0xe4</span>, <span style=color:#d19a66>0xe5</span>, <span style=color:#d19a66>0xe6</span>, <span style=color:#d19a66>0xe7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xe8</span>, <span style=color:#d19a66>0xe9</span>, <span style=color:#d19a66>0xea</span>, <span style=color:#d19a66>0xeb</span>, <span style=color:#d19a66>0xec</span>, <span style=color:#d19a66>0xed</span>, <span style=color:#d19a66>0xee</span>, <span style=color:#d19a66>0xef</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xf0</span>, <span style=color:#d19a66>0xf1</span>, <span style=color:#d19a66>0xf2</span>, <span style=color:#d19a66>0xf3</span>, <span style=color:#d19a66>0xf4</span>, <span style=color:#d19a66>0xf5</span>, <span style=color:#d19a66>0xf6</span>, <span style=color:#d19a66>0xf7</span>,
</span></span><span style=display:flex><span>	<span style=color:#d19a66>0xf8</span>, <span style=color:#d19a66>0xf9</span>, <span style=color:#d19a66>0xfa</span>, <span style=color:#d19a66>0xfb</span>, <span style=color:#d19a66>0xfc</span>, <span style=color:#d19a66>0xfd</span>, <span style=color:#d19a66>0xfe</span>, <span style=color:#d19a66>0xff</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>stringStruct</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>len</span> <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#e06c75>sp</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>string</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>stringStruct</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>stringStruct</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>sp</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>staticuint64s</span>[<span style=color:#d19a66>80</span>])
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>).<span style=color:#e06c75>len</span> = <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>	<span style=color:#e5c07b>println</span>(<span style=color:#e06c75>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用标准转换是最简单也是最安全的，但从上面的源码可以看到，<code>string</code>和<code>[]byte</code>的两个相互转换，都可能出现新的内存分配，并且一定要进行内存的复制。这样的转换在性能敏感的场景下无法满足要求，还好我们还有其他的转换黑魔法😈。</p><h2 id=零拷贝转换>零拷贝转换<a hidden class=anchor aria-hidden=true href=#零拷贝转换>#</a></h2><h3 id=编译器转换>编译器转换<a hidden class=anchor aria-hidden=true href=#编译器转换>#</a></h3><p>其实在上文提到的两个函数旁边，还有一个特殊的函数——<code>slicebytetostringtmp(src/runtime/string.go:154)</code></p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// slicebytetostringtmp returns a &#34;string&#34; referring to the actual []byte bytes.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Callers need to ensure that the returned string will not be used after</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// the calling goroutine modifies the original slice or synchronizes with</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// another goroutine.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// The function is only called when instrumenting</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// and otherwise intrinsified by the compiler.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Some internal compiler optimizations use this function.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// - Used for m[T1{... Tn{..., string(k), ...} ...}] and m[string(k)]</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//   where k is []byte, T1 to Tn is a nesting of struct and array literals.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// - Used for &#34;&lt;&#34;+string(b)+&#34;&gt;&#34; concatenation where b is []byte.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// - Used for string(b)==&#34;foo&#34; comparison where b is []byte.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>slicebytetostringtmp</span>(<span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>byte</span>, <span style=color:#e06c75>n</span> <span style=color:#e5c07b>int</span>) (<span style=color:#e06c75>str</span> <span style=color:#e5c07b>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>raceenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>n</span> &gt; <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>racereadrangepc</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>),
</span></span><span style=display:flex><span>			<span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>n</span>),
</span></span><span style=display:flex><span>			<span style=color:#61afef;font-weight:700>getcallerpc</span>(),
</span></span><span style=display:flex><span>			<span style=color:#e06c75>abi</span>.<span style=color:#61afef;font-weight:700>FuncPCABIInternal</span>(<span style=color:#e06c75>slicebytetostringtmp</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>msanenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>n</span> &gt; <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>msanread</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>), <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>n</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>if</span> <span style=color:#e06c75>asanenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>n</span> &gt; <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#61afef;font-weight:700>asanread</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>), <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>n</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>)
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>len</span> = <span style=color:#e06c75>n</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>抛开无需关心的代码，核心代码只有两句:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>ptr</span>)
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>len</span> = <span style=color:#e06c75>n</span>
</span></span></code></pre></div><p>返回字符串的数据指针str直接指向了<code>[]byte</code>的首地址，而长度直接取<code>[]byte</code>长度。能够如此转换的根本原因是string的底层类型和slice的底层类型内存分布相似，所以可以直接通过修改指针的方式进行转换。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// src/runtime/string.go:238</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>stringStruct</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>str</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>len</span> <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// src/runtime/slice.go:15</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>slice</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>array</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>len</span>   <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>cap</span>   <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可见，两个结构体的前两个字段内存分布是完全一致的，并且<code>string</code>的底层数据类型和<code>[]byte</code>一致，所以<code>unsafe.Pointer</code>对应的实际指针都是<code>*byte</code>。这样的转换实际上就是指针的转换，不需要进行内存的分配和复制，所以效率非常高。</p><style type=text/css media=screen>html{--color-alert-info-text:#24292e;--color-alert-info-bg:#dbedff;--color-alert-info-border:rgba(4, 66, 137, 0.2);--color-alert-warn-text:#24292e;--color-alert-warn-bg:#fffbdd;--color-alert-warn-border:rgba(176, 136, 0, 0.2);--color-alert-error-text:#24292e;--color-alert-error-bg:#ffe3e6;--color-alert-error-border:rgba(158, 28, 35, 0.2);--color-alert-success-text:#24292e;--color-alert-success-bg:#dcffe4;--color-alert-success-border:rgba(23, 111, 44, 0.2)}html[data-theme=dark]{--color-alert-info-text:#79c0ff;--color-alert-info-bg:rgba(56, 139, 253, 0.1);--color-alert-info-border:rgba(56, 139, 253, 0.4);--color-alert-warn-text:#e3b341;--color-alert-warn-bg:rgba(187, 128, 9, 0.1);--color-alert-warn-border:rgba(187, 128, 9, 0.4);--color-alert-error-text:#ff7b72;--color-alert-error-bg:rgba(248, 81, 73, 0.1);--color-alert-error-border:rgba(248, 81, 73, 0.4);--color-alert-success-text:#56d364;--color-alert-success-bg:rgba(46, 160, 67, 0.1);--color-alert-success-border:rgba(46, 160, 67, 0.4)}.tips{position:relative;padding:20px 16px;margin-bottom:20px;border-style:solid;border-width:1px;border-radius:6px;border-left-style:solid;border-left-width:6px}.tips.info{color:var(--color-alert-info-text);background-image:linear-gradient(var(--color-alert-info-bg),var(--color-alert-info-bg));border-color:var(--color-alert-info-border)}.tips.warn{color:var(--color-alert-warn-text);background-image:linear-gradient(var(--color-alert-warn-bg),var(--color-alert-warn-bg));border-color:var(--color-alert-warn-border)}.tips.error{color:var(--color-alert-error-text);background-image:linear-gradient(var(--color-alert-error-bg),var(--color-alert-error-bg));border-color:var(--color-alert-error-border)}.tips.success{color:var(--color-alert-success-text);background-image:linear-gradient(var(--color-alert-success-bg),var(--color-alert-success-bg));border-color:var(--color-alert-success-border)}#tips-title{font-size:19px;font-weight:800;margin-bottom:10px}</style><div class="tips warn"><p>但是使用这样的代码是有风险的，上文中的代码我特意把注释也贴出来了，注释里第二段明确写到，调用者需要保证，在修改或与其他g同步了<code>原[]byte</code>后，返回的<code>string</code>不会再被使用。这是因为你<strong>强行创造</strong>的这个<code>string</code>所对应的底层数据并不安全，创造出该string后，你可以直接对<code>原[]byte</code>进行修改，这违背了go语言字符串不可修改的原则，将会产生无法捕获的错误。</p><p>所以这个方法go没有暴露给开发者，仅在源码内部可使用，供编译器在某些适用场景优化性能。</p></div><p>以上两种转换的性能对比:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>const</span> <span style=color:#e06c75>LEN</span> = <span style=color:#d19a66>33</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getBytes</span>() []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>LEN</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>b</span> = <span style=color:#e5c07b>append</span>(<span style=color:#e06c75>b</span>, <span style=color:#98c379>&#39; &#39;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkByte2StringOrigin</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bytes</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getBytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>s</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>string</span>(<span style=color:#e06c75>bytes</span>)
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>s</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkByte2StringTmp</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bytes</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getBytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>s</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>slicebytetostringtmp</span>(<span style=color:#e06c75>bytes</span>)
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>s</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 依赖代码</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>stringStruct</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>len</span> <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#e06c75>sp</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>string</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>stringStruct</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>stringStruct</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>sp</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>slicebytetostringtmp</span>(<span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>) (<span style=color:#e06c75>str</span> <span style=color:#e5c07b>string</span>) {
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>str</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>[<span style=color:#d19a66>0</span>])
</span></span><span style=display:flex><span>	<span style=color:#61afef;font-weight:700>stringStructOf</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>).<span style=color:#e06c75>len</span> = <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302011436253.png alt=长度为5的[]byte></p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302011437519.png alt=长度32的[]byte></p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302011438301.png alt=长度为33的[]byte></p><p>和之前源码看到的一致，对于标准转换，长度32是一个分水岭，长度大于32时，就会出现内存分配，同时操作耗时也显著增加。并且随着<code>slice</code>长度的增加，和指针转换的性能差距会越来越大。</p><h2 id=自己实现unsafepointer>自己实现——unsafe.Pointer<a hidden class=anchor aria-hidden=true href=#自己实现unsafepointer>#</a></h2><p>虽然<code>slicebytetostringtmp</code>我们无法使用，但是通过使用<code>unsafe</code>包，我们可以自行构造类似的指针转换。</p><p>先来一个最简单的版本:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>String2bytesEasy</span>(<span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span>[]<span style=color:#e5c07b>byte</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>Bytes2StringEasy</span>(<span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>) <span style=color:#e5c07b>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e5c07b>string</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>直接使用<code>unsafe.Pointer</code>作为中间类型进行强转，非常快速，但是会有一个小问题，<code>String2bytesEasy</code>函数中，返回的<code>slice</code>中<code>cap</code>字段是没有赋值的，因为<code>string</code>类型只有两个字段，而<code>slice</code>有三个，未赋值的<code>cap</code>字段的值是随机的，取决于那一块内存的值。</p><p>优化版本:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// src/reflect/value.go:2670</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>StringHeader</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Data</span> <span style=color:#e5c07b>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Len</span>  <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// src/reflect/value.go:2681</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>type</span> <span style=color:#e06c75>SliceHeader</span> <span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Data</span> <span style=color:#e5c07b>uintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Len</span>  <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>Cap</span>  <span style=color:#e5c07b>int</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>String2bytes</span>(<span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>stringHeader</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>StringHeader</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>SliceHeader</span>{
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Data</span>: <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Data</span>,
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Len</span>:  <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Len</span>,
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Cap</span>:  <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Len</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span>[]<span style=color:#e5c07b>byte</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>bh</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个版本用到了<code>reflect</code>包中的两个类型<code>StringHeader</code>和<code>SliceHeader</code>，它们分别是<code>string</code>和<code>slice</code>的<code>runtime</code>层形态。通过这样的转换后，我们得以直接操作它们的字段。</p><p>通过全部的三个字段赋值，最终得到的是一个完整的<code>slice</code>。</p><div class="tips warn">但是这里的代码还隐藏了一个深层次的问题</div><p>继续深挖，这里的关键是我们创建的中间变量<code>bh</code>，特殊点在于它的类型<code>reflect.SliceHeader</code>。如果你打开过源码的<code>unsafe</code>包，在<code>Point</code>类型的开头有一大堆注释(以下仅部分):</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// (6) Conversion of a reflect.SliceHeader or reflect.StringHeader Data field to or from Pointer.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// As in the previous case, the reflect data structures SliceHeader and StringHeader</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// declare the field Data as a uintptr to keep callers from changing the result to</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// an arbitrary type without first importing &#34;unsafe&#34;. However, this means that</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// SliceHeader and StringHeader are only valid when interpreting the content</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// of an actual slice or string value.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	var s string</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	hdr.Data = uintptr(unsafe.Pointer(p))              // case 6 (this case)</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	hdr.Len = n</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// In this usage hdr.Data is really an alternate way to refer to the underlying</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// pointer in the string header, not a uintptr variable itself.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// In general, reflect.SliceHeader and reflect.StringHeader should be used</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// only as *reflect.SliceHeader and *reflect.StringHeader pointing at actual</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// slices or strings, never as plain structs.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// A program should not declare or allocate variables of these struct types.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	// INVALID: a directly-declared header will not hold Data as a reference.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	var hdr reflect.StringHeader</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	hdr.Data = uintptr(unsafe.Pointer(p))</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	hdr.Len = n</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	s := *(*string)(unsafe.Pointer(&amp;hdr)) // p possibly already lost</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span></code></pre></div><p>重点就是这一句——INVALID: a directly-declared header will not hold Data as a reference.</p><p>翻译过来就是，一个直接声明的header不会将Data作为引用。</p><p>解释一下，Header的Data字段类型是<code>uintptr</code>而不是<code>unsafe.Pointer</code>，这两个类型的其中一个差别就是，go的gc不会记录<code>uintptr</code>的引用，这一点在<code>SliceHeader</code>和<code>StringHeader</code>的定义处也有注释进行了说明，它们俩的定义上方都有这么一段:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// Moreover, the Data field is not sufficient to guarantee the data</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// it references will not be garbage collected, so programs must keep</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// a separate, correctly typed pointer to the underlying data.</span>
</span></span></code></pre></div><p>这意味着gc在清理内存时并不知道还存在一个Header的Data字段指向了这块内存，就可能会导致在转换的过程中，底层数据已经被gc给清理。</p><p>对应上面的例子中:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>String2bytes</span>(<span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>stringHeader</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>StringHeader</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>SliceHeader</span>{
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Data</span>: <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Data</span>,
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Len</span>:  <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Len</span>,
</span></span><span style=display:flex><span>		<span style=color:#e06c75>Cap</span>:  <span style=color:#e06c75>stringHeader</span>.<span style=color:#e06c75>Len</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#7f848e>// 在执行这一步之前，stringHeader已经没有了用处，而bh没有产生引用，此时gc认为是可以进行回收的</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span>[]<span style=color:#e5c07b>byte</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>bh</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>避免这个问题的方法也很简单，避开<code>directly-declared</code>就可以了，注释中也给了一个正确例子:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>var</span> <span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>hdr</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>StringHeader</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>)) <span style=color:#7f848e>// case 1</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>hdr</span>.<span style=color:#e06c75>Data</span> = <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>p</span>))              <span style=color:#7f848e>// case 6 (this case)</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>hdr</span>.<span style=color:#e06c75>Len</span> = <span style=color:#e06c75>n</span>
</span></span></code></pre></div><p>这里先创建了临时变量s，再基于s进行转换得到的header指针，所以这里并不存在一个<strong>实际的header</strong>，对hdr的赋值操作其实是在直接操作字符串s，所以也就没有了gc追踪不到的问题了。</p><p>贴一个优化代码示例:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>b2s</span>(<span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>) <span style=color:#e5c07b>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e5c07b>string</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>S2b</span>(<span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) (<span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>SliceHeader</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>))
</span></span><span style=display:flex><span>	<span style=color:#e06c75>sh</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>reflect</span>.<span style=color:#e06c75>StringHeader</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>s</span>))
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span>.<span style=color:#e06c75>Data</span> = <span style=color:#e06c75>sh</span>.<span style=color:#e06c75>Data</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span>.<span style=color:#e06c75>Len</span> = <span style=color:#e06c75>sh</span>.<span style=color:#e06c75>Len</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bh</span>.<span style=color:#e06c75>Cap</span> = <span style=color:#e06c75>sh</span>.<span style=color:#e06c75>Len</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>b</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=补充>补充<a hidden class=anchor aria-hidden=true href=#补充>#</a></h3><p>关于这个问题，我还找到一个go源码库的issue：<a href=https://github.com/golang/go/issues/25484>Feature: provide no-copy conversion from []byte to string</a>，虽然issue的发起者是想问为什么没有官方提供的转换函数，但是他提供的代码有着和我所给的反例代码一样的问题，并且被其他用户指出来了，并且这个问题得到了go的组织成员的肯定：</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302011956539.png alt=image-20230201195628479></p><p>有趣的是，go101(应该有人认识吧)还在下面提出即使避开了header的直接定义，还是需要使用<code>runtime.KeepAlive</code>来保证gc不会回收数据，这就与我本文观点冲突了🤣。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302011959967.png alt=image-20230201195952921></p><p>不过好在这条在下面被反对了👀</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302012003206.png alt=image-20230201200316161></p><p>至于为什么不把reflect包中header的Data字段改为unsafe.Pointer来解决这个问题，也有了解释：</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302012008314.png alt=image-20230201200812265></p><p>这里面提到的另外的issue:</p><p><a href=https://github.com/golang/go/issues/19367>unsafe: add Slice(ptr *T, len anyIntegerType) []T</a></p><p><a href=https://github.com/golang/go/issues/20171>proposal: spec: disallow T&lt;->uintptr conversion for type T unsafe.Pointer</a></p><p>另外，我觉得该issue的发起人说的话挺有道理的，这段转换的代码藏了很深的坑，没有对源码有一定了解的人完全无法发现，而官方又没有提供转换的最佳实践，以致于网络上出现了各种自行实现的版本，而其中许多的实现都是存在问题的。</p><p>幸好，这个问题在Go2迎来了转机。</p><h2 id=展望未来go120>展望未来，Go1.20<a hidden class=anchor aria-hidden=true href=#展望未来go120>#</a></h2><p>在go1.20rc中的这个<a href=https://github.com/golang/go/commit/42768b4c265065df9b7faeb9df0301ef64b271a2>提交</a>，为<code>slice</code>和<code>string</code>的转换提供了新的选择，该提交在unsafe包中新增了四个函数<a href=https://github.com/golang/go/blob/release-branch.go1.20/src/unsafe/unsafe.go>https://github.com/golang/go/blob/release-branch.go1.20/src/unsafe/unsafe.go</a>:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// The function Slice returns a slice whose underlying array starts at ptr</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// and whose length and capacity are len.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Slice(ptr, len) is equivalent to</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//	(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// except that, as a special case, if ptr is nil and len is zero,</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Slice returns nil.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// The len argument must be of integer type or an untyped constant.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// A constant len argument must be non-negative and representable by a value of type int;</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// if it is an untyped constant it is given type int.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// At run time, if len is negative, or if ptr is nil and len is not zero,</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// a run-time panic occurs.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>Slice</span>(<span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>ArbitraryType</span>, <span style=color:#e06c75>len</span> <span style=color:#e06c75>IntegerType</span>) []<span style=color:#e06c75>ArbitraryType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// SliceData returns a pointer to the underlying array of the argument</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// slice.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//   - If cap(slice) &gt; 0, SliceData returns &amp;slice[:1][0].</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//   - If slice == nil, SliceData returns nil.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//   - Otherwise, SliceData returns a non-nil pointer to an</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//     unspecified memory address.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>SliceData</span>(<span style=color:#e06c75>slice</span> []<span style=color:#e06c75>ArbitraryType</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>ArbitraryType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// String returns a string value whose underlying bytes</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// start at ptr and whose length is len.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// The len argument must be of integer type or an untyped constant.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// A constant len argument must be non-negative and representable by a value of type int;</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// if it is an untyped constant it is given type int.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// At run time, if len is negative, or if ptr is nil and len is not zero,</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// a run-time panic occurs.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Since Go strings are immutable, the bytes passed to String</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// must not be modified afterwards.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>String</span>(<span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>byte</span>, <span style=color:#e06c75>len</span> <span style=color:#e06c75>IntegerType</span>) <span style=color:#e5c07b>string</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// StringData returns a pointer to the underlying bytes of str.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// For an empty string the return value is unspecified, and may be nil.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>//</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// Since Go strings are immutable, the bytes returned by StringData</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// must not be modified.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>StringData</span>(<span style=color:#e06c75>str</span> <span style=color:#e5c07b>string</span>) <span style=color:#56b6c2>*</span><span style=color:#e5c07b>byte</span>
</span></span></code></pre></div><p>由于unsafe包的特殊性，其函数的具体实现是通过汇编等手段实现的，所以你在这里只能看到函数签名。</p><p>简单介绍下四个函数的作用:</p><ul><li>Slice：返回一个slice，其底层数组的起始地址即为参数ptr所指向的地址，slice的len和cap都为参数len。</li><li>SliceData: 返回一个指向该slice底层数组的指针。</li><li>String：返回一个string，其底层的byte数组的起始地址即为参数ptr所指向的地址，长度为参数len。</li><li>StringData: 返回参数str底层byte数组的指针。</li></ul><p>这四个函数提供的功能非常基础，不过组合起来就能实现我们想要的字符串转换功能了,如果不想安装go1.20rc，你可以在<a href="https://go.dev/play/p/1scbUmFP3FC?v=gotip">这里</a>去试用这四个函数:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#56b6c2>:=</span> <span style=color:#98c379>&#34;hello world!&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bt</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Slice</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>StringData</span>(<span style=color:#e06c75>str</span>), <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>str</span>))
</span></span><span style=display:flex><span>	<span style=color:#e06c75>fmt</span>.<span style=color:#61afef;font-weight:700>Println</span>(<span style=color:#e06c75>bt</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有了这个写法，reflect的headers就可以弃用了。</p><p>附上三种转换的benchmark(IDE可能会报错，但是没事，go1.20可以执行)：</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>package</span> <span style=color:#e06c75>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#98c379>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>const</span> <span style=color:#e06c75>LEN</span> = <span style=color:#d19a66>33</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getBytes</span>() []<span style=color:#e5c07b>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>var</span> <span style=color:#e06c75>b</span> []<span style=color:#e5c07b>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>LEN</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>b</span> = <span style=color:#e5c07b>append</span>(<span style=color:#e06c75>b</span>, <span style=color:#98c379>&#39; &#39;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e06c75>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>getStr</span>() <span style=color:#e5c07b>string</span> {
</span></span><span style=display:flex><span>	<span style=color:#c678dd>return</span> <span style=color:#e5c07b>string</span>(<span style=color:#61afef;font-weight:700>getBytes</span>())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkString2Slice</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getStr</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>bt</span> <span style=color:#56b6c2>:=</span> []<span style=color:#e5c07b>byte</span>(<span style=color:#e06c75>str</span>)
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>bt</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkString2SliceReflect</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getStr</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>bt</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span>[]<span style=color:#e5c07b>byte</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>str</span>))
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>bt</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkString2SliceUnsafe</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>str</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getStr</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>bt</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Slice</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>StringData</span>(<span style=color:#e06c75>str</span>), <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>str</span>))
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>bt</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkSlice2String</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bytes</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getBytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>ss</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>string</span>(<span style=color:#e06c75>bytes</span>)
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>ss</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkSlice2StringReflect</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bytes</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getBytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>ss</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e5c07b>string</span>)(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>bytes</span>))
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>ss</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>BenchmarkSlice2StringUnsafe</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>testing</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>	<span style=color:#e06c75>bytes</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getBytes</span>()
</span></span><span style=display:flex><span>	<span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>b</span>.<span style=color:#e06c75>N</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#e06c75>ss</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>String</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>SliceData</span>(<span style=color:#e06c75>bytes</span>), <span style=color:#e5c07b>len</span>(<span style=color:#e06c75>bytes</span>))
</span></span><span style=display:flex><span>		<span style=color:#e06c75>_</span> = <span style=color:#e06c75>ss</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202302021120164.png alt=对比结果></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>Golang</a></li><li><a href=https://www.yici.xin/tags/string/>String</a></li></ul><nav class=paginav><a class=next href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><span class=title>下一页 »</span><br><span>Golang-map的操作</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>绝知</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
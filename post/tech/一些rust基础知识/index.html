<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>一些rust基础知识 | yicixin's blog</title>
<meta name=keywords content="rust"><meta name=description content="变量与可变性 变量的可变性 rust中进行变量的声明时，使用let关键字，如:
let x; 这样声明出来的变量是不可变的，不可以进行第二次赋值。 如果需要后续可以修改这个变量，在声明时需要加上mut关键字:
let mut x; 常量 声明常量使用 const 关键字而不是 let，并且必须注明值的类型，且声明时就必须赋值。
// ✅ const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60; // ❌ const THREE_HOURS_IN_SECONDS: u32; THREE_HOURS_IN_SECONDS = 3 * 60 * 60 不可变变量与常量有什么区别呢?
首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。 内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。 隐藏 rust中，可以使用let定义一个与之前变量同名的新变量，此时同名的第一个变量隐藏了。
fn main() { // 定义x let x = 5; // 再次定义x，此时第一个x被隐藏 let x = 6; { // 再次定义x，但是仅在该作用域内生效 let x = x * 2; println!(&#34;The value of x in the inner scope is: {x}&#34;); // 12 } println!"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/%E4%B8%80%E4%BA%9Brust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b35f27175e1d679d5ac37249ed25e28b57702f4740c052621132f937b795fa44.css integrity="sha256-s18nF14dZ51aw3JJ7SXii1dwL0dAwFJiETL5N7eV+kQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="一些rust基础知识"><meta property="og:description" content="变量与可变性 变量的可变性 rust中进行变量的声明时，使用let关键字，如:
let x; 这样声明出来的变量是不可变的，不可以进行第二次赋值。 如果需要后续可以修改这个变量，在声明时需要加上mut关键字:
let mut x; 常量 声明常量使用 const 关键字而不是 let，并且必须注明值的类型，且声明时就必须赋值。
// ✅ const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60; // ❌ const THREE_HOURS_IN_SECONDS: u32; THREE_HOURS_IN_SECONDS = 3 * 60 * 60 不可变变量与常量有什么区别呢?
首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。 内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。 隐藏 rust中，可以使用let定义一个与之前变量同名的新变量，此时同名的第一个变量隐藏了。
fn main() { // 定义x let x = 5; // 再次定义x，此时第一个x被隐藏 let x = 6; { // 再次定义x，但是仅在该作用域内生效 let x = x * 2; println!(&#34;The value of x in the inner scope is: {x}&#34;); // 12 } println!"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/%E4%B8%80%E4%BA%9Brust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-21T18:14:01+08:00"><meta property="article:modified_time" content="2022-12-21T18:14:01+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="一些rust基础知识"><meta name=twitter:description content="变量与可变性 变量的可变性 rust中进行变量的声明时，使用let关键字，如:
let x; 这样声明出来的变量是不可变的，不可以进行第二次赋值。 如果需要后续可以修改这个变量，在声明时需要加上mut关键字:
let mut x; 常量 声明常量使用 const 关键字而不是 let，并且必须注明值的类型，且声明时就必须赋值。
// ✅ const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60; // ❌ const THREE_HOURS_IN_SECONDS: u32; THREE_HOURS_IN_SECONDS = 3 * 60 * 60 不可变变量与常量有什么区别呢?
首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。 内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。 隐藏 rust中，可以使用let定义一个与之前变量同名的新变量，此时同名的第一个变量隐藏了。
fn main() { // 定义x let x = 5; // 再次定义x，此时第一个x被隐藏 let x = 6; { // 再次定义x，但是仅在该作用域内生效 let x = x * 2; println!(&#34;The value of x in the inner scope is: {x}&#34;); // 12 } println!"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"一些rust基础知识","item":"https://www.yici.xin/post/tech/%E4%B8%80%E4%BA%9Brust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一些rust基础知识","name":"一些rust基础知识","description":"变量与可变性 变量的可变性 rust中进行变量的声明时，使用let关键字，如:\nlet x; 这样声明出来的变量是不可变的，不可以进行第二次赋值。 如果需要后续可以修改这个变量，在声明时需要加上mut关键字:\nlet mut x; 常量 声明常量使用 const 关键字而不是 let，并且必须注明值的类型，且声明时就必须赋值。\n// ✅ const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60; // ❌ const THREE_HOURS_IN_SECONDS: u32; THREE_HOURS_IN_SECONDS = 3 * 60 * 60 不可变变量与常量有什么区别呢?\n首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。 内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。 隐藏 rust中，可以使用let定义一个与之前变量同名的新变量，此时同名的第一个变量隐藏了。\nfn main() { // 定义x let x = 5; // 再次定义x，此时第一个x被隐藏 let x = 6; { // 再次定义x，但是仅在该作用域内生效 let x = x * 2; println!(\u0026#34;The value of x in the inner scope is: {x}\u0026#34;); // 12 } println!","keywords":["rust"],"articleBody":"变量与可变性 变量的可变性 rust中进行变量的声明时，使用let关键字，如:\nlet x; 这样声明出来的变量是不可变的，不可以进行第二次赋值。 如果需要后续可以修改这个变量，在声明时需要加上mut关键字:\nlet mut x; 常量 声明常量使用 const 关键字而不是 let，并且必须注明值的类型，且声明时就必须赋值。\n// ✅ const THREE_HOURS_IN_SECONDS: u32 = 3 * 60 * 60; // ❌ const THREE_HOURS_IN_SECONDS: u32; THREE_HOURS_IN_SECONDS = 3 * 60 * 60 不可变变量与常量有什么区别呢?\n首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。 内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。 隐藏 rust中，可以使用let定义一个与之前变量同名的新变量，此时同名的第一个变量隐藏了。\nfn main() { // 定义x let x = 5; // 再次定义x，此时第一个x被隐藏 let x = 6; { // 再次定义x，但是仅在该作用域内生效 let x = x * 2; println!(\"The value of x in the inner scope is: {x}\"); // 12 } println!(\"The value of x is: {x}\"); // 6 } 请注意文中的用词含义，是隐藏而不是覆盖，因为此时存在真实的两个变量，而不是对第一个变量进行再次赋值。 乍看这个机制看着并不是很有用，特别是在不同作用域中的重名定义，这在其他的编程语言是很常见的。其实该机制的主要作用体现在变量的重复定义时，是可以修改变量的类型的。例如:\n// ✅ let spaces = \" \"; let spaces = spaces.len(); 这里的spaces标识符所对应的变量从字符串类型变量改成了另一个整数类型变量，在后续的代码中你可以继续使用这个spaces变量名而不用定义一个新的变量名来记录字符串长度，类似于spaces_length。在同一作用域下的重复定义，这种行为在其他的编程语言的编译器眼中一般都种错误。\n数据类型 标量类型 整型 Rust 中的整型:\n长度 有符号 无符号 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize isize 和 usize 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。\nRust 中的整型字面值:\n数字字面值 例子 Decimal (十进制) 98_222 Hex (十六进制) 0xff Octal (八进制) 0o77 Binary (二进制) 0b1111_0000 Byte (单字节字符)(仅限于u8) b’A' 整形溢出问题\n比方说有一个 u8 ，它可以存放从零到 255 的值。那么当你将其修改为 256 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），这会导致以下两种行为之一的发生。\n当在 debug 模式编译时，Rust 检查这类问题并使程序 panic。 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（two’s complement wrapping）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 256 变成 0，值 257 变成 1，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，Wrapping。 浮点数 Rust 也有两个原生的 浮点数（floating-point numbers）类型，它们是带小数点的数字。Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64，因为在现代 CPU 中，它与 f32 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。\nfn main() { let x = 2.0; // f64 let y: f32 = 3.0; // f32 } 布尔类型 正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：true 和 false。Rust 中的布尔类型使用 bool 表示。例如：\nfn main() { let t = true; let f: bool = false; // with explicit type annotation } 字符 Rust的 char 类型是语言中最原生的字母类型。下面是一些声明 char 值的例子：\nfn main() { let c = 'z'; let z: char = 'ℤ'; // with explicit type annotation let heart_eyed_cat = '😻'; } 用单引号声明 char 字面量，使用双引号声明字符串字面量。 Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。\n在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值。\nUnicode 标量值包含从 U+0000 到 U+D7FF 和 U+E000 到 U+10FFFF 在内的值。 “使用字符串存储 UTF-8 编码的文本” 中将详细讨论这个主题。\n复合类型 复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。\n元组 元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); } 创建元组的语法如上，元组中的每一个位置都有一个类型，而且这些不同值的类型不必相同的。这个例子中使用了可选的类型注解：\nfn main() { let tup: (i32, f64, u8) = (500, 6.4, 1); // ✅ or let tup = (500, 6.4, 1); // ✅ } 元组解构:\nfn main() { let tup = (500, 6.4, 1); let (x, y, z) = tup; println!(\"The value of y is: {y}\"); } 访问元组中的元素，下标从0开始:\nfn main() { let x: (i32, f64, u8) = (500, 6.4, 1); let five_hundred = x.0; let six_point_four = x.1; let one = x.2; } 不带任何值的元组有个特殊的名称，叫做 单元（unit） 元组。这种值以及对应的类型都写作 ()，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。 数组 另一个包含多个值的方式是 数组（array）。与元组不同，数组中的每个元素的类型必须相同。 声明数组的方式:\nfn main() { let a = [1, 2, 3, 4, 5]; } 和go语言一样，数组都是大小固定的，如果需要类slice的可变长数组，rust中使用标准库提供的vector。 一些支持的写法:\n// 这里，i32是每个元素的类型。分号之后，数字5表明该数组包含五个元素。 let a: [i32; 5] = [1, 2, 3, 4, 5]; // 变量名为a的数组将包含5个元素，这些元素的值最初都将被设置为3。 let a = [3; 5]; 访问数组元素:\nfn main() { let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; } 函数 Rust 代码中的函数和变量名使用 snake case 规范风格，所有字母都是小写并使用下划线分隔单词。\nfn main() { println!(\"Hello, world!\"); another_function(); } fn another_function() { println!(\"Another function.\"); } 使用fn关键字声明函数。\n参数 我们可以定义为拥有 参数（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（arguments）。\n在函数签名中，必须 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。\nfn main() { print_labeled_measurement(5, 'h'); } fn print_labeled_measurement(value: i32, unit_label: char) { println!(\"The measurement is: {value}{unit_label}\"); } 语句和表达式 语句（Statements）是执行一些操作但不返回值的指令。\nfn main() { let y = 6; // 语句 let x = (let y = 6); // ❌ } let y = 6 语句并不返回值，所以没有可以绑定到 x 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 x = y = 6，这样 x 和 y 的值都是 6；Rust 中不能这样写。\n表达式（Expressions）计算并产生一个值。大部分 Rust 代码是由表达式组成的。考虑一个数学运算，比如 5 + 6，这是一个表达式并计算出值 11。表达式可以是语句的一部分：语句 let y = 6; 中的 6 是一个表达式，它计算出的值是 6。函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如：\nfn main() { let y = { let x = 3; x + 1 // 注意这里结尾处没有分号 }; println!(\"The value of y is: {y}\"); } 函数返回值 fn main() { let x = plus_one(5); println!(\"The value of x is: {x}\"); } fn plus_one(x: i32) -\u003e i32 { x + 1 // 表达式形式返回 ✅ or return x + 1; // 语句形式返回 ✅ } rust中不可以像go一样对返回值命名，使用-\u003e并提供返回值类型。\n控制流 if表达式 if是表达式而不是语句 if是表达式，可以返回值，所以可以在let的右侧使用它:\nfn main() { let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {number}\"); } 这里的if有两个分支，对应两个表达式，最终返回的就是匹配分支对应表达式的值，所以这里也要求所有分支对应表达式必须返回同类型的值，如果不匹配会报错。\nfn main() { let condition = true; let number = if condition { 5 } else { \"six\" }; // ❌ 两个表达式返回的类型不一致 println!(\"The value of number is: {number}\"); } 循环 Rust 有三种循环：loop、while 和 for。\nloop关键字搭配break和continue使用:\nfn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } else { continue; }; }; println!(\"The result is {result}\"); } 如上是一个loop表达式，在loop内部可以通过break产出值。 当然，利用if表达式，也可以这么写:\nfn main() { let mut counter = 0; let result = loop { counter += 1; break if counter == 10 { counter * 2 } else { continue }; }; println!(\"The result is {result}\"); } 循环标签\nfn main() { let mut count = 0; // 给定循环标签counting_up 'counting_up: loop { println!(\"count = {count}\"); let mut remaining = 10; loop { println!(\"remaining = {remaining}\"); if remaining == 9 { break; } if count == 2 { // 直接跳出整个循环 break 'counting_up; } remaining -= 1; } count += 1; } println!(\"End count = {count}\"); } while条件循环\nfn main() { let mut number = 3; while number != 0 { println!(\"{number}!\"); number -= 1; } println!(\"LIFTOFF!!!\"); } for遍历\nfn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {element}\"); } } ","wordCount":"868","inLanguage":"zh","datePublished":"2022-12-21T18:14:01+08:00","dateModified":"2022-12-21T18:14:01+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/%E4%B8%80%E4%BA%9Brust%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>一些rust基础知识</h1><div class=post-meta><span title='2022-12-21 18:14:01 +0800 +0800'>2022-12-21</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%8f%98%e9%87%8f%e4%b8%8e%e5%8f%af%e5%8f%98%e6%80%a7 aria-label=变量与可变性>变量与可变性</a><ul><li><a href=#%e5%8f%98%e9%87%8f%e7%9a%84%e5%8f%af%e5%8f%98%e6%80%a7 aria-label=变量的可变性>变量的可变性</a></li><li><a href=#%e5%b8%b8%e9%87%8f aria-label=常量>常量</a></li><li><a href=#%e9%9a%90%e8%97%8f aria-label=隐藏>隐藏</a></li></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=数据类型>数据类型</a><ul><li><a href=#%e6%a0%87%e9%87%8f%e7%b1%bb%e5%9e%8b aria-label=标量类型>标量类型</a><ul><li><a href=#%e6%95%b4%e5%9e%8b aria-label=整型>整型</a></li><li><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0 aria-label=浮点数>浮点数</a></li><li><a href=#%e5%b8%83%e5%b0%94%e7%b1%bb%e5%9e%8b aria-label=布尔类型>布尔类型</a></li><li><a href=#%e5%ad%97%e7%ac%a6 aria-label=字符>字符</a></li></ul></li><li><a href=#%e5%a4%8d%e5%90%88%e7%b1%bb%e5%9e%8b aria-label=复合类型>复合类型</a><ul><li><a href=#%e5%85%83%e7%bb%84 aria-label=元组>元组</a></li><li><a href=#%e6%95%b0%e7%bb%84 aria-label=数组>数组</a></li></ul></li></ul></li><li><a href=#%e5%87%bd%e6%95%b0 aria-label=函数>函数</a><ul><ul><li><a href=#%e5%8f%82%e6%95%b0 aria-label=参数>参数</a></li><li><a href=#%e8%af%ad%e5%8f%a5%e5%92%8c%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=语句和表达式>语句和表达式</a></li><li><a href=#%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc aria-label=函数返回值>函数返回值</a></li></ul></ul></li><li><a href=#%e6%8e%a7%e5%88%b6%e6%b5%81 aria-label=控制流>控制流</a><ul><li><a href=#if%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=if表达式>if表达式</a></li><li><a href=#%e5%be%aa%e7%8e%af aria-label=循环>循环</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=变量与可变性>变量与可变性<a hidden class=anchor aria-hidden=true href=#变量与可变性>#</a></h2><h3 id=变量的可变性>变量的可变性<a hidden class=anchor aria-hidden=true href=#变量的可变性>#</a></h3><p>rust中进行变量的声明时，使用<code>let</code>关键字，如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> x;
</span></span></code></pre></div><p>这样声明出来的变量是不可变的，不可以进行第二次赋值。
如果需要后续可以修改这个变量，在声明时需要加上<code>mut</code>关键字:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> x;
</span></span></code></pre></div><h3 id=常量>常量<a hidden class=anchor aria-hidden=true href=#常量>#</a></h3><p>声明常量使用 <code>const</code> 关键字而不是 <code>let</code>，并且<strong>必须</strong>注明值的类型，且声明时就必须赋值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>THREE_HOURS_IN_SECONDS</span>: <span style=color:#66d9ef>u32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ❌
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>THREE_HOURS_IN_SECONDS</span>: <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>THREE_HOURS_IN_SECONDS</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>60</span>
</span></span></code></pre></div><style type=text/css media=screen>html{--color-alert-info-text:#24292e;--color-alert-info-bg:#dbedff;--color-alert-info-border:rgba(4, 66, 137, 0.2);--color-alert-warn-text:#24292e;--color-alert-warn-bg:#fffbdd;--color-alert-warn-border:rgba(176, 136, 0, 0.2);--color-alert-error-text:#24292e;--color-alert-error-bg:#ffe3e6;--color-alert-error-border:rgba(158, 28, 35, 0.2);--color-alert-success-text:#24292e;--color-alert-success-bg:#dcffe4;--color-alert-success-border:rgba(23, 111, 44, 0.2)}html[data-theme=dark]{--color-alert-info-text:#79c0ff;--color-alert-info-bg:rgba(56, 139, 253, 0.1);--color-alert-info-border:rgba(56, 139, 253, 0.4);--color-alert-warn-text:#e3b341;--color-alert-warn-bg:rgba(187, 128, 9, 0.1);--color-alert-warn-border:rgba(187, 128, 9, 0.4);--color-alert-error-text:#ff7b72;--color-alert-error-bg:rgba(248, 81, 73, 0.1);--color-alert-error-border:rgba(248, 81, 73, 0.4);--color-alert-success-text:#56d364;--color-alert-success-bg:rgba(46, 160, 67, 0.1);--color-alert-success-border:rgba(46, 160, 67, 0.4)}.tips{position:relative;padding:20px 16px;margin-bottom:20px;border-style:solid;border-width:1px;border-radius:6px;border-left-style:solid;border-left-width:6px}.tips.info{color:var(--color-alert-info-text);background-image:linear-gradient(var(--color-alert-info-bg),var(--color-alert-info-bg));border-color:var(--color-alert-info-border)}.tips.warn{color:var(--color-alert-warn-text);background-image:linear-gradient(var(--color-alert-warn-bg),var(--color-alert-warn-bg));border-color:var(--color-alert-warn-border)}.tips.error{color:var(--color-alert-error-text);background-image:linear-gradient(var(--color-alert-error-bg),var(--color-alert-error-bg));border-color:var(--color-alert-error-border)}.tips.success{color:var(--color-alert-success-text);background-image:linear-gradient(var(--color-alert-success-bg),var(--color-alert-success-bg));border-color:var(--color-alert-success-border)}#tips-title{font-size:19px;font-weight:800;margin-bottom:10px}</style><div class="tips info"><p id=tips-title>不可变变量与常量有什么区别呢?</p>首先一个区别是，声明常量时提供的值必须是编译期间就可以计算出来的，而不可变变量虽然不可变，但是声明时可以使用运行时值。
内存布局角度来看，常量一般都是存储在数据段，而变量会在栈区或堆区。</div><h3 id=隐藏>隐藏<a hidden class=anchor aria-hidden=true href=#隐藏>#</a></h3><p><code>rust</code>中，可以使用<code>let</code>定义一个与之前变量同名的新变量，此时同名的第一个变量<strong>隐藏</strong>了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 定义x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 再次定义x，此时第一个x被隐藏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	    <span style=color:#75715e>// 再次定义x，但是仅在该作用域内生效
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;The value of x in the inner scope is: </span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>&#34;</span>); <span style=color:#75715e>// 12
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of x is: </span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>&#34;</span>); <span style=color:#75715e>// 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class="tips warn">请注意文中的用词含义，是<strong>隐藏</strong>而不是<strong>覆盖</strong>，因为此时存在真实的两个变量，而不是对第一个变量进行再次赋值。</div><p>乍看这个机制看着并不是很有用，特别是在不同作用域中的重名定义，这在其他的编程语言是很常见的。其实该机制的主要作用体现在变量的重复定义时，是可以修改变量的类型的。例如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> spaces <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;   &#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> spaces <span style=color:#f92672>=</span> spaces.len();
</span></span></code></pre></div><p>这里的<code>spaces</code>标识符所对应的变量从字符串类型变量改成了另一个整数类型变量，在后续的代码中你可以继续使用这个<code>spaces</code>变量名而不用定义一个新的变量名来记录字符串长度，类似于<code>spaces_length</code>。在同一作用域下的重复定义，这种行为在其他的编程语言的编译器眼中一般都种错误。</p><hr><h2 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h2><h3 id=标量类型>标量类型<a hidden class=anchor aria-hidden=true href=#标量类型>#</a></h3><h4 id=整型>整型<a hidden class=anchor aria-hidden=true href=#整型>#</a></h4><p>Rust 中的整型:</p><table><thead><tr><th style=text-align:center>长度</th><th style=text-align:center>有符号</th><th style=text-align:center>无符号</th></tr></thead><tbody><tr><td style=text-align:center>8-bit</td><td style=text-align:center>i8</td><td style=text-align:center>u8</td></tr><tr><td style=text-align:center>16-bit</td><td style=text-align:center>i16</td><td style=text-align:center>u16</td></tr><tr><td style=text-align:center>32-bit</td><td style=text-align:center>i32</td><td style=text-align:center>u32</td></tr><tr><td style=text-align:center>64-bit</td><td style=text-align:center>i64</td><td style=text-align:center>u64</td></tr><tr><td style=text-align:center>128-bit</td><td style=text-align:center>i128</td><td style=text-align:center>u128</td></tr><tr><td style=text-align:center>arch</td><td style=text-align:center>isize</td><td style=text-align:center>usize</td></tr></tbody></table><p><code>isize</code> 和 <code>usize</code> 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。</p><p>Rust 中的整型字面值:</p><table><thead><tr><th style=text-align:center>数字字面值</th><th style=text-align:center>例子</th></tr></thead><tbody><tr><td style=text-align:center>Decimal (十进制)</td><td style=text-align:center>98_222</td></tr><tr><td style=text-align:center>Hex (十六进制)</td><td style=text-align:center>0xff</td></tr><tr><td style=text-align:center>Octal (八进制)</td><td style=text-align:center>0o77</td></tr><tr><td style=text-align:center>Binary (二进制)</td><td style=text-align:center>0b1111_0000</td></tr><tr><td style=text-align:center>Byte (单字节字符)(仅限于<code>u8</code>)</td><td style=text-align:center>b&rsquo;A'</td></tr></tbody></table><div class="tips warn"><p id=tips-title>整形溢出问题</p><p>比方说有一个 <code>u8</code> ，它可以存放从零到 <code>255</code> 的值。那么当你将其修改为 <code>256</code> 时会发生什么呢？这被称为 “整型溢出”（“integer overflow” ），这会导致以下两种行为之一的发生。</p><ol><li>当在 debug 模式编译时，Rust 检查这类问题并使程序 <em>panic</em>。</li><li>在 release 构建中，Rust 不检测溢出，相反会进行一种被称为二进制补码回绕（<em>two’s complement wrapping</em>）的操作。简而言之，比此类型能容纳最大值还大的值会回绕到最小值，值 <code>256</code> 变成 <code>0</code>，值 <code>257</code> 变成 <code>1</code>，依此类推。依赖整型回绕被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，<a href=https://doc.rust-lang.org/std/num/struct.Wrapping.html>Wrapping</a>。</li></ol></div><h4 id=浮点数>浮点数<a hidden class=anchor aria-hidden=true href=#浮点数>#</a></h4><p>Rust 也有两个原生的 <strong>浮点数</strong>（<em>floating-point numbers</em>）类型，它们是带小数点的数字。Rust 的浮点数类型是 <code>f32</code> 和 <code>f64</code>，分别占 32 位和 64 位。<strong>默认类型是 <code>f64</code></strong>，因为在现代 CPU 中，它与 <code>f32</code> 速度几乎一样，不过精度更高。所有的浮点型都是有符号的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>2.0</span>; <span style=color:#75715e>// f64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: <span style=color:#66d9ef>f32</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3.0</span>; <span style=color:#75715e>// f32
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=布尔类型>布尔类型<a hidden class=anchor aria-hidden=true href=#布尔类型>#</a></h4><p>正如其他大部分编程语言一样，Rust 中的布尔类型有两个可能的值：<code>true</code> 和 <code>false</code>。Rust 中的布尔类型使用 <code>bool</code> 表示。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> t <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> f: <span style=color:#66d9ef>bool</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// with explicit type annotation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=字符>字符<a hidden class=anchor aria-hidden=true href=#字符>#</a></h4><p>Rust的 <code>char</code> 类型是语言中最原生的字母类型。下面是一些声明 <code>char</code> 值的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> c <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;z&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> z: <span style=color:#66d9ef>char</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;ℤ&#39;</span>; <span style=color:#75715e>// with explicit type annotation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> heart_eyed_cat <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;😻&#39;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>用单引号声明 <code>char</code> 字面量，使用双引号声明字符串字面量。<div class="tips info"><p>Rust 的 <code>char</code> 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。</p><p>在 Rust 中，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 <code>char</code> 值。</p><p>Unicode 标量值包含从 <code>U+0000</code> 到 <code>U+D7FF</code> 和 <code>U+E000</code> 到 <code>U+10FFFF</code> 在内的值。 <a href=https://kaisery.github.io/trpl-zh-cn/ch08-02-strings.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8-utf-8-%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E6%9C%AC>“使用字符串存储 UTF-8 编码的文本”</a> 中将详细讨论这个主题。</p></div></p><h3 id=复合类型>复合类型<a hidden class=anchor aria-hidden=true href=#复合类型>#</a></h3><p><strong>复合类型</strong>（<em>Compound types</em>）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p><h4 id=元组>元组<a hidden class=anchor aria-hidden=true href=#元组>#</a></h4><p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。<strong>元组长度固定：一旦声明，其长度不会增大或缩小。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>创建元组的语法如上，元组中的每一个位置都有一个类型，而且这些不同值的类型不必相同的。这个例子中使用了可选的类型注解：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tup: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    or
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tup <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>元组解构:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> tup <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> (x, y, z) <span style=color:#f92672>=</span> tup;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of y is: </span><span style=color:#e6db74>{y}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>访问元组中的元素，下标从0开始:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>f64</span>, <span style=color:#66d9ef>u8</span>) <span style=color:#f92672>=</span> (<span style=color:#ae81ff>500</span>, <span style=color:#ae81ff>6.4</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> five_hundred <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> six_point_four <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> one <span style=color:#f92672>=</span> x.<span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="tips info">不带任何值的元组有个特殊的名称，叫做 <strong>单元（unit）</strong> 元组。这种值以及对应的类型都写作 <code>()</code>，表示空值或空的返回类型。如果表达式不返回任何其他值，则会隐式返回单元值。</div><h4 id=数组>数组<a hidden class=anchor aria-hidden=true href=#数组>#</a></h4><p>另一个包含多个值的方式是 <strong>数组</strong>（<em>array</em>）。与元组不同，数组中的每个元素的类型必须相同。
声明数组的方式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和go语言一样，数组都是大小固定的，如果需要类slice的可变长数组，rust中使用标准库提供的<code>vector</code>。
一些支持的写法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// 这里，i32是每个元素的类型。分号之后，数字5表明该数组包含五个元素。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> a: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span><span style=color:#75715e>// 变量名为a的数组将包含5个元素，这些元素的值最初都将被设置为3。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>3</span>; <span style=color:#ae81ff>5</span>];
</span></span></code></pre></div><p>访问数组元素:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> first <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> second <span style=color:#f92672>=</span> a[<span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><p>Rust 代码中的函数和变量名使用 <em>snake case</em> 规范风格，所有字母都是小写并使用下划线分隔单词。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Hello, world!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    another_function();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>another_function</span>() {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;Another function.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>fn</code>关键字声明函数。</p><h4 id=参数>参数<a hidden class=anchor aria-hidden=true href=#参数>#</a></h4><p>我们可以定义为拥有 <strong>参数</strong>（<em>parameters</em>）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。技术上讲，这些具体值被称为参数（<em>arguments</em>）。</p><p>在函数签名中，<strong>必须</strong> 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    print_labeled_measurement(<span style=color:#ae81ff>5</span>, <span style=color:#e6db74>&#39;h&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>print_labeled_measurement</span>(value: <span style=color:#66d9ef>i32</span>, unit_label: <span style=color:#66d9ef>char</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The measurement is: </span><span style=color:#e6db74>{value}{unit_label}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=语句和表达式>语句和表达式<a hidden class=anchor aria-hidden=true href=#语句和表达式>#</a></h4><p><strong>语句</strong>（<em>Statements</em>）是执行一些操作但不返回值的指令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>; <span style=color:#75715e>// 语句
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> (<span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>6</span>); <span style=color:#75715e>// ❌
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>let y = 6</code> 语句并不返回值，所以没有可以绑定到 <code>x</code> 上的值。这与其他语言不同，例如 C 和 Ruby，它们的赋值语句会返回所赋的值。在这些语言中，可以这么写 <code>x = y = 6</code>，这样 <code>x</code> 和 <code>y</code> 的值都是 <code>6</code>；Rust 中不能这样写。</p><p>表达式（<em>Expressions</em>）计算并产生一个值。大部分 Rust 代码是由表达式组成的。考虑一个数学运算，比如 <code>5 + 6</code>，这是一个表达式并计算出值 <code>11</code>。表达式可以是语句的一部分：语句 <code>let y = 6;</code> 中的 <code>6</code> 是一个表达式，它计算出的值是 <code>6</code>。函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>        x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e>// 注意这里结尾处没有分号
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of y is: </span><span style=color:#e6db74>{y}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=函数返回值>函数返回值<a hidden class=anchor aria-hidden=true href=#函数返回值>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x <span style=color:#f92672>=</span> plus_one(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of x is: </span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>plus_one</span>(x: <span style=color:#66d9ef>i32</span>) -&gt; <span style=color:#66d9ef>i32</span> {
</span></span><span style=display:flex><span>    x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 表达式形式返回 ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    or
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>; <span style=color:#75715e>// 语句形式返回 ✅
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>rust中不可以像go一样对返回值命名，使用->并提供返回值类型。</p><h2 id=控制流>控制流<a hidden class=anchor aria-hidden=true href=#控制流>#</a></h2><h3 id=if表达式>if表达式<a hidden class=anchor aria-hidden=true href=#if表达式>#</a></h3><div class="tips warn">if是表达式而不是语句</div><p>if是表达式，可以返回值，所以可以在let的右侧使用它:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> condition <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> condition { <span style=color:#ae81ff>5</span> } <span style=color:#66d9ef>else</span> { <span style=color:#ae81ff>6</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of number is: </span><span style=color:#e6db74>{number}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这里的if有两个分支，对应两个表达式，最终返回的就是匹配分支对应表达式的值，所以这里也要求<strong>所有分支对应表达式必须返回同类型的值</strong>，如果不匹配会报错。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> condition <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> number <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> condition { <span style=color:#ae81ff>5</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#34;six&#34;</span> }; <span style=color:#75715e>// ❌ 两个表达式返回的类型不一致
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The value of number is: </span><span style=color:#e6db74>{number}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=循环>循环<a hidden class=anchor aria-hidden=true href=#循环>#</a></h3><p>Rust 有三种循环：<code>loop</code>、<code>while</code> 和 <code>for</code>。</p><p><code>loop</code>关键字搭配<code>break</code>和<code>continue</code>使用:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> counter <span style=color:#f92672>==</span> <span style=color:#ae81ff>10</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span> counter <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The result is </span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上是一个<code>loop</code>表达式，在<code>loop</code>内部可以通过<code>break</code>产出值。
当然，利用if表达式，也可以这么写:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> result <span style=color:#f92672>=</span> <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        counter <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span> <span style=color:#66d9ef>if</span> counter <span style=color:#f92672>==</span> <span style=color:#ae81ff>10</span> { counter <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span> } <span style=color:#66d9ef>else</span> { <span style=color:#66d9ef>continue</span> };
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;The result is </span><span style=color:#e6db74>{result}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>循环标签</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 给定循环标签counting_up
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>&#39;counting_up</span>: <span style=color:#a6e22e>loop</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;count = </span><span style=color:#e6db74>{count}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> remaining <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;remaining = </span><span style=color:#e6db74>{remaining}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> remaining <span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> count <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> {
</span></span><span style=display:flex><span>	            <span style=color:#75715e>// 直接跳出整个循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>break</span> &#39;counting_up;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            remaining <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;End count = </span><span style=color:#e6db74>{count}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>while条件循环</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> number <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> number <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{number}</span><span style=color:#e6db74>!&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        number <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;LIFTOFF!!!&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>for遍历</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> [<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>20</span>, <span style=color:#ae81ff>30</span>, <span style=color:#ae81ff>40</span>, <span style=color:#ae81ff>50</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> element <span style=color:#66d9ef>in</span> a {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;the value is: </span><span style=color:#e6db74>{element}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/rust/>rust</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/protobuf%E5%8E%9F%E7%90%86/><span class=title>« 上一页</span><br><span>Protobuf原理</span>
</a><a class=next href=https://www.yici.xin/post/tech/go-sync-pool/><span class=title>下一页 »</span><br><span>Go Sync Pool</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
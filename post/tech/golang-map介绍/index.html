<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>golang-map介绍 | yicixin's blog</title>
<meta name=keywords content="golang,map,hashmap,源码解析"><meta name=description content="本文中使用的 go 版本：
go version go1.17.2 darwin/amd64
内容概述 本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。
map 在源码中的结构——hmap Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。
在源码中$GOROOT/src/runtime/map.go，map 的核心结构体是这样的：
// A header for a Go map. type hmap struct { count int // map中的元素数量，即len(map)时的返回值 flags uint8 B uint8 // buckets的以2为底的对数, 即2^B=buckets noverflow uint16 // 溢出桶的近似数; see incrnoverflow for details hash0 uint32 // 哈希种子 buckets unsafe.Pointer // 2^B个bucket的数组，may be nil if count==0. oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半； nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } 在上面我们需要关注的核心是buckets，它是一个指针，最终指向了bmap结构体数组"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E4%BB%8B%E7%BB%8D/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b35f27175e1d679d5ac37249ed25e28b57702f4740c052621132f937b795fa44.css integrity="sha256-s18nF14dZ51aw3JJ7SXii1dwL0dAwFJiETL5N7eV+kQ=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="golang-map介绍"><meta property="og:description" content="本文中使用的 go 版本：
go version go1.17.2 darwin/amd64
内容概述 本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。
map 在源码中的结构——hmap Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。
在源码中$GOROOT/src/runtime/map.go，map 的核心结构体是这样的：
// A header for a Go map. type hmap struct { count int // map中的元素数量，即len(map)时的返回值 flags uint8 B uint8 // buckets的以2为底的对数, 即2^B=buckets noverflow uint16 // 溢出桶的近似数; see incrnoverflow for details hash0 uint32 // 哈希种子 buckets unsafe.Pointer // 2^B个bucket的数组，may be nil if count==0. oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半； nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } 在上面我们需要关注的核心是buckets，它是一个指针，最终指向了bmap结构体数组"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E4%BB%8B%E7%BB%8D/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-01-05T23:38:06+08:00"><meta property="article:modified_time" content="2022-01-05T23:38:06+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="golang-map介绍"><meta name=twitter:description content="本文中使用的 go 版本：
go version go1.17.2 darwin/amd64
内容概述 本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。
map 在源码中的结构——hmap Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。
在源码中$GOROOT/src/runtime/map.go，map 的核心结构体是这样的：
// A header for a Go map. type hmap struct { count int // map中的元素数量，即len(map)时的返回值 flags uint8 B uint8 // buckets的以2为底的对数, 即2^B=buckets noverflow uint16 // 溢出桶的近似数; see incrnoverflow for details hash0 uint32 // 哈希种子 buckets unsafe.Pointer // 2^B个bucket的数组，may be nil if count==0. oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半； nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } 在上面我们需要关注的核心是buckets，它是一个指针，最终指向了bmap结构体数组"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"golang-map介绍","item":"https://www.yici.xin/post/tech/golang-map%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang-map介绍","name":"golang-map介绍","description":"本文中使用的 go 版本：\ngo version go1.17.2 darwin/amd64\n内容概述 本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。\nmap 在源码中的结构——hmap Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。\n在源码中$GOROOT/src/runtime/map.go，map 的核心结构体是这样的：\n// A header for a Go map. type hmap struct { count int // map中的元素数量，即len(map)时的返回值 flags uint8 B uint8 // buckets的以2为底的对数, 即2^B=buckets noverflow uint16 // 溢出桶的近似数; see incrnoverflow for details hash0 uint32 // 哈希种子 buckets unsafe.Pointer // 2^B个bucket的数组，may be nil if count==0. oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半； nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } 在上面我们需要关注的核心是buckets，它是一个指针，最终指向了bmap结构体数组","keywords":["golang","map","hashmap","源码解析"],"articleBody":" 本文中使用的 go 版本：\ngo version go1.17.2 darwin/amd64\n内容概述 本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。\nmap 在源码中的结构——hmap Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。\n在源码中$GOROOT/src/runtime/map.go，map 的核心结构体是这样的：\n// A header for a Go map. type hmap struct { count int // map中的元素数量，即len(map)时的返回值 flags uint8 B uint8 // buckets的以2为底的对数, 即2^B=buckets noverflow uint16 // 溢出桶的近似数; see incrnoverflow for details hash0 uint32 // 哈希种子 buckets unsafe.Pointer // 2^B个bucket的数组，may be nil if count==0. oldbuckets unsafe.Pointer // 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半； nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) extra *mapextra // optional fields } 在上面我们需要关注的核心是buckets，它是一个指针，最终指向了bmap结构体数组\n// A bucket for a Go map. type bmap struct { // tophash generally contains the top byte of the hash value // for each key in this bucket. If tophash[0] \u003c minTopHash, // tophash[0] is a bucket evacuation state instead. // 翻译: tophash 存储了每个在该bucket中的key的最高字节，如果tophash[0] \u003c minTopHash，tophash[0]是一个桶疏松状态 tophash [bucketCnt]uint8 // Followed by bucketCnt keys and then bucketCnt elems. // NOTE: packing all the keys together and then all the elems together makes the // code a bit more complicated than alternating key/elem/key/elem/... but it allows // us to eliminate padding which would be needed for, e.g., map[int64]int8. // 翻译: 注意，把所有键打包在一起，然后再把所有对应值打包在一起，这会比键值对交错更复杂。但这种形式能够消除多余的填充字节，方便内存对齐 // Followed by an overflow pointer. } bucketCnt 是一个常量，它是一个 bucket 能够持有键值对个数的最大值。\n它在源码中是这样的：\nbucketCntBits = 3 bucketCnt = 1 \u003c\u003c bucketCntBits 即 bucketCnt = 1 左移三位 = 8\nbucket 的结构-bmap 在运行时，bmap 的真正结构并不像它在源码里展示的这么简单，在编译期间会创建一个新的结构，这是因为哈希表中能存储的键值对类型不确定，而且 Go 语言也不支持泛型，不可能在源码中全部定义，所以键值对的类型及其占据的内存空间大小只能在编译时进行推导。\n具体来说，是在类型检查阶段，在这一步 AST(抽象语法树)将转换为 SSA(静态单赋值)形式的中间代码，map 关键字及其操作将转换为对应的 runtime 函数，例如:\nv := hash[key] // =\u003e v := runtime.mapaccess1(maptype, hash, \u0026key) 所以，bmap 运行时的真正结构是这样：\ntype bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } 其中，所有的 key 在一个组里，所有的 value 在一个组里，而不是以{key,value}的组来存储，这样能够减少内存对齐带来的内存浪费。\nbucket 的结构如下图所示。\n如果 bucket 装满了的话，会创建新的 bucket，并使用 overflow 字段指向新的 bucket，形成类似链表的结构。\n一个 map 中会存在一个 bucket 数组，它们的关系大概像这样。\n让我们暂停分析一下目前的结构，当往 map 中存储一个 kv 对时，通过 k 获取 hash 值，hash 值的低八位和 bucket 数组长度取余，定位到数组中的下标，hash 值的高八位存储在 bucket 中的 tophash 中，用来快速判断 key 是否存在，key 和 value 的具体值则通过指针运算存储，当一个 bucket 满时，通过 overfolw 指针链接到下一个 bucket。\n随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。\n预备 简单了解完了 map 的构成之后，接下来要介绍的就是对 map 的具体操作了，为了读者能更好的理解，这里要先讲一些预备知识。从何讲起？先来思考一个问题，我们都知道 go 是强类型的语言，并且目前为止(go1.17)都还不支持泛型，那么要怎么让 map 支持这么多类型呢？\n先来看看别的强类型语言是怎么做的吧\nC++的 map 首先来看看 c++，这里用到了 c++的特性之一————模板(也就是泛型啦)，c++标准模板库 STL 提供了 std::unordered_map，经常用来实现 hashmap。\nThis is the declaration for std::unordered_map. It’s a template, so the actual values of the parameters depend on how the template is instantiated.\n这里是std::unordered_map的定义，它是一个模板，所以实际的参数值决定模板如何初始化。\ntemplate\u003c class Key, // the type of the key class T, // the type of the value class Hash = std::hash\u003cKey\u003e, // the hash function class KeyEqual = std::equal_to\u003cKey\u003e, // the key equality function class Allocator = std::allocator\u003c std::pair\u003cconst Key, T\u003e \u003e \u003e class unordered_map; 通过这些参数能知道：\nkey 和 value 的类型Key、T，也就知道了它们的大小。 KeyEqual，类型是std::equal_to，表示这个是一个处理Key的哈希函数，用来求 key 的哈希值 Allocator，类型是std::equal_to，同样也是处理Key的函数，用于比较两个 key 有了这些信息，编译器就能在编译时确定类型，生成对应的确定类型的代码了。\n来源: 引用 11\nc++的 map 查询操作简单来说是这样的，如上图，首先我们将 key 传给 std::hash 函数以得到 key 的 hash 值。然后做掩码并取到 bucket 数组中的序号，接着再遍历对应 bucket 的 entry 列表并用 std::equal_to 函数来比较 key。\njava 的 map 第二个要谈的是 java，不出所料，java 中 hashmap 类型就是java.util.Hashmap。\n在 java 中， java.util.Hashmap只能够操作对象，因为 java 万物皆对象 🤪，所有的对象都来源于java.lang.Object，可以继承或重写hashCode 和 equals 方法。\n当然，有 8 种基础类型不能够这样操作boolean， int， short， long， byte， char， float， and double，因为它们不是java.lang.Object的子类，难道说基础类型没法作为 key 或 value 吗？非也，为了解决这个限制，java 会隐式转换基础类型为它们对应的对象，这种操作叫装箱。\n来源: 引用 11\njava 中的查找是这样的，首先我们调用 key 的 hashCode 方法来获取它的 hash 值，然后做掩码操作，获取到 bucket 数组中的对应位置，里面存放了一个指向 Entry 的指针。Entry 中有一个 key，一个 value，还有一个指向下一个 Entry 的指针，形成了一个 linked list。\n优缺点 现在我们知道了 hashmap 在 c++和 java 中的实现了，来比较一下他们的优缺点：\nc++ 优点：\nkey 和 value 类型的大小在编译期间就确定了。 不需要装箱操作。 由于代码在编译期间就定下来了，所以其他编译优化操作例如内联，常数折叠和死代码删除就可以介入了。 总之，C++中的 map 和自己为每种 key/value 类型组合手写的特定 map 一样快速高效，因为本质就是一样的，模板为你生成了对应的代码。\n缺点：\n代码膨胀，每个不同的类型映射都有对应的一份 map 代码 编译时间增长，继上一点，更多的代码会带来更久的编译时间 java 优点:\n基于多态，一份 map 代码的实现可以用于任何 java.util.Object 的子类。只需要编译一份 java.util.Object，在每个 class 文件中就都可以引用了。 缺点：\n基本类型的 map 必须用通过装箱操作转化为对象。装箱操作会增加垃圾回收的压力，并且额外的指针引用会增加缓存压力（每个对象都必须通过另外的指针来查找）。 Hash 和 equals 函数需要代码编写者来实现。不正确的 hash 和 equals 函数会减慢 map 的运行速度，甚至导致 map 的行为错误。 go 的 map 总结一下，c++的 map 就是写重复的代码来兼容不同的映射类型，将类型信息硬编码在代码中，而 java 的 map 使用一套代码，将操作对象统一，以多态形式处理不同类型的对象，即相当于等到运行时获取类型信息。\ngo 语言是什么方式呢？首先 go 没有泛型，没法像 C++模板一样生成所有相应类型映射的代码，那怎么以一套代码处理所有类型呢？(interface{}吗？留给大家思考)\n这里先给出答案，并不是用 interface{}，go 的 map 的特别之处，在于它不是单单编译阶段就处理完成，需要编译时和运行时的相互协作。\n编译时重写 在上文有提到过，编译器会重写 map 操作为 runtime 函数调用，例如:\nv := hash[key] // =\u003e v := runtime.mapaccess1(maptype, hash, \u0026key) 这里的 runtime 函数就是关键了，我们以runtime.mapaccess1函数举例介绍。\nruntime 函数 先来看看runtime.mapaccess1函数，这是一个用来访问 map 的函数，签名:\nfunc mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer 解释一下这些参数:\nkey， 一个指针，指向了你提供的 key 值。 h ，指向 runtime.hmap 结构的指针。 t 是个指向 maptype 的指针。 🤓 来了，经过上文介绍，这里 key 和 h 的作用我想读者都能够很好的理解，但是它们都没有解决问题，关键所在就是这里的maptype，它使得通用的 *hmap 可以服务于（几乎）任意 key 和 value 类型的组合。在你的程序中对于每一个独立的 map 定义都会有一个特定的maptype值。例如，有一个 maptype 值描述了从 string 到 int 的映射，另一个描述了 string 到 http.Headers 的映射，等等。\n因此，go 在编译期间做的事是，创建对应的 maptype，在调用 runtime 的 map 函数的时候当做参数传入，提供 hmap 需要的信息。\nmaptype type maptype struct { typ _type key *_type elem *_type bucket *_type // internal type representing a hash bucket // function for hashing keys (ptr to key, seed) -\u003e hash hasher func(unsafe.Pointer, uintptr) uintptr keysize uint8 // size of key slot elemsize uint8 // size of elem slot bucketsize uint16 // size of bucket flags uint32 } 这是 maptype 的结构定义，包含了特定 map 中从 key 映射到 elem 所需的各种属性细节。如 key 和 elem 的类型信息(_type 类型中)，哈希函数。\n// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize, // ../cmd/compile/internal/reflectdata/reflect.go:/^func.dcommontype and // ../reflect/type.go:/^type.rtype. // ../internal/reflectlite/type.go:/^type.rtype. type _type struct { size uintptr ptrdata uintptr // size of memory prefix holding all pointers hash uint32 tflag tflag align uint8 fieldAlign uint8 kind uint8 // function for comparing objects of this type // (ptr to object A, ptr to object B) -\u003e ==? equal func(unsafe.Pointer, unsafe.Pointer) bool // gcdata stores the GC type data for the garbage collector. // If the KindGCProg bit is set in kind, gcdata is a GC program. // Otherwise it is a ptrmask bitmap. See mbitmap.go for details. gcdata *byte str nameOff ptrToThis typeOff } 在 _type 类型中，记载的是类型信息，比如它的大小size，该类型判断是否相等的方法euqal。\n总结，go 的 map 没有重复的 map 代码，靠的是多个maptype来提供不同的类型信息，在运行时从参数maptype中获取需要的类型信息，通过这个机制，go 不必生成大量的重复 map 代码，也不用特殊处理基础类型，以一套 map 代码就能够处理所有的类型映射，并且性能依然优秀。使用方式简单清晰，的确是优秀的设计！\n引用 Runtime:源码解析 Golang 的 map 实现原理\nHow the Go runtime implements maps efficiently (without generics) ↩︎ ↩︎\n","wordCount":"841","inLanguage":"zh","datePublished":"2022-01-05T23:38:06+08:00","dateModified":"2022-01-05T23:38:06+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>golang-map介绍</h1><div class=post-meta><span title='2022-01-05 23:38:06 +0800 +0800'>2022-01-05</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%86%85%e5%ae%b9%e6%a6%82%e8%bf%b0 aria-label=内容概述>内容概述</a></li><li><a href=#map-%e5%9c%a8%e6%ba%90%e7%a0%81%e4%b8%ad%e7%9a%84%e7%bb%93%e6%9e%84hmap aria-label="map 在源码中的结构——hmap">map 在源码中的结构——hmap</a></li><li><a href=#bucket-%e7%9a%84%e7%bb%93%e6%9e%84-bmap aria-label="bucket 的结构-bmap">bucket 的结构-bmap</a></li><li><a href=#%e9%a2%84%e5%a4%87 aria-label=预备>预备</a><ul><li><a href=#c%e7%9a%84-map aria-label="C++的 map">C++的 map</a></li><li><a href=#java-%e7%9a%84-map aria-label="java 的 map">java 的 map</a></li><li><a href=#%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label=优缺点>优缺点</a><ul><li><a href=#c aria-label=c++>c++</a></li><li><a href=#java aria-label=java>java</a></li></ul></li></ul></li><li><a href=#go-%e7%9a%84-map aria-label="go 的 map">go 的 map</a><ul><li><a href=#%e7%bc%96%e8%af%91%e6%97%b6%e9%87%8d%e5%86%99 aria-label=编译时重写>编译时重写</a></li><li><a href=#runtime-%e5%87%bd%e6%95%b0 aria-label="runtime 函数">runtime 函数</a></li><li><a href=#maptype aria-label=maptype>maptype</a></li></ul></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><blockquote><p>本文中使用的 go 版本：</p><p>go version go1.17.2 darwin/amd64</p></blockquote><h2 id=内容概述>内容概述<a hidden class=anchor aria-hidden=true href=#内容概述>#</a></h2><p>本文介绍 golang 中经常用到的结构-map，简称哈希表、字典。介绍其结构及设计思路。</p><h2 id=map-在源码中的结构hmap>map 在源码中的结构——hmap<a hidden class=anchor aria-hidden=true href=#map-在源码中的结构hmap>#</a></h2><p>Go 语言采用的核心数据结构是哈希查找表，使用链表解决哈希冲突。</p><p>在源码中<code>$GOROOT/src/runtime/map.go</code>，map 的核心结构体是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A header for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>hmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span>     <span style=color:#66d9ef>int</span> <span style=color:#75715e>// map中的元素数量，即len(map)时的返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>flags</span>     <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>B</span>         <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// buckets的以2为底的对数, 即2^B=buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>noverflow</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// 溢出桶的近似数; see incrnoverflow for details
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash0</span>     <span style=color:#66d9ef>uint32</span> <span style=color:#75715e>// 哈希种子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>buckets</span>    <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 2^B个bucket的数组，may be nil if count==0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>oldbuckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 哈希在扩容时用于保存之前 buckets 的字段，它的大小是当前 buckets 的一半；
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nevacuate</span>  <span style=color:#66d9ef>uintptr</span>        <span style=color:#75715e>// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>extra</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mapextra</span> <span style=color:#75715e>// optional fields
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>在上面我们需要关注的核心是<code>buckets</code>，它是一个指针，最终指向了<code>bmap</code>结构体数组</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// A bucket for a Go map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tophash generally contains the top byte of the hash value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// for each key in this bucket. If tophash[0] &lt; minTopHash,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// tophash[0] is a bucket evacuation state instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 翻译: tophash 存储了每个在该bucket中的key的最高字节，如果tophash[0] &lt; minTopHash，tophash[0]是一个桶疏松状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>tophash</span> [<span style=color:#a6e22e>bucketCnt</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Followed by bucketCnt keys and then bucketCnt elems.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// NOTE: packing all the keys together and then all the elems together makes the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// code a bit more complicated than alternating key/elem/key/elem/... but it allows
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// us to eliminate padding which would be needed for, e.g., map[int64]int8.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 翻译: 注意，把所有键打包在一起，然后再把所有对应值打包在一起，这会比键值对交错更复杂。但这种形式能够消除多余的填充字节，方便内存对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Followed by an overflow pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><blockquote><p>bucketCnt 是一个常量，它是一个 bucket 能够持有键值对个数的最大值。</p><p>它在源码中是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>bucketCntBits</span> = <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bucketCnt</span>     = <span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>bucketCntBits</span>
</span></span></code></pre></div><p>即 bucketCnt = 1 左移三位 = 8</p></blockquote><h2 id=bucket-的结构-bmap>bucket 的结构-bmap<a hidden class=anchor aria-hidden=true href=#bucket-的结构-bmap>#</a></h2><p>在运行时，bmap 的真正结构并不像它在源码里展示的这么简单，在编译期间会创建一个新的结构，这是因为哈希表中能存储的键值对类型不确定，而且 Go 语言也不支持泛型，不可能在源码中全部定义，所以键值对的类型及其占据的内存空间大小只能在编译时进行推导。</p><p>具体来说，是在<strong>类型检查</strong>阶段，在这一步 AST(抽象语法树)将转换为 SSA(静态单赋值)形式的中间代码，map 关键字及其操作将转换为对应的 runtime 函数，例如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>v</span>     <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>] <span style=color:#75715e>// =&gt; v     := runtime.mapaccess1(maptype, hash, &amp;key)
</span></span></span></code></pre></div><p>所以，bmap 运行时的真正结构是这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bmap</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>topbits</span>  [<span style=color:#ae81ff>8</span>]<span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>keys</span>     [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>keytype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>values</span>   [<span style=color:#ae81ff>8</span>]<span style=color:#a6e22e>valuetype</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pad</span>      <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中，所有的 key 在一个组里，所有的 value 在一个组里，而不是以{key,value}的组来存储，这样能够减少内存对齐带来的内存浪费。</p><p>bucket 的结构如下图所示。</p><img src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.png alt=bucket style=zoom:50%><p>如果 bucket 装满了的话，会创建新的 bucket，并使用 overflow 字段指向新的 bucket，形成类似链表的结构。</p><p>一个 map 中会存在一个 bucket 数组，它们的关系大概像这样。</p><img src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png alt=map中的buckets style=zoom:25%><p>让我们暂停分析一下目前的结构，当往 map 中存储一个 kv 对时，通过 k 获取 hash 值，hash 值的低八位和 bucket 数组长度取余，定位到数组中的下标，hash 值的高八位存储在 bucket 中的 tophash 中，用来快速判断 key 是否存在，key 和 value 的具体值则通过指针运算存储，当一个 bucket 满时，通过 overfolw 指针链接到下一个 bucket。</p><p>随着哈希表存储的数据逐渐增多，我们会扩容哈希表或者使用额外的桶存储溢出的数据，不会让单个桶中的数据超过 8 个，不过溢出桶只是临时的解决方案，创建过多的溢出桶最终也会导致哈希的扩容。</p><h2 id=预备>预备<a hidden class=anchor aria-hidden=true href=#预备>#</a></h2><p>简单了解完了 map 的构成之后，接下来要介绍的就是对 map 的具体操作了，为了读者能更好的理解，这里要先讲一些预备知识。从何讲起？先来思考一个问题，我们都知道 go 是强类型的语言，并且目前为止(go1.17)都还不支持泛型，那么要怎么让 map 支持这么多类型呢？</p><p>先来看看别的强类型语言是怎么做的吧</p><h3 id=c的-map>C++的 map<a hidden class=anchor aria-hidden=true href=#c的-map>#</a></h3><p>首先来看看 c++，这里用到了 c++的特性之一————模板(也就是泛型啦)，c++标准模板库 STL 提供了 std::unordered_map，经常用来实现 hashmap。</p><p>This is the declaration for <code>std::unordered_map</code>. It’s a template, so the actual values of the parameters depend on how the template is instantiated.</p><p>这里是<code>std::unordered_map</code>的定义，它是一个模板，所以实际的参数值决定模板如何初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Key</span>,                             <span style=color:#75715e>// the type of the key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span>,                               <span style=color:#75715e>// the type of the value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hash</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>hash<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,           <span style=color:#75715e>// the hash function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>KeyEqual</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>equal_to<span style=color:#f92672>&lt;</span>Key<span style=color:#f92672>&gt;</span>,   <span style=color:#75715e>// the key equality function
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Allocator</span> <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>allocator<span style=color:#f92672>&lt;</span> std<span style=color:#f92672>::</span>pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> Key, T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>unordered_map</span>;
</span></span></code></pre></div><p>通过这些参数能知道：</p><ul><li>key 和 value 的类型<code>Key</code>、<code>T</code>，也就知道了它们的大小。</li><li><code>KeyEqual</code>，类型是<code>std::equal_to&lt;Key></code>，表示这个是一个处理<code>Key</code>的哈希函数，用来求 key 的哈希值</li><li><code>Allocator</code>，类型是<code>std::equal_to&lt;Key></code>，同样也是处理<code>Key</code>的函数，用于比较两个 key</li></ul><p>有了这些信息，编译器就能在编译时确定类型，生成对应的<code>确定类型</code>的代码了。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/Gocon-2018-Maps.030-624x351.png alt=std::unordered_map></p><p>来源: 引用 1<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>c++的 map 查询操作简单来说是这样的，如上图，首先我们将 key 传给 <code>std::hash</code> 函数以得到 key 的 hash 值。然后做掩码并取到 bucket 数组中的序号，接着再遍历对应 bucket 的 entry 列表并用 <code>std::equal_to</code> 函数来比较 key。</p><h3 id=java-的-map>java 的 map<a hidden class=anchor aria-hidden=true href=#java-的-map>#</a></h3><p>第二个要谈的是 java，不出所料，java 中 hashmap 类型就是<code>java.util.Hashmap</code>。</p><p>在 java 中， <code>java.util.Hashmap</code>只能够操作<code>对象</code>，因为 java 万物皆对象 🤪，所有的对象都来源于<code>java.lang.Object</code>，可以继承或重写<code>hashCode</code> 和 <code>equals</code> 方法。</p><p>当然，有 8 种基础类型不能够这样操作<code>boolean</code>， <code>int</code>， <code>short</code>， <code>long</code>， <code>byte</code>， <code>char</code>， <code>float</code>， and <code>double</code>，因为它们不是<code>java.lang.Object</code>的子类，难道说基础类型没法作为 key 或 value 吗？非也，为了解决这个限制，java 会隐式转换基础类型为它们对应的对象，这种操作叫<code>装箱</code>。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/Gocon-2018-Maps.034-624x351.png alt=java_hashmap></p><p>来源: 引用 1<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>java 中的查找是这样的，首先我们调用 key 的 <code>hashCode</code> 方法来获取它的 hash 值，然后做掩码操作，获取到 bucket 数组中的对应位置，里面存放了一个指向 <code>Entry</code> 的指针。<code>Entry</code> 中有一个 key，一个 value，还有一个指向下一个 <code>Entry</code> 的指针，形成了一个 linked list。</p><h3 id=优缺点>优缺点<a hidden class=anchor aria-hidden=true href=#优缺点>#</a></h3><p>现在我们知道了 hashmap 在 c++和 java 中的实现了，来比较一下他们的优缺点：</p><h4 id=c>c++<a hidden class=anchor aria-hidden=true href=#c>#</a></h4><p>优点：</p><ul><li>key 和 value 类型的大小在编译期间就确定了。</li><li>不需要装箱操作。</li><li>由于代码在编译期间就定下来了，所以其他编译优化操作例如内联，常数折叠和死代码删除就可以介入了。</li></ul><p>总之，C++中的 map 和自己为每种 key/value 类型组合手写的特定 map 一样快速高效，因为本质就是一样的，模板为你生成了对应的代码。</p><p>缺点：</p><ul><li>代码膨胀，每个不同的类型映射都有对应的一份 map 代码</li><li>编译时间增长，继上一点，更多的代码会带来更久的编译时间</li></ul><h4 id=java>java<a hidden class=anchor aria-hidden=true href=#java>#</a></h4><p>优点:</p><ul><li>基于多态，一份 map 代码的实现可以用于任何 java.util.Object 的子类。只需要编译一份 java.util.Object，在每个 class 文件中就都可以引用了。</li></ul><p>缺点：</p><ul><li>基本类型的 map 必须用通过装箱操作转化为对象。装箱操作会增加垃圾回收的压力，并且额外的指针引用会增加缓存压力（每个对象都必须通过另外的指针来查找）。</li><li>Hash 和 equals 函数需要代码编写者来实现。不正确的 hash 和 equals 函数会减慢 map 的运行速度，甚至导致 map 的行为错误。</li></ul><h2 id=go-的-map>go 的 map<a hidden class=anchor aria-hidden=true href=#go-的-map>#</a></h2><p>总结一下，c++的 map 就是写重复的代码来兼容不同的映射类型，将类型信息硬编码在代码中，而 java 的 map 使用一套代码，将操作对象统一，以多态形式处理不同类型的对象，即相当于等到运行时获取类型信息。</p><p>go 语言是什么方式呢？首先 go 没有泛型，没法像 C++模板一样生成所有相应类型映射的代码，那怎么以一套代码处理所有类型呢？(interface{}吗？留给大家思考)</p><p>这里先给出答案，并不是用 interface{}，go 的 map 的特别之处，在于它不是单单编译阶段就处理完成，需要编译时和运行时的相互协作。</p><h3 id=编译时重写>编译时重写<a hidden class=anchor aria-hidden=true href=#编译时重写>#</a></h3><p>在上文有提到过，编译器会重写 map 操作为 runtime 函数调用，例如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span>[<span style=color:#a6e22e>key</span>] <span style=color:#75715e>// =&gt; v := runtime.mapaccess1(maptype, hash, &amp;key)
</span></span></span></code></pre></div><p>这里的 runtime 函数就是关键了，我们以<code>runtime.mapaccess1</code>函数举例介绍。</p><h3 id=runtime-函数>runtime 函数<a hidden class=anchor aria-hidden=true href=#runtime-函数>#</a></h3><p>先来看看<code>runtime.mapaccess1</code>函数，这是一个用来访问 map 的函数，签名:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span></code></pre></div><p>解释一下这些参数:</p><ul><li><code>key</code>， 一个指针，指向了你提供的 key 值。</li><li><code>h</code> ，指向 <code>runtime.hmap</code> 结构的指针。</li><li><code>t</code> 是个指向 <code>maptype</code> 的指针。</li></ul><p>🤓 来了，经过上文介绍，这里 key 和 h 的作用我想读者都能够很好的理解，但是它们都没有解决问题，关键所在就是这里的<code>maptype</code>，它使得通用的 <code>*hmap</code> 可以服务于（几乎）任意 key 和 value 类型的组合。在你的程序中对于每一个独立的 map 定义都会有一个特定的<code>maptype</code>值。例如，有一个 <code>maptype</code> 值描述了从 <code>string</code> 到 <code>int</code> 的映射，另一个描述了 <code>string</code> 到 <code>http.Headers</code> 的映射，等等。</p><p>因此，go 在编译期间做的事是，创建对应的 maptype，在调用 runtime 的 map 函数的时候当做参数传入，提供 hmap 需要的信息。</p><h3 id=maptype>maptype<a hidden class=anchor aria-hidden=true href=#maptype>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>maptype</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>typ</span>    <span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>key</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>elem</span>   <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span> <span style=color:#75715e>// internal type representing a hash bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// function for hashing keys (ptr to key, seed) -&gt; hash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hasher</span>     <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>keysize</span>    <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// size of key slot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>elemsize</span>   <span style=color:#66d9ef>uint8</span>  <span style=color:#75715e>// size of elem slot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bucketsize</span> <span style=color:#66d9ef>uint16</span> <span style=color:#75715e>// size of bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>flags</span>      <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是 maptype 的结构定义，包含了特定 map 中从 key 映射到 elem 所需的各种属性细节。如 key 和 elem 的类型信息(_type 类型中)，哈希函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Needs to be in sync with ../cmd/link/internal/ld/decodesym.go:/^func.commonsize,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../cmd/compile/internal/reflectdata/reflect.go:/^func.dcommontype and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../reflect/type.go:/^type.rtype.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ../internal/reflectlite/type.go:/^type.rtype.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>_type</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>size</span>       <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptrdata</span>    <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// size of memory prefix holding all pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash</span>       <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>tflag</span>      <span style=color:#a6e22e>tflag</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>align</span>      <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fieldAlign</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>kind</span>       <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// function for comparing objects of this type
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// (ptr to object A, ptr to object B) -&gt; ==?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>equal</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// gcdata stores the GC type data for the garbage collector.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If the KindGCProg bit is set in kind, gcdata is a GC program.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcdata</span>    <span style=color:#f92672>*</span><span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>str</span>       <span style=color:#a6e22e>nameOff</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptrToThis</span> <span style=color:#a6e22e>typeOff</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在 <code>_type</code> 类型中，记载的是类型信息，比如它的大小<code>size</code>，该类型判断是否相等的方法<code>euqal</code>。</p><p>总结，go 的 map 没有重复的 map 代码，靠的是多个<code>maptype</code>来提供不同的类型信息，在运行时从参数<code>maptype</code>中获取需要的类型信息，通过这个机制，go 不必生成大量的重复 map 代码，也不用特殊处理基础类型，以一套 map 代码就能够处理所有的类型映射，并且性能依然优秀。使用方式简单清晰，的确是优秀的设计！</p><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><p><a href=https://www.jianshu.com/p/888a90aa25b0>Runtime:源码解析 Golang 的 map 实现原理</a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://dave.cheney.net/2018/05/29/how-the-go-runtime-implements-maps-efficiently-without-generics>How the Go runtime implements maps efficiently (without generics)</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>golang</a></li><li><a href=https://www.yici.xin/tags/map/>map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>源码解析</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/short_code/><span class=title>« 上一页</span><br><span>Short_code</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Rust函数式编程特性 迭代器和闭包 | yicixin's blog</title><meta name=keywords content="rust,函数式编程,闭包,迭代器"><meta name=description content="简介 Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.
In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional."><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/rust%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Rust函数式编程特性 迭代器和闭包"><meta property="og:description" content="简介 Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.
In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/rust%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-06-06T23:09:15+08:00"><meta property="article:modified_time" content="2023-06-06T23:09:15+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust函数式编程特性 迭代器和闭包"><meta name=twitter:description content="简介 Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.
In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Rust函数式编程特性 迭代器和闭包","item":"https://www.yici.xin/post/tech/rust%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust函数式编程特性 迭代器和闭包","name":"Rust函数式编程特性 迭代器和闭包","description":"简介 Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.\nIn this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.","keywords":["rust","函数式编程","闭包","迭代器"],"articleBody":"简介 Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.\nIn this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.\nMore specifically, we’ll cover:\nClosures, a function-like construct you can store in a variable Iterators, a way of processing a series of elements How to use these two features to improve the I/O project in Chapter 12 The performance of these two features (Spoiler alert: they’re faster than you might think!) Other Rust features, such as pattern matching and enums, which we’ve covered in other chapters, are influenced by the functional style as well. Mastering closures and iterators is an important part of writing idiomatic, fast Rust code, so we’ll devote this entire chapter to them.\nRust的设计灵感来自很多现存的语言和技术，其中显著的一个影响是**“函数式编程”**。函数式编程经常把函数当做实参传递、作为其他函数的返回值、赋值给变量用于之后的执行。\n在这一节，我们不会去讨论函数式编程到底是什么，而是讨论一些 Rust 的特性，这些特性与许多常被称为函数式的语言中的特性相似。\n具体会涉及这些内容：\n闭包（Closures），一个可以储存在变量里的类函数的结构 迭代器（Iterator），一种处理元素序列的方式 如何使用这些特性改善第12章中的io项目 这两种特性的性能如何（剧透一下：它们的性能可能比你想的要高） 如模式匹配和枚举这样受函数式风格影响的其他Rust特性，我们已经在其他章讲过了。掌握闭包和迭代器是编写符合风格、高性能的rust代码的重要一环，所以我们将专门一整章来讲解它们。\n闭包：可以捕获环境的匿名函数 Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.\nrust的闭包是一个匿名函数，你可以将它保存在一个变量当中，或者当做实参传递给其他的函数。你创建出来的闭包可以在与创建环境完全不同的上下文进行调用求值。和函数不同，定义闭包时，你可以捕获当前上下文作用域当中的值。我们将示范闭包特性如何让我们实现代码重用和行为自定义。\n解释一下什么是行为自定义，举个例子，你编写了一个函数，形参可以传入一个函数，使用传入的函数来操控你值，相当于把控制权交给了外部定义，外部就可以自定义将要执行的行为。 使用闭包抽象化行为 Let’s work on an example of a situation in which it’s useful to store a closure to be executed later. Along the way, we’ll talk about the syntax of closures, type inference, and traits.\nConsider this hypothetical situation: we work at a startup that’s making an app to generate custom exercise workout plans. The backend is written in Rust, and the algorithm that generates the workout plan takes into account many factors, such as the app user’s age, body mass index, exercise preferences, recent workouts, and an intensity number they specify. The actual algorithm used isn’t important in this example; what’s important is that this calculation takes a few seconds. We want to call this algorithm only when we need to and only call it once so we don’t make the user wait more than necessary.\n让我们举个例子演示一下创建闭包并稍后执行它的情况下有多么有用。在这个过程中，我们将谈论闭包的语法、类型推断以及特性。\n考虑这么一种假设：我们正在一家初创公司工作，这家公司正在打造一款可生成个性化运动训练计划的应用程序。应用的后台由rust编写，生成锻炼计划的算法需要考虑很多因素，例如用户的年龄、身体质量指数、运动偏好、最近的锻炼和用户指定的强度指数。实际使用了什么算法在这个例子中并不重要，重要的是这个计算需要几秒钟。我们只想在需要时调用一次这个算法，这样我们就不会让用户等待过长时间。\nWe’ll simulate calling this hypothetical algorithm with the function simulated_expensive_calculation shown in Listing 13-1, which will print calculating slowly..., wait for two seconds, and then return whatever number we passed in.\nFilename: src/main.rs\nuse std::thread; use std::time::Duration; fn simulated_expensive_calculation(intensity: u32) -\u003e u32 { println!(\"calculating slowly...\"); thread::sleep(Duration::from_secs(2)); intensity } 我们将使用下面的函数simulated_expensive_calculation来模拟调用我们假设的算法，这个函数将打印calculating slowly...然后等待2秒钟，然后返回我们传入的数字。\nNext is the main function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app’s frontend isn’t relevant to the use of closures, we’ll hardcode values representing inputs to our program and print the outputs.\nThe required inputs are these:\nAn intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout A random number that will generate some variety in the workout plans The output will be the recommended workout plan. Listing 13-2 shows the main function we’ll use.\nFilename: src/main.rs\nfn main() { let simulated_user_specified_value = 10; let simulated_random_number = 7; generate_workout(simulated_user_specified_value, simulated_random_number); } 下面是main函数，其中包含了本示例中健身应用程序的重要部分。这个函数是当用户请求生成锻炼计划时会执行的代码，由于与应用程序前端的交互与闭包的使用无关，我们将直接硬编码程序的输入并打印输出的值。\nThe required inputs are these:\nAn intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout A random number that will generate some variety in the workout plans The output will be the recommended workout plan. Listing 13-2 shows the main function we’ll use.\nfn main() { let simulated_user_specified_value = 10; let simulated_random_number = 7; generate_workout( simulated_user_specified_value, simulated_random_number ); } fn generate_workout(intensity: u32, random_number: u32) {} 所需的输入如下：\n一个用户设置的强度值，用于在他们想要生成计划时指定生成的计划强度。 一个随机数，在锻炼计划中增加一些变化 输出将是推荐的锻炼计划。\nWe’ve hardcoded the variable simulated_user_specified_value as 10 and the variable simulated_random_number as 7 for simplicity’s sake; in an actual program, we’d get the intensity number from the app frontend, and we’d use the rand crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The main function calls a generate_workout function with the simulated input values.\nNow that we have the context, let’s get to the algorithm. The function generate_workout in Listing 13-3 contains the business logic of the app that we’re most concerned with in this example. The rest of the code changes in this example will be made to this function.\nuse std::thread; use std::time::Duration; fn simulated_expensive_calculation(intensity: u32) -\u003e u32 { println!(\"calculating slowly...\"); thread::sleep(Duration::from_secs(2)); intensity } fn generate_workout(intensity: u32, random_number: u32) { if intensity \u003c 25 { println!( \"Today, do {} pushups!\", simulated_expensive_calculation(intensity) ); println!( \"Next, do {} situps!\", simulated_expensive_calculation(intensity) ); } else { if random_number == 3 { println!(\"Take a break today! Remember to stay hydrated!\"); } else { println!( \"Today, run for {} minutes!\", simulated_expensive_calculation(intensity) ); } } } fn main() { let simulated_user_specified_value = 10; let simulated_random_number = 7; generate_workout(simulated_user_specified_value, simulated_random_number); } 简单起见，我们把simulated_user_specified_value和simulated_random_number硬编码为了10和7。在实 际程序中，我们从app前台获取到了强度数值，然后我们使用rand库生成一个随机值，就像我们在第二章中的Guessing Game例子一样。main函数中使用模拟输入值调用generate_workout。\n现在我们有了上下文，让我们来看看算法。13-3节中的generate_workout函数包含了这个例子中我们最关心的应用业务逻辑。本例中剩余的代码修改都是针对这个函数。\n","wordCount":"868","inLanguage":"zh","datePublished":"2023-06-06T23:09:15+08:00","dateModified":"2023-06-06T23:09:15+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/rust%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%89%B9%E6%80%A7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E9%97%AD%E5%8C%85/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li><li><a href=https://www.yici.xin/archives/ title=归档🕰️><span>归档🕰️</span></a></li><li><a href=https://www.yici.xin/projects/ title=项目☢️><span>项目☢️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Rust函数式编程特性 迭代器和闭包</h1><div class=post-meta><span title='2023-06-06 23:09:15 +0800 +0800'>2023-06-06</span>&nbsp;·&nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/tech/rust%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%89%b9%e6%80%a7-%e8%bf%ad%e4%bb%a3%e5%99%a8%e5%92%8c%e9%97%ad%e5%8c%85.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e7%ae%80%e4%bb%8b aria-label=简介>简介</a></li><li><a href=#%e9%97%ad%e5%8c%85%e5%8f%af%e4%bb%a5%e6%8d%95%e8%8e%b7%e7%8e%af%e5%a2%83%e7%9a%84%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0 aria-label=闭包：可以捕获环境的匿名函数>闭包：可以捕获环境的匿名函数</a><ul><li><a href=#%e4%bd%bf%e7%94%a8%e9%97%ad%e5%8c%85%e6%8a%bd%e8%b1%a1%e5%8c%96%e8%a1%8c%e4%b8%ba aria-label=使用闭包抽象化行为>使用闭包抽象化行为</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=简介>简介<a hidden class=anchor aria-hidden=true href=#简介>#</a></h2><blockquote><p>Rust’s design has taken inspiration from many existing languages and techniques, and one significant influence is <em>functional programming</em>. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.</p><p>In this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.</p><p>More specifically, we’ll cover:</p><ul><li><em>Closures</em>, a function-like construct you can store in a variable</li><li><em>Iterators</em>, a way of processing a series of elements</li><li>How to use these two features to improve the I/O project in Chapter 12</li><li>The performance of these two features (Spoiler alert: they’re faster than you might think!)</li></ul><p>Other Rust features, such as pattern matching and enums, which we’ve covered in other chapters, are influenced by the functional style as well. Mastering closures and iterators is an important part of writing idiomatic, fast Rust code, so we’ll devote this entire chapter to them.</p></blockquote><p>Rust的设计灵感来自很多现存的语言和技术，其中显著的一个影响是**“函数式编程”**。函数式编程经常把函数当做实参传递、作为其他函数的返回值、赋值给变量用于之后的执行。</p><p>在这一节，我们不会去讨论函数式编程到底是什么，而是讨论一些 Rust 的特性，这些特性与许多常被称为函数式的语言中的特性相似。</p><p>具体会涉及这些内容：</p><ul><li><strong>闭包</strong>（<em>Closures</em>），一个可以储存在变量里的类函数的结构</li><li><strong>迭代器</strong>（<em>Iterator</em>），一种处理元素序列的方式</li><li>如何使用这些特性改善第12章中的io项目</li><li>这两种特性的性能如何（剧透一下：它们的性能可能比你想的要高）</li></ul><p>如模式匹配和枚举这样受函数式风格影响的其他Rust特性，我们已经在其他章讲过了。掌握闭包和迭代器是编写符合风格、高性能的rust代码的重要一环，所以我们将专门一整章来讲解它们。</p><h2 id=闭包可以捕获环境的匿名函数>闭包：可以捕获环境的匿名函数<a hidden class=anchor aria-hidden=true href=#闭包可以捕获环境的匿名函数>#</a></h2><blockquote><p>Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.</p></blockquote><p>rust的闭包是一个匿名函数，你可以将它保存在一个变量当中，或者当做实参传递给其他的函数。你创建出来的闭包可以在与创建环境完全不同的上下文进行调用求值。和函数不同，定义闭包时，你可以捕获当前上下文作用域当中的值。我们将示范闭包特性如何让我们实现代码重用和行为自定义。</p><style type=text/css media=screen>html{--color-alert-info-text:#24292e;--color-alert-info-bg:#dbedff;--color-alert-info-border:rgba(4, 66, 137, 0.2);--color-alert-warn-text:#24292e;--color-alert-warn-bg:#fffbdd;--color-alert-warn-border:rgba(176, 136, 0, 0.2);--color-alert-error-text:#24292e;--color-alert-error-bg:#ffe3e6;--color-alert-error-border:rgba(158, 28, 35, 0.2);--color-alert-success-text:#24292e;--color-alert-success-bg:#dcffe4;--color-alert-success-border:rgba(23, 111, 44, 0.2)}html[data-theme=dark]{--color-alert-info-text:#79c0ff;--color-alert-info-bg:rgba(56, 139, 253, 0.1);--color-alert-info-border:rgba(56, 139, 253, 0.4);--color-alert-warn-text:#e3b341;--color-alert-warn-bg:rgba(187, 128, 9, 0.1);--color-alert-warn-border:rgba(187, 128, 9, 0.4);--color-alert-error-text:#ff7b72;--color-alert-error-bg:rgba(248, 81, 73, 0.1);--color-alert-error-border:rgba(248, 81, 73, 0.4);--color-alert-success-text:#56d364;--color-alert-success-bg:rgba(46, 160, 67, 0.1);--color-alert-success-border:rgba(46, 160, 67, 0.4)}.tips{position:relative;padding:20px 16px;margin-bottom:20px;border-style:solid;border-width:1px;border-radius:6px;border-left-style:solid;border-left-width:6px}.tips.info{color:var(--color-alert-info-text);background-image:linear-gradient(var(--color-alert-info-bg),var(--color-alert-info-bg));border-color:var(--color-alert-info-border)}.tips.warn{color:var(--color-alert-warn-text);background-image:linear-gradient(var(--color-alert-warn-bg),var(--color-alert-warn-bg));border-color:var(--color-alert-warn-border)}.tips.error{color:var(--color-alert-error-text);background-image:linear-gradient(var(--color-alert-error-bg),var(--color-alert-error-bg));border-color:var(--color-alert-error-border)}.tips.success{color:var(--color-alert-success-text);background-image:linear-gradient(var(--color-alert-success-bg),var(--color-alert-success-bg));border-color:var(--color-alert-success-border)}#tips-title{font-size:19px;font-weight:800;margin-bottom:10px}</style><div class="tips info">解释一下什么是行为自定义，举个例子，你编写了一个函数，形参可以传入一个函数，使用传入的函数来操控你值，相当于把控制权交给了外部定义，外部就可以自定义将要执行的行为。</div><h3 id=使用闭包抽象化行为>使用闭包抽象化行为<a hidden class=anchor aria-hidden=true href=#使用闭包抽象化行为>#</a></h3><blockquote><p>Let’s work on an example of a situation in which it’s useful to store a closure to be executed later. Along the way, we’ll talk about the syntax of closures, type inference, and traits.</p><p>Consider this hypothetical situation: we work at a startup that’s making an app to generate custom exercise workout plans. The backend is written in Rust, and the algorithm that generates the workout plan takes into account many factors, such as the app user’s age, body mass index, exercise preferences, recent workouts, and an intensity number they specify. The actual algorithm used isn’t important in this example; what’s important is that this calculation takes a few seconds. We want to call this algorithm only when we need to and only call it once so we don’t make the user wait more than necessary.</p></blockquote><p>让我们举个例子演示一下创建闭包并稍后执行它的情况下有多么有用。在这个过程中，我们将谈论闭包的语法、类型推断以及特性。</p><p>考虑这么一种假设：我们正在一家初创公司工作，这家公司正在打造一款可生成个性化运动训练计划的应用程序。应用的后台由rust编写，生成锻炼计划的算法需要考虑很多因素，例如用户的年龄、身体质量指数、运动偏好、最近的锻炼和用户指定的强度指数。实际使用了什么算法在这个例子中并不重要，重要的是这个计算需要几秒钟。我们只想在需要时调用一次这个算法，这样我们就不会让用户等待过长时间。</p><blockquote><p>We’ll simulate calling this hypothetical algorithm with the function <code>simulated_expensive_calculation</code> shown in Listing 13-1, which will print <code>calculating slowly...</code>, wait for two seconds, and then return whatever number we passed in.</p><p>Filename: src/main.rs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulated_expensive_calculation</span>(intensity: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>   println!(<span style=color:#e6db74>&#34;calculating slowly...&#34;</span>);
</span></span><span style=display:flex><span>   thread::sleep(Duration::from_secs(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>   intensity
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></blockquote><p>我们将使用下面的函数<code>simulated_expensive_calculation</code>来模拟调用我们假设的算法，这个函数将打印<code>calculating slowly...</code>然后等待2秒钟，然后返回我们传入的数字。</p><blockquote><p>Next is the <code>main</code> function, which contains the parts of the workout app important for this example. This function represents the code that the app will call when a user asks for a workout plan. Because the interaction with the app’s frontend isn’t relevant to the use of closures, we’ll hardcode values representing inputs to our program and print the outputs.</p><p>The required inputs are these:</p><ul><li>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</li><li>A random number that will generate some variety in the workout plans</li></ul><p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code> function we’ll use.</p><p>Filename: src/main.rs</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>let</span> simulated_user_specified_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>let</span> simulated_random_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   generate_workout(simulated_user_specified_value, simulated_random_number);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></blockquote><p>下面是main函数，其中包含了本示例中健身应用程序的重要部分。这个函数是当用户请求生成锻炼计划时会执行的代码，由于与应用程序前端的交互与闭包的使用无关，我们将直接硬编码程序的输入并打印输出的值。</p><blockquote><p>The required inputs are these:</p><ul><li>An intensity number from the user, which is specified when they request a workout to indicate whether they want a low-intensity workout or a high-intensity workout</li><li>A random number that will generate some variety in the workout plans</li></ul><p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code> function we’ll use.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>let</span> simulated_user_specified_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>let</span> simulated_random_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   generate_workout(
</span></span><span style=display:flex><span>       simulated_user_specified_value,
</span></span><span style=display:flex><span>       simulated_random_number
</span></span><span style=display:flex><span>   );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_workout</span>(intensity: <span style=color:#66d9ef>u32</span>, random_number: <span style=color:#66d9ef>u32</span>) {}
</span></span></code></pre></div></blockquote><p>所需的输入如下：</p><ul><li>一个用户设置的强度值，用于在他们想要生成计划时指定生成的计划强度。</li><li>一个随机数，在锻炼计划中增加一些变化</li></ul><p>输出将是推荐的锻炼计划。</p><blockquote><p>We’ve hardcoded the variable <code>simulated_user_specified_value</code> as 10 and the variable <code>simulated_random_number</code> as 7 for simplicity’s sake; in an actual program, we’d get the intensity number from the app frontend, and we’d use the <code>rand</code> crate to generate a random number, as we did in the Guessing Game example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function with the simulated input values.</p><p>Now that we have the context, let’s get to the algorithm. The function <code>generate_workout</code> in Listing 13-3 contains the business logic of the app that we’re most concerned with in this example. The rest of the code changes in this example will be made to this function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> std::thread;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> std::time::Duration;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>simulated_expensive_calculation</span>(intensity: <span style=color:#66d9ef>u32</span>) -&gt; <span style=color:#66d9ef>u32</span> {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;calculating slowly...&#34;</span>);
</span></span><span style=display:flex><span>    thread::sleep(Duration::from_secs(<span style=color:#ae81ff>2</span>));
</span></span><span style=display:flex><span>    intensity
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>generate_workout</span>(intensity: <span style=color:#66d9ef>u32</span>, random_number: <span style=color:#66d9ef>u32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> intensity <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>25</span> {
</span></span><span style=display:flex><span>        println!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Today, do </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> pushups!&#34;</span>,
</span></span><span style=display:flex><span>            simulated_expensive_calculation(intensity)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        println!(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;Next, do </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> situps!&#34;</span>,
</span></span><span style=display:flex><span>            simulated_expensive_calculation(intensity)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> random_number <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;Take a break today! Remember to stay hydrated!&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            println!(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;Today, run for </span><span style=color:#e6db74>{}</span><span style=color:#e6db74> minutes!&#34;</span>,
</span></span><span style=display:flex><span>                simulated_expensive_calculation(intensity)
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> simulated_user_specified_value <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> simulated_random_number <span style=color:#f92672>=</span> <span style=color:#ae81ff>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    generate_workout(simulated_user_specified_value, simulated_random_number);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></blockquote><p>简单起见，我们把<code>simulated_user_specified_value</code>和<code>simulated_random_number</code>硬编码为了10和7。在实 际程序中，我们从app前台获取到了强度数值，然后我们使用<code>rand</code>库生成一个随机值，就像我们在第二章中的Guessing Game例子一样。main函数中使用模拟输入值调用generate_workout。</p><p>现在我们有了上下文，让我们来看看算法。13-3节中的<code>generate_workout</code>函数包含了这个例子中我们最关心的应用业务逻辑。本例中剩余的代码修改都是针对这个函数。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/rust/>rust</a></li><li><a href=https://www.yici.xin/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/>函数式编程</a></li><li><a href=https://www.yici.xin/tags/%E9%97%AD%E5%8C%85/>闭包</a></li><li><a href=https://www.yici.xin/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/>迭代器</a></li></ul><nav class=paginav><a class=next href=https://www.yici.xin/post/tech/rust%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84vector/><span class=title>下一页 »</span><br><span>Rust动态数组Vector</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
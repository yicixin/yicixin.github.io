<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang-map的操作 | 绝知</title>
<meta name=keywords content="golang,map,hashmap,源码解析"><meta name=description content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.09ec7b2639f9095779b73636ae4b3857a1b98d87bcdb44b187c9a7c6a5c1cfb9.css integrity="sha256-Cex7Jjn5CVd5tzY2rks4V6G5jYe820Sxh8mnxqXBz7k=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="Golang-map的操作"><meta property="og:description" content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:49:41+08:00"><meta property="article:modified_time" content="2022-12-30T10:49:41+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang-map的操作"><meta name=twitter:description content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang-map的操作","item":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang-map的操作","name":"Golang-map的操作","description":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。 // 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。 // 如果h不是nil，那么该map能直接创建在这个h上。 // 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket func makemap(t *maptype, hint int, h *hmap) *hmap { // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小 mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // 初始化hmap，并指定随机种子 if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B \u0026lt; hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现 if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // 溢出桶地址赋值 h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u0026lt;\u0026lt;b is the minimum number of buckets to allocate. // dirtyalloc should either be nil or a bucket array previously // allocated by makeBucketArray with the same t and b parameters. // If dirtyalloc is nil a new backing array will be alloced and // otherwise dirtyalloc will be cleared and reused as backing array. // 翻译：makeBucketArray为map buckets初始化一个备用数组 // 2^b是该buckets长度的最小值 // dirtyalloc之前应该是nil或者bucket数组 // 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。 func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { base := bucketShift(b) // base = 2^b nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销 // 对于b\u0026gt;4（桶的数量\u0026gt; 2^4）的话，则需要创建2^(b-4)个溢出桶。 if b \u0026gt;= 4 { // 加上溢出桶的数量 nbuckets += bucketShift(b - 4) // 总大小 sz := t.bucket.size * nbuckets // 针对所需要的内存大小，mallocgc将分配的内存块大小 up := roundupsize(sz) if up != sz { // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets nbuckets = up / t.bucket.size } } if dirtyalloc == nil { buckets = newarray(t.bucket, int(nbuckets)) } else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.ptrdata != 0 { memclrHasPointers(buckets, size) } else { memclrNoHeapPointers(buckets, size) } } if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket\u0026#39;s overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定: // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用， // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶 // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中 nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶 last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶 last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶 } return buckets, nextOverflow } 从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。\n","keywords":["golang","map","hashmap","源码解析"],"articleBody":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。 // 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。 // 如果h不是nil，那么该map能直接创建在这个h上。 // 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket func makemap(t *maptype, hint int, h *hmap) *hmap { // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小 mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // 初始化hmap，并指定随机种子 if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B \u003c hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现 if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // 溢出桶地址赋值 h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u003c","wordCount":"2376","inLanguage":"zh","datePublished":"2022-12-30T10:49:41+08:00","dateModified":"2022-12-30T10:49:41+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"绝知","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="绝知 (Alt + H)">绝知</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Golang-map的操作</h1><div class=post-meta><span title='2022-12-30 10:49:41 +0800 +0800'>2022-12-30</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%88%9b%e5%bb%ba-map aria-label="创建 map">创建 map</a></li><li><a href=#map-%e7%9a%84%e8%af%bb%e5%8f%96 aria-label="map 的读取">map 的读取</a></li><li><a href=#map-%e5%86%99%e5%85%a5 aria-label="map 写入">map 写入</a></li><li><a href=#map-%e6%89%a9%e5%ae%b9 aria-label="map 扩容">map 扩容</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=创建-map>创建 map<a hidden class=anchor aria-hidden=true href=#创建-map>#</a></h3><p>创建 map 的语法很简单</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// 不指定map长度</span>
</span></span><span style=display:flex><span>ageMp <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>int</span>)
</span></span><span style=display:flex><span><span style=color:#6272a4>// 指定map长度</span>
</span></span><span style=display:flex><span>ageMp <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>int</span>, <span style=color:#bd93f9>8</span>)
</span></span><span style=display:flex><span><span style=color:#6272a4>// ageMp 为 nil，不能向其添加元素，会直接panic</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>var</span> ageMp <span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>string</span>]<span style=color:#8be9fd>int</span>
</span></span></code></pre></div><p>通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// makemap implements Go map creation for make(map[k]v, hint).</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// If the compiler has determined that the map or the first bucket</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// can be created on the stack, h and/or bucket may be non-nil.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// If h != nil, the map can be created directly in h.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如果h不是nil，那么该map能直接创建在这个h上。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makemap</span>(t <span style=color:#ff79c6>*</span>maptype, hint <span style=color:#8be9fd>int</span>, h <span style=color:#ff79c6>*</span>hmap) <span style=color:#ff79c6>*</span>hmap {
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小</span>
</span></span><span style=display:flex><span>    mem, overflow <span style=color:#ff79c6>:=</span> math.<span style=color:#50fa7b>MulUintptr</span>(<span style=color:#8be9fd;font-style:italic>uintptr</span>(hint), t.bucket.size)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> mem &gt; maxAlloc {
</span></span><span style=display:flex><span>        hint = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 初始化hmap，并指定随机种子</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        h = <span style=color:#8be9fd;font-style:italic>new</span>(hmap)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    h.hash0 = <span style=color:#50fa7b>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Find the size parameter B which will hold the requested # of elements.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B &lt; hint</span>
</span></span><span style=display:flex><span>    B <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uint8</span>(<span style=color:#bd93f9>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> <span style=color:#50fa7b>overLoadFactor</span>(hint, B) {
</span></span><span style=display:flex><span>        B<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    h.B = B
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// allocate initial hash table</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// if B == 0, the buckets field is allocated lazily later (in mapassign)</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// If hint is large zeroing this memory could take a while.</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.B <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>var</span> nextOverflow <span style=color:#ff79c6>*</span>bmap
</span></span><span style=display:flex><span>        h.buckets, nextOverflow = <span style=color:#50fa7b>makeBucketArray</span>(t, h.B, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> nextOverflow <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>            h.extra = <span style=color:#8be9fd;font-style:italic>new</span>(mapextra)
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 溢出桶地址赋值</span>
</span></span><span style=display:flex><span>            h.extra.nextOverflow = nextOverflow
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> h
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// makeBucketArray initializes a backing array for map buckets.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 1&lt;&lt;b is the minimum number of buckets to allocate.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// dirtyalloc should either be nil or a bucket array previously</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// allocated by makeBucketArray with the same t and b parameters.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// If dirtyalloc is nil a new backing array will be alloced and</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// otherwise dirtyalloc will be cleared and reused as backing array.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 翻译：makeBucketArray为map buckets初始化一个备用数组</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 2^b是该buckets长度的最小值</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// dirtyalloc之前应该是nil或者bucket数组</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makeBucketArray</span>(t <span style=color:#ff79c6>*</span>maptype, b <span style=color:#8be9fd>uint8</span>, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow <span style=color:#ff79c6>*</span>bmap) {
</span></span><span style=display:flex><span>    base <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>bucketShift</span>(b) <span style=color:#6272a4>// base = 2^b</span>
</span></span><span style=display:flex><span>    nbuckets <span style=color:#ff79c6>:=</span> base
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// For small b, overflow buckets are unlikely.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Avoid the overhead of the calculation.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 对于b&gt;4（桶的数量&gt; 2^4）的话，则需要创建2^(b-4)个溢出桶。</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> b <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 加上溢出桶的数量</span>
</span></span><span style=display:flex><span>        nbuckets <span style=color:#ff79c6>+=</span> <span style=color:#50fa7b>bucketShift</span>(b <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 总大小</span>
</span></span><span style=display:flex><span>        sz <span style=color:#ff79c6>:=</span> t.bucket.size <span style=color:#ff79c6>*</span> nbuckets
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 针对所需要的内存大小，mallocgc将分配的内存块大小</span>
</span></span><span style=display:flex><span>        up <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>roundupsize</span>(sz)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> up <span style=color:#ff79c6>!=</span> sz {
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets</span>
</span></span><span style=display:flex><span>            nbuckets = up <span style=color:#ff79c6>/</span> t.bucket.size
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> dirtyalloc <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        buckets = <span style=color:#50fa7b>newarray</span>(t.bucket, <span style=color:#8be9fd;font-style:italic>int</span>(nbuckets))
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// dirtyalloc was previously generated by</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// the above newarray(t.bucket, int(nbuckets))</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// but may not be empty.</span>
</span></span><span style=display:flex><span>        buckets = dirtyalloc
</span></span><span style=display:flex><span>        size <span style=color:#ff79c6>:=</span> t.bucket.size <span style=color:#ff79c6>*</span> nbuckets
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> t.bucket.ptrdata <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>memclrHasPointers</span>(buckets, size)
</span></span><span style=display:flex><span>        } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>memclrNoHeapPointers</span>(buckets, size)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> base <span style=color:#ff79c6>!=</span> nbuckets {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// We preallocated some overflow buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// To keep the overhead of tracking these overflow buckets to a minimum,</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// we use the convention that if a preallocated overflow bucket&#39;s overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// pointer is nil, then there are more available by bumping the pointer.</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中</span>
</span></span><span style=display:flex><span>        nextOverflow = (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(buckets, base<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize))) <span style=color:#6272a4>// 指向第一个溢出桶</span>
</span></span><span style=display:flex><span>        last <span style=color:#ff79c6>:=</span> (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(buckets, (nbuckets<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize))) <span style=color:#6272a4>// 指向最后一个溢出桶</span>
</span></span><span style=display:flex><span>        last.<span style=color:#50fa7b>setoverflow</span>(t, (<span style=color:#ff79c6>*</span>bmap)(buckets)) <span style=color:#6272a4>// 溢出桶的最后一个桶的overflow指向了buckets的第一个桶</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> buckets, nextOverflow
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202201182254581.jpeg alt=手绘图></p><h3 id=map-的读取>map 的读取<a hidden class=anchor aria-hidden=true href=#map-的读取>#</a></h3><p>对于 map 的读取操作，最终是调用了函数 <code>runtime.mapaccess1()</code>和 <code>runtime.mapaccess2()</code> 。两者的唯一区别就是返回值不一样，<code>runtime.mapaccess1()</code> 返回的是一个值，<code>runtime.mapaccess2()</code> 返回的是两个值，第二个值表示 key 是否在 map 中存在。即我们常用的两种 map 取值方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>v <span style=color:#ff79c6>:=</span> ageMap[<span style=color:#f1fa8c>&#34;yicixin&#34;</span>]
</span></span><span style=display:flex><span>v, ok <span style=color:#ff79c6>:=</span> ageMap[<span style=color:#f1fa8c>&#34;yicixin&#34;</span>]
</span></span></code></pre></div><p>所以我们只需要介绍<code>runtime.mapaccess1()</code>,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// it will return a reference to the zero object for the elem type if</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// the key is not in the map.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// NOTE: The returned pointer may keep the whole map live, so don&#39;t</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// hold onto it for very long.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// mapaccess1返回指向h[key]的指针，永远不会返回nil，如果key不存在，就会返回元素对应类型的空值。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 注意：返回的指针可能会使得整个map处于活动状态，所以不要长时间持有它</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>mapaccess1</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> raceenabled <span style=color:#ff79c6>&amp;&amp;</span> h <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        callerpc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getcallerpc</span>()
</span></span><span style=display:flex><span>        pc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>funcPC</span>(mapaccess1)
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>racereadpc</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(h), callerpc, pc)
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>raceReadObjectPC</span>(t.key, key, callerpc, pc)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> msanenabled <span style=color:#ff79c6>&amp;&amp;</span> h <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>msanread</span>(key, t.key.size)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 判断h是否为nil或者h.count值是否为0，如果h为nil则表示未初始化，则可能panic，如果h.count=0,则表示map为空，则直接返回一个zero值。</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>||</span> h.count <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>hashMightPanic</span>() {
</span></span><span style=display:flex><span>            t.<span style=color:#50fa7b>hasher</span>(key, <span style=color:#bd93f9>0</span>) <span style=color:#6272a4>// see issue 23734</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>zeroVal[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 考虑是否处于并发读写状态，否则产生panic</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>hashWriting <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;concurrent map read and map write&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 根据键key计算hash值</span>
</span></span><span style=display:flex><span>    hash <span style=color:#ff79c6>:=</span> t.<span style=color:#50fa7b>hasher</span>(key, <span style=color:#8be9fd;font-style:italic>uintptr</span>(h.hash0))
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 计算低B位的掩码bucketMask(h.B)，比如 B=5，那 m 就是31，低五位二进制是全1</span>
</span></span><span style=display:flex><span>    m <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>bucketMask</span>(h.B)
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 计算当前bucket的地址</span>
</span></span><span style=display:flex><span>    b <span style=color:#ff79c6>:=</span> (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(h.buckets, (hash<span style=color:#ff79c6>&amp;</span>m)<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 根据h.oldbuckets判断是否处于扩容中，如果不是nil则表示当前map正处于扩容状态中</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>:=</span> h.oldbuckets; c <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !h.<span style=color:#50fa7b>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// There used to be half as many buckets; mask down one more power of two.</span>
</span></span><span style=display:flex><span>            m <span style=color:#ff79c6>&gt;&gt;=</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        oldb <span style=color:#ff79c6>:=</span> (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(c, (hash<span style=color:#ff79c6>&amp;</span>m)<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !<span style=color:#50fa7b>evacuated</span>(oldb) {
</span></span><span style=display:flex><span>            b = oldb
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 计算tophash，即高八位</span>
</span></span><span style=display:flex><span>    top <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>tophash</span>(hash)
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 真正开始查找key,外层for是循环bucket及溢出桶overflow，内层for是循环桶内的8个slot</span>
</span></span><span style=display:flex><span>bucketloop:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> ; b <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span>; b = b.<span style=color:#50fa7b>overflow</span>(t) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(<span style=color:#bd93f9>0</span>); i &lt; bucketCnt; i<span style=color:#ff79c6>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> b.tophash[i] <span style=color:#ff79c6>!=</span> top {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> b.tophash[i] <span style=color:#ff79c6>==</span> emptyRest {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>break</span> bucketloop
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            k <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectkey</span>() {
</span></span><span style=display:flex><span>                k = <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>*</span>unsafe.Pointer)(k))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> t.key.<span style=color:#50fa7b>equal</span>(key, k) {
</span></span><span style=display:flex><span>                e <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize)<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize))
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectelem</span>() {
</span></span><span style=display:flex><span>                    e = <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>*</span>unsafe.Pointer)(e))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>return</span> e
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>zeroVal[<span style=color:#bd93f9>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>key 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>k <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span></code></pre></div><p>value 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>e <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize)<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize))
</span></span></code></pre></div><p>其中 dataOffset 表示 第一个 key 相对于 bmap 的偏移量，结构体如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>dataOffset = unsafe.<span style=color:#50fa7b>Offsetof</span>(<span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>        b bmap
</span></span><span style=display:flex><span>        v <span style=color:#8be9fd>int64</span>
</span></span><span style=display:flex><span>    }{}.v)
</span></span></code></pre></div><p>所以键的地址=当前 bucket 的起始位置(<code>unsafe.Pointer(b)</code>) + 第一个 key 的偏移量(<code>dataOffset</code>)+当前 slot 索引值(<code>i</code>) * 每个键的大小(<code>uintptr(t.keysize)</code>)</p><p>而对于值来说，由于 bmap.values 在 b.map.keys 后面，所以要先将 8 个键的地址全部计算上才行，同样值类型也有自己的大小 <code>t.elemsize</code></p><p>bucket 的几种状态码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    emptyRest      = <span style=color:#bd93f9>0</span> <span style=color:#6272a4>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow</span>
</span></span><span style=display:flex><span>    emptyOne       = <span style=color:#bd93f9>1</span> <span style=color:#6272a4>// 当前cell为空</span>
</span></span><span style=display:flex><span>    evacuatedX     = <span style=color:#bd93f9>2</span> <span style=color:#6272a4>// key/elem is valid.  Entry has been evacuated to first half of larger table.</span>
</span></span><span style=display:flex><span>    evacuatedY     = <span style=color:#bd93f9>3</span> <span style=color:#6272a4>// 扩容相关，第二部分迁移完毕。</span>
</span></span><span style=display:flex><span>    evacuatedEmpty = <span style=color:#bd93f9>4</span> <span style=color:#6272a4>// 当前cell为空，且迁移完成。</span>
</span></span><span style=display:flex><span>    minTopHash     = <span style=color:#bd93f9>5</span> <span style=color:#6272a4>// tophash最小值，如果在调用 tophash(hash)时，计算出的值小于此值，则会加上此值</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// tophash calculates the tophash value for hash.</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>tophash</span>(hash <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>uint8</span> {
</span></span><span style=display:flex><span>        top <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uint8</span>(hash <span style=color:#ff79c6>&gt;&gt;</span> (sys.PtrSize<span style=color:#ff79c6>*</span><span style=color:#bd93f9>8</span> <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>8</span>))
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> top &lt; minTopHash {
</span></span><span style=display:flex><span>        top <span style=color:#ff79c6>+=</span> minTopHash
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> top
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=map-写入>map 写入<a hidden class=anchor aria-hidden=true href=#map-写入>#</a></h3><p>与 map 写入相关的 runtime 函数是<code>runtime.mapassign()</code>，对于某些 key 类型，runtime 还有特定的函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#50fa7b>mapassign_faststr</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, s <span style=color:#8be9fd>string</span>) unsafe.Pointer
</span></span><span style=display:flex><span><span style=color:#50fa7b>mapassign_fast64</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, key <span style=color:#8be9fd>uint64</span>) unsafe.Pointer
</span></span><span style=display:flex><span><span style=color:#50fa7b>mapassign_fast32</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, key <span style=color:#8be9fd>uint32</span>) unsafe.Pointer
</span></span></code></pre></div><p>这是<code>runtime.mapassign</code>函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>mapassign</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, key unsafe.Pointer) unsafe.Pointer {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 空map写入会触发panic</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;assignment to entry in nil map&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// raceenabled-是否启用数据竞争检测</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>        callerpc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getcallerpc</span>()
</span></span><span style=display:flex><span>        pc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>funcPC</span>(mapassign)
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>racewritepc</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(h), callerpc, pc)
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>raceReadObjectPC</span>(t.key, key, callerpc, pc)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> msanenabled {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>msanread</span>(key, t.key.size)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果并发写入会触发panic</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>hashWriting <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 计算hash值</span>
</span></span><span style=display:flex><span>    hash <span style=color:#ff79c6>:=</span> t.<span style=color:#50fa7b>hasher</span>(key, <span style=color:#8be9fd;font-style:italic>uintptr</span>(h.hash0))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Set hashWriting after calling t.hasher, since t.hasher may panic,</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// in which case we have not actually done a write.</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 设置写入标志位</span>
</span></span><span style=display:flex><span>    h.flags ^= hashWriting
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.buckets <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        h.buckets = <span style=color:#50fa7b>newobject</span>(t.bucket) <span style=color:#6272a4>// newarray(t.bucket, 1)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>again:
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 定位bucket</span>
</span></span><span style=display:flex><span>    bucket <span style=color:#ff79c6>:=</span> hash <span style=color:#ff79c6>&amp;</span> <span style=color:#50fa7b>bucketMask</span>(h.B)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.<span style=color:#50fa7b>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>growWork</span>(t, h, bucket)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    b <span style=color:#ff79c6>:=</span> (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(h.buckets, bucket<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>    top <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>tophash</span>(hash)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> inserti <span style=color:#ff79c6>*</span><span style=color:#8be9fd>uint8</span> <span style=color:#6272a4>// tophash的位置</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> insertk unsafe.Pointer <span style=color:#6272a4>// key的地址</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> elem unsafe.Pointer <span style=color:#6272a4>// val的地址</span>
</span></span><span style=display:flex><span>bucketloop:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(<span style=color:#bd93f9>0</span>); i &lt; bucketCnt; i<span style=color:#ff79c6>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> b.tophash[i] <span style=color:#ff79c6>!=</span> top {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> <span style=color:#50fa7b>isEmpty</span>(b.tophash[i]) <span style=color:#ff79c6>&amp;&amp;</span> inserti <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>                    inserti = <span style=color:#ff79c6>&amp;</span>b.tophash[i]
</span></span><span style=display:flex><span>                    insertk = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>                    elem = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize)<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow, 可以退出循环了</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> b.tophash[i] <span style=color:#ff79c6>==</span> emptyRest {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>break</span> bucketloop
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>              <span style=color:#6272a4>// b.tophash[i] == top</span>
</span></span><span style=display:flex><span>            k <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectkey</span>() {
</span></span><span style=display:flex><span>                k = <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>*</span>unsafe.Pointer)(k))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> !t.key.<span style=color:#50fa7b>equal</span>(key, k) {
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// already have a mapping for key. Update it.</span>
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>needkeyupdate</span>() {
</span></span><span style=display:flex><span>                <span style=color:#50fa7b>typedmemmove</span>(t.key, k, key)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            elem = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset<span style=color:#ff79c6>+</span>bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize)<span style=color:#ff79c6>+</span>i<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize))
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>goto</span> done
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 如果还有溢出桶，继续查询溢出桶</span>
</span></span><span style=display:flex><span>        ovf <span style=color:#ff79c6>:=</span> b.<span style=color:#50fa7b>overflow</span>(t)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> ovf <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        b = ovf
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Did not find mapping for key. Allocate new cell &amp; add entry.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// If we hit the max load factor or we have too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// and we&#39;re not already in the middle of growing, start growing.</span>
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 如果负载因子到了最大或者有太多的溢出桶，并且不在扩容中，开始扩容</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !h.<span style=color:#50fa7b>growing</span>() <span style=color:#ff79c6>&amp;&amp;</span> (<span style=color:#50fa7b>overLoadFactor</span>(h.count<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>, h.B) <span style=color:#ff79c6>||</span> <span style=color:#50fa7b>tooManyOverflowBuckets</span>(h.noverflow, h.B)) {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>hashGrow</span>(t, h)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>goto</span> again <span style=color:#6272a4>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> inserti <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// 当前bucket和所有的溢出桶都满了，创建新的溢出桶</span>
</span></span><span style=display:flex><span>        newb <span style=color:#ff79c6>:=</span> h.<span style=color:#50fa7b>newoverflow</span>(t, b)
</span></span><span style=display:flex><span>        inserti = <span style=color:#ff79c6>&amp;</span>newb.tophash[<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>        insertk = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(newb), dataOffset)
</span></span><span style=display:flex><span>        elem = <span style=color:#50fa7b>add</span>(insertk, bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// store new key/elem at insert position</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectkey</span>() {
</span></span><span style=display:flex><span>        kmem <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>newobject</span>(t.key)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span>unsafe.Pointer)(insertk) = kmem
</span></span><span style=display:flex><span>        insertk = kmem
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectelem</span>() {
</span></span><span style=display:flex><span>        vmem <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>newobject</span>(t.elem)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span>unsafe.Pointer)(elem) = vmem
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 写入key</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>typedmemmove</span>(t.key, insertk, key)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>*</span>inserti = top
</span></span><span style=display:flex><span>      <span style=color:#6272a4>// 哈希元素数量+1</span>
</span></span><span style=display:flex><span>    h.count<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>done:
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>hashWriting <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    h.flags <span style=color:#ff79c6>&amp;^=</span> hashWriting
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectelem</span>() {
</span></span><span style=display:flex><span>        elem = <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>*</span>unsafe.Pointer)(elem))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> elem
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>mapassign</code>中并没有对 val 进行直接赋值，而是返回了 val 的地址，真正的赋值操作在哪呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>var</span> a = <span style=color:#8be9fd;font-style:italic>make</span>(<span style=color:#8be9fd;font-style:italic>map</span>[<span style=color:#8be9fd>int</span>]<span style=color:#8be9fd>int</span>, <span style=color:#bd93f9>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>; i &lt; <span style=color:#bd93f9>1000</span>; i<span style=color:#ff79c6>++</span> {
</span></span><span style=display:flex><span>        a[i] = <span style=color:#bd93f9>99999</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>看看这段代码对应的汇编:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#bd93f9>0x003f</span> <span style=color:#bd93f9>00063</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    MOVQ    DX, (SP) <span style=color:#6272a4>// 第一个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x0043</span> <span style=color:#bd93f9>00067</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    MOVQ    AX, <span style=color:#bd93f9>8</span>(SP) <span style=color:#6272a4>// 第二个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x0048</span> <span style=color:#bd93f9>00072</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    MOVQ    CX, <span style=color:#bd93f9>16</span>(SP) <span style=color:#6272a4>// 第三个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x004d</span> <span style=color:#bd93f9>00077</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    PCDATA    $<span style=color:#bd93f9>0</span>, $<span style=color:#bd93f9>1</span> <span style=color:#6272a4>// GC 相关</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x004d</span> <span style=color:#bd93f9>00077</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    CALL    runtime.<span style=color:#50fa7b>mapassign_fast64</span>(SB) <span style=color:#6272a4>// 调用函数</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x0052</span> <span style=color:#bd93f9>000</span><span style=color:#bd93f9>82</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    MOVQ    <span style=color:#bd93f9>24</span>(SP), AX <span style=color:#6272a4>// 返回值，即 value 应该存放的内存地址</span>
</span></span><span style=display:flex><span>    <span style=color:#bd93f9>0x0057</span> <span style=color:#bd93f9>000</span><span style=color:#bd93f9>87</span> (m.<span style=color:#ff79c6>go</span>:<span style=color:#bd93f9>9</span>)    MOVQ    $<span style=color:#bd93f9>99999</span>, (AX) <span style=color:#6272a4>// 把 99999 放入该地址中</span>
</span></span></code></pre></div><h3 id=map-扩容>map 扩容<a hidden class=anchor aria-hidden=true href=#map-扩容>#</a></h3><p>在上文中的 map 写入操作过程中，有关于 map 扩容的代码，在这一部分细谈 map 扩容机制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !h.<span style=color:#50fa7b>growing</span>() <span style=color:#ff79c6>&amp;&amp;</span> (<span style=color:#50fa7b>overLoadFactor</span>(h.count<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>, h.B) <span style=color:#ff79c6>||</span> <span style=color:#50fa7b>tooManyOverflowBuckets</span>(h.noverflow, h.B)) {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>hashGrow</span>(t, h)
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>goto</span> again <span style=color:#6272a4>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>在写入时，有两种情况会触发扩容:</p><ul><li>负载因子超过上限，即元素个数 >= 桶个数 * 6.5，这时候说明大部分的桶可能都快满了，如果插入新元素，有大概率需要挂在 overflow 的桶上。</li><li>太多溢出桶，什么情况会导致太多溢出桶而又不超过负载因子上线呢？这可能发生在我们对 map 一边插入，一边删除，导致其中很多桶出现空洞，虽然使用了很多溢出桶，但是总元素个数并没有超出负载因子上限。这时 bucket 的使用率不高，值存储得比较稀疏，在查找时效率会下降，占据了大量内存却无用，等同于内存泄漏。</li></ul><p>满足任意情况且目前不在扩容状态<code>!h.growing()</code>时，即会进行扩容，map 扩容的函数就是<code>hashGrow(t, h)</code></p><p>针对上面两种不同情况，map 的扩容方法也是不一样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>hashGrow</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// If we&#39;ve hit the load factor, get bigger.</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// Otherwise, there are too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// so keep the same number of buckets and &#34;grow&#34; laterally.</span>
</span></span><span style=display:flex><span>    bigger <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uint8</span>(<span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 如果不是负载因子超出上限，那么进行的是一次等量扩容，bucket的数量不变</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !<span style=color:#50fa7b>overLoadFactor</span>(h.count<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>, h.B) {
</span></span><span style=display:flex><span>        bigger = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// sameSizeGrow，即为等量扩容</span>
</span></span><span style=display:flex><span>        h.flags <span style=color:#ff79c6>|=</span> sameSizeGrow
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    oldbuckets <span style=color:#ff79c6>:=</span> h.buckets
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 等量扩容bigger为0，bucket数不变。否则bigger为1，bucket数翻倍</span>
</span></span><span style=display:flex><span>    newbuckets, nextOverflow <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>makeBucketArray</span>(t, h.B<span style=color:#ff79c6>+</span>bigger, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flags <span style=color:#ff79c6>:=</span> h.flags <span style=color:#ff79c6>&amp;^</span> (iterator | oldIterator)
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>iterator <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>        flags <span style=color:#ff79c6>|=</span> oldIterator
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// commit the grow (atomic wrt gc)</span>
</span></span><span style=display:flex><span>    h.B <span style=color:#ff79c6>+=</span> bigger
</span></span><span style=display:flex><span>    h.flags = flags
</span></span><span style=display:flex><span>    h.oldbuckets = oldbuckets
</span></span><span style=display:flex><span>    h.buckets = newbuckets
</span></span><span style=display:flex><span>    h.nevacuate = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>    h.noverflow = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.extra <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> <span style=color:#ff79c6>&amp;&amp;</span> h.extra.overflow <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Promote current overflow buckets to the old generation.</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> h.extra.oldoverflow <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        h.extra.oldoverflow = h.extra.overflow
</span></span><span style=display:flex><span>        h.extra.overflow = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> nextOverflow <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> h.extra <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>            h.extra = <span style=color:#8be9fd;font-style:italic>new</span>(mapextra)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        h.extra.nextOverflow = nextOverflow
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// the actual copying of the hash table data is done incrementally</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// by growWork() and evacuate().</span>
</span></span><span style=display:flex><span>  <span style=color:#6272a4>// 哈希表数据的实际复制是由 growWork() 和 evacuate() 逐步完成的</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>growWork</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, bucket <span style=color:#8be9fd>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 确保我们移动的 oldbucket 对应的是我们马上就要用到的那一个</span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>evacuate</span>(t, h, bucket<span style=color:#ff79c6>&amp;</span>h.<span style=color:#50fa7b>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果还在 growing 状态，再多移动一个 oldbucket</span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> h.<span style=color:#50fa7b>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>evacuate</span>(t, h, h.nevacuate)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>重要的是真正的数据迁移部分，<code>evacuate</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>evacuate</span>(t <span style=color:#ff79c6>*</span>maptype, h <span style=color:#ff79c6>*</span>hmap, oldbucket <span style=color:#8be9fd>uintptr</span>) {
</span></span><span style=display:flex><span>    b <span style=color:#ff79c6>:=</span> (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(h.oldbuckets, oldbucket<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>    newbit <span style=color:#ff79c6>:=</span> h.<span style=color:#50fa7b>noldbuckets</span>()
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> !<span style=color:#50fa7b>evacuated</span>(b) {
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// TODO: reuse overflow buckets instead of using new ones, if there</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// is no iterator using the old buckets.  (If !oldIterator.)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// xy contains the x and y (low and high) evacuation destinations.</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// evacDst用于保存分配上下文</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// xy 包含的是移动的目标</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// x 表示新 bucket 数组的前(low)半部分</span>
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// y 表示新 bucket 数组的后(high)半部分</span>
</span></span><span style=display:flex><span>        <span style=color:#8be9fd;font-style:italic>var</span> xy [<span style=color:#bd93f9>2</span>]evacDst
</span></span><span style=display:flex><span>        x <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>xy[<span style=color:#bd93f9>0</span>]
</span></span><span style=display:flex><span>        x.b = (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(h.buckets, oldbucket<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>        x.k = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(x.b), dataOffset)
</span></span><span style=display:flex><span>        x.e = <span style=color:#50fa7b>add</span>(x.k, bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 如果是等量扩容，新旧bucket是一对一，不需要两个evacDst，而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> !h.<span style=color:#50fa7b>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Only calculate y pointers if we&#39;re growing bigger.</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Otherwise GC can see bad pointers.</span>
</span></span><span style=display:flex><span>            y <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>xy[<span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>            y.b = (<span style=color:#ff79c6>*</span>bmap)(<span style=color:#50fa7b>add</span>(h.buckets, (oldbucket<span style=color:#ff79c6>+</span>newbit)<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize)))
</span></span><span style=display:flex><span>            y.k = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(y.b), dataOffset)
</span></span><span style=display:flex><span>            y.e = <span style=color:#50fa7b>add</span>(y.k, bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>for</span> ; b <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span>; b = b.<span style=color:#50fa7b>overflow</span>(t) {
</span></span><span style=display:flex><span>            k <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(b), dataOffset)
</span></span><span style=display:flex><span>            e <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(k, bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>            <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>:=</span> <span style=color:#bd93f9>0</span>; i &lt; bucketCnt; i, k, e = i<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>, <span style=color:#50fa7b>add</span>(k, <span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize)), <span style=color:#50fa7b>add</span>(e, <span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize)) {
</span></span><span style=display:flex><span>                top <span style=color:#ff79c6>:=</span> b.tophash[i]
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> <span style=color:#50fa7b>isEmpty</span>(top) {
</span></span><span style=display:flex><span>                    b.tophash[i] = evacuatedEmpty
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> top &lt; minTopHash {
</span></span><span style=display:flex><span>                    <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;bad map state&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                k2 <span style=color:#ff79c6>:=</span> k
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectkey</span>() {
</span></span><span style=display:flex><span>                    k2 = <span style=color:#ff79c6>*</span>((<span style=color:#ff79c6>*</span>unsafe.Pointer)(k2))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#8be9fd;font-style:italic>var</span> useY <span style=color:#8be9fd>uint8</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> !h.<span style=color:#50fa7b>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// Compute hash to make our evacuation decision (whether we need</span>
</span></span><span style=display:flex><span>                    <span style=color:#6272a4>// to send this key/elem to bucket x or bucket y).</span>
</span></span><span style=display:flex><span>                    hash <span style=color:#ff79c6>:=</span> t.<span style=color:#50fa7b>hasher</span>(k2, <span style=color:#8be9fd;font-style:italic>uintptr</span>(h.hash0))
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>iterator <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> !t.<span style=color:#50fa7b>reflexivekey</span>() <span style=color:#ff79c6>&amp;&amp;</span> !t.key.<span style=color:#50fa7b>equal</span>(k2, k2) {
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// If key != key (NaNs), then the hash could be (and probably</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// will be) entirely different from the old hash. Moreover,</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// it isn&#39;t reproducible. Reproducibility is required in the</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// presence of iterators, as our evacuation decision must</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// match whatever decision the iterator made.</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// Fortunately, we have the freedom to send these keys either</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// way. Also, tophash is meaningless for these kinds of keys.</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// We let the low bit of tophash drive the evacuation decision.</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// We recompute a new random tophash for the next level so</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// these keys will get evenly distributed across all buckets</span>
</span></span><span style=display:flex><span>                        <span style=color:#6272a4>// after multiple grows.</span>
</span></span><span style=display:flex><span>                        useY = top <span style=color:#ff79c6>&amp;</span> <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>                        top = <span style=color:#50fa7b>tophash</span>(hash)
</span></span><span style=display:flex><span>                    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#ff79c6>if</span> hash<span style=color:#ff79c6>&amp;</span>newbit <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>                            useY = <span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> evacuatedX<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span> <span style=color:#ff79c6>!=</span> evacuatedY <span style=color:#ff79c6>||</span> evacuatedX^<span style=color:#bd93f9>1</span> <span style=color:#ff79c6>!=</span> evacuatedY {
</span></span><span style=display:flex><span>                    <span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;bad evacuatedN&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                b.tophash[i] = evacuatedX <span style=color:#ff79c6>+</span> useY <span style=color:#6272a4>// evacuatedX + 1 == evacuatedY</span>
</span></span><span style=display:flex><span>                dst <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&amp;</span>xy[useY]                 <span style=color:#6272a4>// evacuation destination</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> dst.i <span style=color:#ff79c6>==</span> bucketCnt {
</span></span><span style=display:flex><span>                    dst.b = h.<span style=color:#50fa7b>newoverflow</span>(t, dst.b)
</span></span><span style=display:flex><span>                    dst.i = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>                    dst.k = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(dst.b), dataOffset)
</span></span><span style=display:flex><span>                    dst.e = <span style=color:#50fa7b>add</span>(dst.k, bucketCnt<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                dst.b.tophash[dst.i<span style=color:#ff79c6>&amp;</span>(bucketCnt<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>)] = top <span style=color:#6272a4>// mask dst.i as an optimization, to avoid a bounds check</span>
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span>unsafe.Pointer)(dst.k) = k2 <span style=color:#6272a4>// copy pointer</span>
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#50fa7b>typedmemmove</span>(t.key, dst.k, k) <span style=color:#6272a4>// copy elem</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#ff79c6>if</span> t.<span style=color:#50fa7b>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span>unsafe.Pointer)(dst.e) = <span style=color:#ff79c6>*</span>(<span style=color:#ff79c6>*</span>unsafe.Pointer)(e)
</span></span><span style=display:flex><span>                } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#50fa7b>typedmemmove</span>(t.elem, dst.e, e)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                dst.i<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// These updates might push these pointers past the end of the</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// key or elem arrays.  That&#39;s ok, as we have the overflow pointer</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// at the end of the bucket to protect against pointing past the</span>
</span></span><span style=display:flex><span>                <span style=color:#6272a4>// end of the bucket.</span>
</span></span><span style=display:flex><span>                dst.k = <span style=color:#50fa7b>add</span>(dst.k, <span style=color:#8be9fd;font-style:italic>uintptr</span>(t.keysize))
</span></span><span style=display:flex><span>                dst.e = <span style=color:#50fa7b>add</span>(dst.e, <span style=color:#8be9fd;font-style:italic>uintptr</span>(t.elemsize))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#6272a4>// Unlink the overflow buckets &amp; clear key/elem to help GC.</span>
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span> h.flags<span style=color:#ff79c6>&amp;</span>oldIterator <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> t.bucket.ptrdata <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>            b <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(h.oldbuckets, oldbucket<span style=color:#ff79c6>*</span><span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize))
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// Preserve b.tophash because the evacuation</span>
</span></span><span style=display:flex><span>            <span style=color:#6272a4>// state is maintained there.</span>
</span></span><span style=display:flex><span>            ptr <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>add</span>(b, dataOffset)
</span></span><span style=display:flex><span>            n <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>uintptr</span>(t.bucketsize) <span style=color:#ff79c6>-</span> dataOffset
</span></span><span style=display:flex><span>            <span style=color:#50fa7b>memclrHasPointers</span>(ptr, n)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span> oldbucket <span style=color:#ff79c6>==</span> h.nevacuate {
</span></span><span style=display:flex><span>        <span style=color:#50fa7b>advanceEvacuationMark</span>(h, t, newbit)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>Golang</a></li><li><a href=https://www.yici.xin/tags/map/>Map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>Hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>源码解析</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/><span class=title>« 上一页</span><br><span>Golang——plan9汇编</span>
</a><a class=next href=https://www.yici.xin/post/tech/keynote%E4%B8%AD%E8%B4%B4%E4%BB%A3%E7%A0%81/><span class=title>下一页 »</span><br><span>如何在Keynote中贴出好看的代码</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>绝知</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
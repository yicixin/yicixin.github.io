<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang-map的操作 | 握月担风</title>
<meta name=keywords content="golang,map,hashmap,源码解析"><meta name=description content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.278e8b2dd0edae6a4a4d865210e46385ee100556bcf14ba56506e7501326056e.css integrity="sha256-J46LLdDtrmpKTYZSEORjhe4QBVa88UulZQbnUBMmBW4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="Golang-map的操作"><meta property="og:description" content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:49:41+08:00"><meta property="article:modified_time" content="2022-12-30T10:49:41+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang-map的操作"><meta name=twitter:description content="创建 map
创建 map 的语法很简单
// 不指定map长度
ageMp := make(map[string]int)
// 指定map长度
ageMp := make(map[string]int, 8)
// ageMp 为 nil，不能向其添加元素，会直接panic
var ageMp map[string]int
通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
// 如果h不是nil，那么该map能直接创建在这个h上。
// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // 初始化hmap，并指定随机种子
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // 溢出桶地址赋值
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// 翻译：makeBucketArray为map buckets初始化一个备用数组
// 2^b是该buckets长度的最小值
// dirtyalloc之前应该是nil或者bucket数组
// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
    // 对于b>4（桶的数量> 2^4）的话，则需要创建2^(b-4)个溢出桶。
    if b >= 4 {
        // 加上溢出桶的数量
        nbuckets += bucketShift(b - 4)
    // 总大小
        sz := t.bucket.size * nbuckets
    // 针对所需要的内存大小，mallocgc将分配的内存块大小
        up := roundupsize(sz)
        if up != sz {
      // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
        // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
        // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
        // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶
        last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
    }
    return buckets, nextOverflow
}
从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang-map的操作","item":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang-map的操作","name":"Golang-map的操作","description":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。 // 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。 // 如果h不是nil，那么该map能直接创建在这个h上。 // 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket func makemap(t *maptype, hint int, h *hmap) *hmap { // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小 mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // 初始化hmap，并指定随机种子 if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B \u0026lt; hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现 if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // 溢出桶地址赋值 h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u0026lt;\u0026lt;b is the minimum number of buckets to allocate. // dirtyalloc should either be nil or a bucket array previously // allocated by makeBucketArray with the same t and b parameters. // If dirtyalloc is nil a new backing array will be alloced and // otherwise dirtyalloc will be cleared and reused as backing array. // 翻译：makeBucketArray为map buckets初始化一个备用数组 // 2^b是该buckets长度的最小值 // dirtyalloc之前应该是nil或者bucket数组 // 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。 func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { base := bucketShift(b) // base = 2^b nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. // 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销 // 对于b\u0026gt;4（桶的数量\u0026gt; 2^4）的话，则需要创建2^(b-4)个溢出桶。 if b \u0026gt;= 4 { // 加上溢出桶的数量 nbuckets += bucketShift(b - 4) // 总大小 sz := t.bucket.size * nbuckets // 针对所需要的内存大小，mallocgc将分配的内存块大小 up := roundupsize(sz) if up != sz { // 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets nbuckets = up / t.bucket.size } } if dirtyalloc == nil { buckets = newarray(t.bucket, int(nbuckets)) } else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.ptrdata != 0 { memclrHasPointers(buckets, size) } else { memclrNoHeapPointers(buckets, size) } } if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket\u0026#39;s overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. // 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定: // 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用， // 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶 // 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中 nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // 指向第一个溢出桶 last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // 指向最后一个溢出桶 last.setoverflow(t, (*bmap)(buckets)) // 溢出桶的最后一个桶的overflow指向了buckets的第一个桶 } return buckets, nextOverflow } 从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。\n","keywords":["golang","map","hashmap","源码解析"],"articleBody":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。 // 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。 // 如果h不是nil，那么该map能直接创建在这个h上。 // 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket func makemap(t *maptype, hint int, h *hmap) *hmap { // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小 mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // 初始化hmap，并指定随机种子 if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B \u003c hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现 if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // 溢出桶地址赋值 h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u003c","wordCount":"2376","inLanguage":"zh","datePublished":"2022-12-30T10:49:41+08:00","dateModified":"2022-12-30T10:49:41+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"握月担风","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="握月担风 (Alt + H)">握月担风</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Golang-map的操作</h1><div class=post-meta><span title='2022-12-30 10:49:41 +0800 +0800'>2022-12-30</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%88%9b%e5%bb%ba-map aria-label="创建 map">创建 map</a></li><li><a href=#map-%e7%9a%84%e8%af%bb%e5%8f%96 aria-label="map 的读取">map 的读取</a></li><li><a href=#map-%e5%86%99%e5%85%a5 aria-label="map 写入">map 写入</a></li><li><a href=#map-%e6%89%a9%e5%ae%b9 aria-label="map 扩容">map 扩容</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=创建-map>创建 map<a hidden class=anchor aria-hidden=true href=#创建-map>#</a></h3><p>创建 map 的语法很简单</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// 不指定map长度</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ageMp</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// 指定map长度</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ageMp</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>, <span style=color:#d19a66>8</span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// ageMp 为 nil，不能向其添加元素，会直接panic</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>var</span> <span style=color:#e06c75>ageMp</span> <span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>
</span></span></code></pre></div><p>通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// makemap implements Go map creation for make(map[k]v, hint).</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If the compiler has determined that the map or the first bucket</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// can be created on the stack, h and/or bucket may be non-nil.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If h != nil, the map can be created directly in h.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 如果h不是nil，那么该map能直接创建在这个h上。</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>makemap</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>hint</span> <span style=color:#e5c07b>int</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span> {
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>mem</span>, <span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>math</span>.<span style=color:#61afef;font-weight:700>MulUintptr</span>(<span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>hint</span>), <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>mem</span> &gt; <span style=color:#e06c75>maxAlloc</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>hint</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 初始化hmap，并指定随机种子</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>hmap</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span> = <span style=color:#61afef;font-weight:700>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Find the size parameter B which will hold the requested # of elements.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B &lt; hint</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>B</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#d19a66>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> <span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>hint</span>, <span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>B</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> = <span style=color:#e06c75>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// allocate initial hash table</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// if B == 0, the buckets field is allocated lazily later (in mapassign)</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If hint is large zeroing this memory could take a while.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>var</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>nextOverflow</span> = <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>, <span style=color:#e5c07b>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>mapextra</span>)
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 溢出桶地址赋值</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>nextOverflow</span> = <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// makeBucketArray initializes a backing array for map buckets.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 1&lt;&lt;b is the minimum number of buckets to allocate.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// dirtyalloc should either be nil or a bucket array previously</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// allocated by makeBucketArray with the same t and b parameters.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If dirtyalloc is nil a new backing array will be alloced and</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// otherwise dirtyalloc will be cleared and reused as backing array.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 翻译：makeBucketArray为map buckets初始化一个备用数组</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 2^b是该buckets长度的最小值</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// dirtyalloc之前应该是nil或者bucket数组</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>b</span> <span style=color:#e5c07b>uint8</span>, <span style=color:#e06c75>dirtyalloc</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) (<span style=color:#e06c75>buckets</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>, <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>base</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>bucketShift</span>(<span style=color:#e06c75>b</span>) <span style=color:#7f848e>// base = 2^b</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>nbuckets</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>base</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// For small b, overflow buckets are unlikely.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Avoid the overhead of the calculation.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 对于b&gt;4（桶的数量&gt; 2^4）的话，则需要创建2^(b-4)个溢出桶。</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span> <span style=color:#56b6c2>&gt;=</span> <span style=color:#d19a66>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 加上溢出桶的数量</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>nbuckets</span> <span style=color:#56b6c2>+=</span> <span style=color:#61afef;font-weight:700>bucketShift</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 总大小</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>sz</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>nbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 针对所需要的内存大小，mallocgc将分配的内存块大小</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>up</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>roundupsize</span>(<span style=color:#e06c75>sz</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>up</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>sz</span> {
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>nbuckets</span> = <span style=color:#e06c75>up</span> <span style=color:#56b6c2>/</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>dirtyalloc</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>buckets</span> = <span style=color:#61afef;font-weight:700>newarray</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>, <span style=color:#e5c07b>int</span>(<span style=color:#e06c75>nbuckets</span>))
</span></span><span style=display:flex><span>    } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// dirtyalloc was previously generated by</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// the above newarray(t.bucket, int(nbuckets))</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// but may not be empty.</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>buckets</span> = <span style=color:#e06c75>dirtyalloc</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>size</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>nbuckets</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>ptrdata</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrHasPointers</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>        } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrNoHeapPointers</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>base</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>nbuckets</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// We preallocated some overflow buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// To keep the overhead of tracking these overflow buckets to a minimum,</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// we use the convention that if a preallocated overflow bucket&#39;s overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// pointer is nil, then there are more available by bumping the pointer.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>nextOverflow</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>base</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))) <span style=color:#7f848e>// 指向第一个溢出桶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>last</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>nbuckets</span><span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))) <span style=color:#7f848e>// 指向最后一个溢出桶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>last</span>.<span style=color:#61afef;font-weight:700>setoverflow</span>(<span style=color:#e06c75>t</span>, (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#e06c75>buckets</span>)) <span style=color:#7f848e>// 溢出桶的最后一个桶的overflow指向了buckets的第一个桶</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202201182254581.jpeg alt=手绘图></p><h3 id=map-的读取>map 的读取<a hidden class=anchor aria-hidden=true href=#map-的读取>#</a></h3><p>对于 map 的读取操作，最终是调用了函数 <code>runtime.mapaccess1()</code>和 <code>runtime.mapaccess2()</code> 。两者的唯一区别就是返回值不一样，<code>runtime.mapaccess1()</code> 返回的是一个值，<code>runtime.mapaccess2()</code> 返回的是两个值，第二个值表示 key 是否在 map 中存在。即我们常用的两种 map 取值方法。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>v</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ageMap</span>[<span style=color:#98c379>&#34;yicixin&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#e06c75>v</span>, <span style=color:#e06c75>ok</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ageMap</span>[<span style=color:#98c379>&#34;yicixin&#34;</span>]
</span></span></code></pre></div><p>所以我们只需要介绍<code>runtime.mapaccess1()</code>,</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// it will return a reference to the zero object for the elem type if</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// the key is not in the map.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// NOTE: The returned pointer may keep the whole map live, so don&#39;t</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// hold onto it for very long.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// mapaccess1返回指向h[key]的指针，永远不会返回nil，如果key不存在，就会返回元素对应类型的空值。</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 注意：返回的指针可能会使得整个map处于活动状态，所以不要长时间持有它</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>mapaccess1</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>raceenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>callerpc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#e06c75>pc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>funcPC</span>(<span style=color:#e06c75>mapaccess1</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>racereadpc</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>h</span>), <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>raceReadObjectPC</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>key</span>, <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>msanenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>msanread</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 判断h是否为nil或者h.count值是否为0，如果h为nil则表示未初始化，则可能panic，如果h.count=0,则表示map为空，则直接返回一个zero值。</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hashMightPanic</span>() {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#d19a66>0</span>) <span style=color:#7f848e>// see issue 23734</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>zeroVal</span>[<span style=color:#d19a66>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 考虑是否处于并发读写状态，否则产生panic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map read and map write&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 根据键key计算hash值</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 计算低B位的掩码bucketMask(h.B)，比如 B=5，那 m 就是31，低五位二进制是全1</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>m</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>bucketMask</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 计算当前bucket的地址</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>m</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 根据h.oldbuckets判断是否处于扩容中，如果不是nil则表示当前map正处于扩容状态中</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>c</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>; <span style=color:#e06c75>c</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// There used to be half as many buckets; mask down one more power of two.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>m</span> <span style=color:#56b6c2>&gt;&gt;=</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>oldb</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>c</span>, (<span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>m</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>evacuated</span>(<span style=color:#e06c75>oldb</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>b</span> = <span style=color:#e06c75>oldb</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 计算tophash，即高八位</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 真正开始查找key,外层for是循环bucket及溢出桶overflow，内层for是循环桶内的8个slot</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> ; <span style=color:#e06c75>b</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span>; <span style=color:#e06c75>b</span> = <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>) {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#d19a66>0</span>); <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>==</span> <span style=color:#e06c75>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>break</span> <span style=color:#e06c75>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>e</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>e</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>return</span> <span style=color:#e06c75>e</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>zeroVal</span>[<span style=color:#d19a66>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>key 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span></code></pre></div><p>value 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span></code></pre></div><p>其中 dataOffset 表示 第一个 key 相对于 bmap 的偏移量，结构体如下</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>dataOffset</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Offsetof</span>(<span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>b</span> <span style=color:#e06c75>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>v</span> <span style=color:#e5c07b>int64</span>
</span></span><span style=display:flex><span>    }{}.<span style=color:#e06c75>v</span>)
</span></span></code></pre></div><p>所以键的地址=当前 bucket 的起始位置(<code>unsafe.Pointer(b)</code>) + 第一个 key 的偏移量(<code>dataOffset</code>)+当前 slot 索引值(<code>i</code>) * 每个键的大小(<code>uintptr(t.keysize)</code>)</p><p>而对于值来说，由于 bmap.values 在 b.map.keys 后面，所以要先将 8 个键的地址全部计算上才行，同样值类型也有自己的大小 <code>t.elemsize</code></p><p>bucket 的几种状态码</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#e06c75>emptyRest</span>      = <span style=color:#d19a66>0</span> <span style=color:#7f848e>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>emptyOne</span>       = <span style=color:#d19a66>1</span> <span style=color:#7f848e>// 当前cell为空</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedX</span>     = <span style=color:#d19a66>2</span> <span style=color:#7f848e>// key/elem is valid.  Entry has been evacuated to first half of larger table.</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedY</span>     = <span style=color:#d19a66>3</span> <span style=color:#7f848e>// 扩容相关，第二部分迁移完毕。</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedEmpty</span> = <span style=color:#d19a66>4</span> <span style=color:#7f848e>// 当前cell为空，且迁移完成。</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>minTopHash</span>     = <span style=color:#d19a66>5</span> <span style=color:#7f848e>// tophash最小值，如果在调用 tophash(hash)时，计算出的值小于此值，则会加上此值</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// tophash calculates the tophash value for hash.</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span> <span style=color:#e5c07b>uintptr</span>) <span style=color:#e5c07b>uint8</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#e06c75>hash</span> <span style=color:#56b6c2>&gt;&gt;</span> (<span style=color:#e06c75>sys</span>.<span style=color:#e06c75>PtrSize</span><span style=color:#56b6c2>*</span><span style=color:#d19a66>8</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>8</span>))
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>top</span> &lt; <span style=color:#e06c75>minTopHash</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>top</span> <span style=color:#56b6c2>+=</span> <span style=color:#e06c75>minTopHash</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#e06c75>top</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=map-写入>map 写入<a hidden class=anchor aria-hidden=true href=#map-写入>#</a></h3><p>与 map 写入相关的 runtime 函数是<code>runtime.mapassign()</code>，对于某些 key 类型，runtime 还有特定的函数。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_faststr</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_fast64</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e5c07b>uint64</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_fast32</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e5c07b>uint32</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span></code></pre></div><p>这是<code>runtime.mapassign</code>函数：</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>mapassign</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 空map写入会触发panic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e5c07b>panic</span>(<span style=color:#61afef;font-weight:700>plainError</span>(<span style=color:#98c379>&#34;assignment to entry in nil map&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// raceenabled-是否启用数据竞争检测</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>callerpc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#e06c75>pc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>funcPC</span>(<span style=color:#e06c75>mapassign</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>racewritepc</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>h</span>), <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>raceReadObjectPC</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>key</span>, <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>msanenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>msanread</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 如果并发写入会触发panic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 计算hash值</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Set hashWriting after calling t.hasher, since t.hasher may panic,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// in which case we have not actually done a write.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 设置写入标志位</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> ^= <span style=color:#e06c75>hashWriting</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> = <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>) <span style=color:#7f848e>// newarray(t.bucket, 1)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>again</span>:
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 定位bucket</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>bucket</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>&amp;</span> <span style=color:#61afef;font-weight:700>bucketMask</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>growWork</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>bucket</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>bucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>uint8</span> <span style=color:#7f848e>// tophash的位置</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>insertk</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> <span style=color:#7f848e>// key的地址</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>elem</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> <span style=color:#7f848e>// val的地址</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#d19a66>0</span>); <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#61afef;font-weight:700>isEmpty</span>(<span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]) <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>inserti</span> = <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>insertk</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow, 可以退出循环了</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>==</span> <span style=color:#e06c75>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>break</span> <span style=color:#e06c75>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>              <span style=color:#7f848e>// b.tophash[i] == top</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> !<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// already have a mapping for key. Update it.</span>
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>needkeyupdate</span>() {
</span></span><span style=display:flex><span>                <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>, <span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>goto</span> <span style=color:#e06c75>done</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 如果还有溢出桶，继续查询溢出桶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>ovf</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>ovf</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>b</span> = <span style=color:#e06c75>ovf</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Did not find mapping for key. Allocate new cell &amp; add entry.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If we hit the max load factor or we have too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// and we&#39;re not already in the middle of growing, start growing.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 如果负载因子到了最大或者有太多的溢出桶，并且不在扩容中，开始扩容</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() <span style=color:#56b6c2>&amp;&amp;</span> (<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) <span style=color:#56b6c2>||</span> <span style=color:#61afef;font-weight:700>tooManyOverflowBuckets</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>goto</span> <span style=color:#e06c75>again</span> <span style=color:#7f848e>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// 当前bucket和所有的溢出桶都满了，创建新的溢出桶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>newb</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>newoverflow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>inserti</span> = <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>newb</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#d19a66>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#e06c75>insertk</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>newb</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>insertk</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// store new key/elem at insert position</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>kmem</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>insertk</span>) = <span style=color:#e06c75>kmem</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>insertk</span> = <span style=color:#e06c75>kmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>vmem</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elem</span>)
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>elem</span>) = <span style=color:#e06c75>vmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 写入key</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>insertk</span>, <span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>*</span><span style=color:#e06c75>inserti</span> = <span style=color:#e06c75>top</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// 哈希元素数量+1</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>done</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>&amp;^=</span> <span style=color:#e06c75>hashWriting</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>elem</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>elem</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>elem</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>mapassign</code>中并没有对 val 进行直接赋值，而是返回了 val 的地址，真正的赋值操作在哪呢？</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>a</span> = <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>int</span>]<span style=color:#e5c07b>int</span>, <span style=color:#d19a66>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#d19a66>1000</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>a</span>[<span style=color:#e06c75>i</span>] = <span style=color:#d19a66>99999</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>看看这段代码对应的汇编:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#d19a66>0x003f</span> <span style=color:#d19a66>00063</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>DX</span>, (<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// 第一个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0043</span> <span style=color:#d19a66>00067</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>AX</span>, <span style=color:#d19a66>8</span>(<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// 第二个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0048</span> <span style=color:#d19a66>00072</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>CX</span>, <span style=color:#d19a66>16</span>(<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// 第三个参数</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x004d</span> <span style=color:#d19a66>00077</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>PCDATA</span>    $<span style=color:#d19a66>0</span>, $<span style=color:#d19a66>1</span> <span style=color:#7f848e>// GC 相关</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x004d</span> <span style=color:#d19a66>00077</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>CALL</span>    <span style=color:#e06c75>runtime</span>.<span style=color:#61afef;font-weight:700>mapassign_fast64</span>(<span style=color:#e06c75>SB</span>) <span style=color:#7f848e>// 调用函数</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0052</span> <span style=color:#d19a66>000</span><span style=color:#d19a66>82</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#d19a66>24</span>(<span style=color:#e06c75>SP</span>), <span style=color:#e06c75>AX</span> <span style=color:#7f848e>// 返回值，即 value 应该存放的内存地址</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0057</span> <span style=color:#d19a66>000</span><span style=color:#d19a66>87</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    $<span style=color:#d19a66>99999</span>, (<span style=color:#e06c75>AX</span>) <span style=color:#7f848e>// 把 99999 放入该地址中</span>
</span></span></code></pre></div><h3 id=map-扩容>map 扩容<a hidden class=anchor aria-hidden=true href=#map-扩容>#</a></h3><p>在上文中的 map 写入操作过程中，有关于 map 扩容的代码，在这一部分细谈 map 扩容机制</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() <span style=color:#56b6c2>&amp;&amp;</span> (<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) <span style=color:#56b6c2>||</span> <span style=color:#61afef;font-weight:700>tooManyOverflowBuckets</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>goto</span> <span style=color:#e06c75>again</span> <span style=color:#7f848e>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>在写入时，有两种情况会触发扩容:</p><ul><li>负载因子超过上限，即元素个数 >= 桶个数 * 6.5，这时候说明大部分的桶可能都快满了，如果插入新元素，有大概率需要挂在 overflow 的桶上。</li><li>太多溢出桶，什么情况会导致太多溢出桶而又不超过负载因子上线呢？这可能发生在我们对 map 一边插入，一边删除，导致其中很多桶出现空洞，虽然使用了很多溢出桶，但是总元素个数并没有超出负载因子上限。这时 bucket 的使用率不高，值存储得比较稀疏，在查找时效率会下降，占据了大量内存却无用，等同于内存泄漏。</li></ul><p>满足任意情况且目前不在扩容状态<code>!h.growing()</code>时，即会进行扩容，map 扩容的函数就是<code>hashGrow(t, h)</code></p><p>针对上面两种不同情况，map 的扩容方法也是不一样的。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If we&#39;ve hit the load factor, get bigger.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Otherwise, there are too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// so keep the same number of buckets and &#34;grow&#34; laterally.</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>bigger</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#d19a66>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// 如果不是负载因子超出上限，那么进行的是一次等量扩容，bucket的数量不变</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>bigger</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// sameSizeGrow，即为等量扩容</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>|=</span> <span style=color:#e06c75>sameSizeGrow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>oldbuckets</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// 等量扩容bigger为0，bucket数不变。否则bigger为1，bucket数翻倍</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>newbuckets</span>, <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bigger</span>, <span style=color:#e5c07b>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>flags</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>&amp;^</span> (<span style=color:#e06c75>iterator</span> | <span style=color:#e06c75>oldIterator</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iterator</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>flags</span> <span style=color:#56b6c2>|=</span> <span style=color:#e06c75>oldIterator</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// commit the grow (atomic wrt gc)</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> <span style=color:#56b6c2>+=</span> <span style=color:#e06c75>bigger</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> = <span style=color:#e06c75>flags</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span> = <span style=color:#e06c75>oldbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> = <span style=color:#e06c75>newbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// Promote current overflow buckets to the old generation.</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>oldoverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>oldoverflow</span> = <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span> = <span style=color:#e5c07b>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>mapextra</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>nextOverflow</span> = <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// the actual copying of the hash table data is done incrementally</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// by growWork() and evacuate().</span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// 哈希表数据的实际复制是由 growWork() 和 evacuate() 逐步完成的</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>growWork</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>bucket</span> <span style=color:#e5c07b>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 确保我们移动的 oldbucket 对应的是我们马上就要用到的那一个</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>bucket</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果还在 growing 状态，再多移动一个 oldbucket</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>重要的是真正的数据迁移部分，<code>evacuate</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>oldbucket</span> <span style=color:#e5c07b>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#e06c75>newbit</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>noldbuckets</span>()
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>evacuated</span>(<span style=color:#e06c75>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// TODO: reuse overflow buckets instead of using new ones, if there</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// is no iterator using the old buckets.  (If !oldIterator.)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// xy contains the x and y (low and high) evacuation destinations.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// evacDst用于保存分配上下文</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// xy 包含的是移动的目标</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// x 表示新 bucket 数组的前(low)半部分</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// y 表示新 bucket 数组的后(high)半部分</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>var</span> <span style=color:#e06c75>xy</span> [<span style=color:#d19a66>2</span>]<span style=color:#e06c75>evacDst</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#d19a66>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>b</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>x</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>x</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// 如果是等量扩容，新旧bucket是一对一，不需要两个evacDst，而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Only calculate y pointers if we&#39;re growing bigger.</span>
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Otherwise GC can see bad pointers.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#d19a66>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>b</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>newbit</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>y</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>y</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> ; <span style=color:#e06c75>b</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span>; <span style=color:#e06c75>b</span> = <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span>, <span style=color:#e06c75>k</span>, <span style=color:#e06c75>e</span> = <span style=color:#e06c75>i</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>k</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)), <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>e</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#61afef;font-weight:700>isEmpty</span>(<span style=color:#e06c75>top</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] = <span style=color:#e06c75>evacuatedEmpty</span>
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>top</span> &lt; <span style=color:#e06c75>minTopHash</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;bad map state&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k2</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>k</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>k2</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k2</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>var</span> <span style=color:#e06c75>useY</span> <span style=color:#e5c07b>uint8</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#7f848e>// Compute hash to make our evacuation decision (whether we need</span>
</span></span><span style=display:flex><span>                    <span style=color:#7f848e>// to send this key/elem to bucket x or bucket y).</span>
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>k2</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iterator</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> <span style=color:#56b6c2>&amp;&amp;</span> !<span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>reflexivekey</span>() <span style=color:#56b6c2>&amp;&amp;</span> !<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>k2</span>, <span style=color:#e06c75>k2</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// If key != key (NaNs), then the hash could be (and probably</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// will be) entirely different from the old hash. Moreover,</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// it isn&#39;t reproducible. Reproducibility is required in the</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// presence of iterators, as our evacuation decision must</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// match whatever decision the iterator made.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// Fortunately, we have the freedom to send these keys either</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// way. Also, tophash is meaningless for these kinds of keys.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// We let the low bit of tophash drive the evacuation decision.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// We recompute a new random tophash for the next level so</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// these keys will get evenly distributed across all buckets</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// after multiple grows.</span>
</span></span><span style=display:flex><span>                        <span style=color:#e06c75>useY</span> = <span style=color:#e06c75>top</span> <span style=color:#56b6c2>&amp;</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#e06c75>top</span> = <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#c678dd>if</span> <span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>newbit</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#e06c75>useY</span> = <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>evacuatedX</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>evacuatedY</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>evacuatedX</span>^<span style=color:#d19a66>1</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>evacuatedY</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;bad evacuatedN&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] = <span style=color:#e06c75>evacuatedX</span> <span style=color:#56b6c2>+</span> <span style=color:#e06c75>useY</span> <span style=color:#7f848e>// evacuatedX + 1 == evacuatedY</span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#e06c75>useY</span>]                 <span style=color:#7f848e>// evacuation destination</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span> <span style=color:#56b6c2>==</span> <span style=color:#e06c75>bucketCnt</span> {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span> = <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>newoverflow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span><span style=color:#56b6c2>&amp;</span>(<span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span>)] = <span style=color:#e06c75>top</span> <span style=color:#7f848e>// mask dst.i as an optimization, to avoid a bounds check</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>) = <span style=color:#e06c75>k2</span> <span style=color:#7f848e>// copy pointer</span>
</span></span><span style=display:flex><span>                } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>k</span>) <span style=color:#7f848e>// copy elem</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>) = <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>e</span>)
</span></span><span style=display:flex><span>                } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elem</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>, <span style=color:#e06c75>e</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// These updates might push these pointers past the end of the</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// key or elem arrays.  That&#39;s ok, as we have the overflow pointer</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// at the end of the bucket to protect against pointing past the</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// end of the bucket.</span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// Unlink the overflow buckets &amp; clear key/elem to help GC.</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>oldIterator</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>ptrdata</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Preserve b.tophash because the evacuation</span>
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// state is maintained there.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>b</span>, <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>n</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>) <span style=color:#56b6c2>-</span> <span style=color:#e06c75>dataOffset</span>
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrHasPointers</span>(<span style=color:#e06c75>ptr</span>, <span style=color:#e06c75>n</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>oldbucket</span> <span style=color:#56b6c2>==</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>advanceEvacuationMark</span>(<span style=color:#e06c75>h</span>, <span style=color:#e06c75>t</span>, <span style=color:#e06c75>newbit</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>Golang</a></li><li><a href=https://www.yici.xin/tags/map/>Map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>Hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>源码解析</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><span class=title>« 上一页</span><br><span>转换bytes和string的最佳实践</span>
</a><a class=next href=https://www.yici.xin/post/tech/keynote%E4%B8%AD%E8%B4%B4%E4%BB%A3%E7%A0%81/><span class=title>下一页 »</span><br><span>如何在Keynote中贴出好看的代码</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>握月担风</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
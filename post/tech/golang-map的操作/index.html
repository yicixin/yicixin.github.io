<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang-map的操作 | yicixin's blog</title><meta name=keywords content="golang,map,hashmap,源码解析"><meta name=description content="创建 map 创建 map 的语法很简单
// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang-map的操作"><meta property="og:description" content="创建 map 创建 map 的语法很简单
// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:49:41+08:00"><meta property="article:modified_time" content="2022-12-30T10:49:41+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang-map的操作"><meta name=twitter:description content="创建 map 创建 map 的语法很简单
// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang-map的操作","item":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang-map的操作","name":"Golang-map的操作","description":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h.","keywords":["golang","map","hashmap","源码解析"],"articleBody":"创建 map 创建 map 的语法很简单\n// 不指定map长度 ageMp := make(map[string]int) // 指定map长度 ageMp := make(map[string]int, 8) // ageMp 为 nil，不能向其添加元素，会直接panic var ageMp map[string]int 通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。 // 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。 // 如果h不是nil，那么该map能直接创建在这个h上。 // 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket func makemap(t *maptype, hint int, h *hmap) *hmap { // 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小 mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // 初始化hmap，并指定随机种子 if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. // 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B \u003c hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现 if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // 溢出桶地址赋值 h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u003c","wordCount":"2376","inLanguage":"zh","datePublished":"2022-12-30T10:49:41+08:00","dateModified":"2022-12-30T10:49:41+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="Yicixin's blog (Alt + H)">Yicixin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li><li><a href=https://www.yici.xin/archives/ title=归档🕰️><span>归档🕰️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Golang-map的操作</h1><div class=post-meta><span title='2022-12-30 10:49:41 +0800 +0800'>2022-12-30</span>&nbsp;·&nbsp;12 分钟&nbsp;·&nbsp;2376 字&nbsp;·&nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/tech/golang-map%e7%9a%84%e6%93%8d%e4%bd%9c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%88%9b%e5%bb%ba-map aria-label="创建 map">创建 map</a></li><li><a href=#map-%e7%9a%84%e8%af%bb%e5%8f%96 aria-label="map 的读取">map 的读取</a></li><li><a href=#map-%e5%86%99%e5%85%a5 aria-label="map 写入">map 写入</a></li><li><a href=#map-%e6%89%a9%e5%ae%b9 aria-label="map 扩容">map 扩容</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=创建-map>创建 map<a hidden class=anchor aria-hidden=true href=#创建-map>#</a></h3><p>创建 map 的语法很简单</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 不指定map长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ageMp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// 指定map长度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ageMp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// ageMp 为 nil，不能向其添加元素，会直接panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ageMp</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>通过汇编语言，我们能够跟踪到 map 的创建最终会调用 runtime.makemap 方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// makemap implements Go map creation for make(map[k]v, hint).
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If the compiler has determined that the map or the first bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e>// can be created on the stack, h and/or bucket may be non-nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If h != nil, the map can be created directly in h.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If h.buckets != nil, bucket pointed to can be used as the first bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 翻译：makemap实现了make(map[k]v, hint)这种形式语法的Go map创建。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果编译器已经确定该map或者第一个bucket能够在这个栈上创建，那么h和(或)bucket可能为非nil。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果h不是nil，那么该map能直接创建在这个h上。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果h.buckets不是nil, 则被指向的bucket能被用来做第一个bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 计算指定的大小所需要的内容是否超出出系统允许的最大分配大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(uintptr(<span style=color:#a6e22e>hint</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hint</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 初始化hmap，并指定随机种子
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span> = new(<span style=color:#a6e22e>hmap</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span> = <span style=color:#a6e22e>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the size parameter B which will hold the requested # of elements.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 通过overLoadFactor(hint, B)函数找到一个能装下指定map大小个元素个数的最小B，要满足 装载因子*2^B &lt; hint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>B</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>hint</span>, <span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>B</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// allocate initial hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If hint is large zeroing this memory could take a while.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 开始对hash table进行初始化。如果B==0则buckets 进行懒初始化操作（赋值的时候才进行初始化），如果B值特别大，则初始化需要一段时间，主要通过 makeBucketArray() 函数实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 溢出桶地址赋值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// makeBucketArray initializes a backing array for map buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 1&lt;&lt;b is the minimum number of buckets to allocate.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// dirtyalloc should either be nil or a bucket array previously
</span></span></span><span style=display:flex><span><span style=color:#75715e>// allocated by makeBucketArray with the same t and b parameters.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If dirtyalloc is nil a new backing array will be alloced and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// otherwise dirtyalloc will be cleared and reused as backing array.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 翻译：makeBucketArray为map buckets初始化一个备用数组
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2^b是该buckets长度的最小值
</span></span></span><span style=display:flex><span><span style=color:#75715e>// dirtyalloc之前应该是nil或者bucket数组
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 如果dirtyalloc 为nil，将分配一个新的后备数组，否则将清除dirtyalloc 并作为后备数组重用。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint8</span>, <span style=color:#a6e22e>dirtyalloc</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>buckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>base</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketShift</span>(<span style=color:#a6e22e>b</span>) <span style=color:#75715e>// base = 2^b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>base</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For small b, overflow buckets are unlikely.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Avoid the overhead of the calculation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于小的b，不太可能会需要溢出桶，可以避免这部分计算开销
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 对于b&gt;4（桶的数量&gt; 2^4）的话，则需要创建2^(b-4)个溢出桶。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 加上溢出桶的数量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>nbuckets</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bucketShift</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 总大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>sz</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>nbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 针对所需要的内存大小，mallocgc将分配的内存块大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>up</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>roundupsize</span>(<span style=color:#a6e22e>sz</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>up</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>sz</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果总大小和mallocgc将分配的内存块大小不同，以mallocgc分配的为准，计算nbuckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>nbuckets</span> = <span style=color:#a6e22e>up</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dirtyalloc</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newarray</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>, int(<span style=color:#a6e22e>nbuckets</span>))
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dirtyalloc was previously generated by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the above newarray(t.bucket, int(nbuckets))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// but may not be empty.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>dirtyalloc</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>nbuckets</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>nbuckets</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We preallocated some overflow buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// To keep the overhead of tracking these overflow buckets to a minimum,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// we use the convention that if a preallocated overflow bucket&#39;s overflow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// pointer is nil, then there are more available by bumping the pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// We need a safe non-nil pointer for the last overflow bucket; just use buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 我们提前分配了一些溢出桶，为了使得追踪溢出桶的开销最小，我们这样约定:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 如果溢出桶的overflow指针为nil，那么代表还有空间在出现哈希碰撞时使用，
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 溢出桶的最后一个桶的overflow需要指向一个安全的非空指针，这里指向了buckets的第一个桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 具体的用处在map写入时，需要创建溢出桶时会用到，具体在newoverflow函数中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>nextOverflow</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>base</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))) <span style=color:#75715e>// 指向第一个溢出桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>last</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>nbuckets</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))) <span style=color:#75715e>// 指向最后一个溢出桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>last</span>.<span style=color:#a6e22e>setoverflow</span>(<span style=color:#a6e22e>t</span>, (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>buckets</span>)) <span style=color:#75715e>// 溢出桶的最后一个桶的overflow指向了buckets的第一个桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面代码可以得知，2^B 并不等于 buckets 的大小，它只是创建 buckets 时的 base 部分，在该部分后，还有溢出桶。所以正常桶和溢出桶在内存上的分布是连续的，溢出桶的指针记录在了 hmap 的 extra 字段中。</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202201182254581.jpeg alt=手绘图></p><h3 id=map-的读取>map 的读取<a hidden class=anchor aria-hidden=true href=#map-的读取>#</a></h3><p>对于 map 的读取操作，最终是调用了函数 <code>runtime.mapaccess1()</code>和 <code>runtime.mapaccess2()</code> 。两者的唯一区别就是返回值不一样，<code>runtime.mapaccess1()</code> 返回的是一个值，<code>runtime.mapaccess2()</code> 返回的是两个值，第二个值表示 key 是否在 map 中存在。即我们常用的两种 map 取值方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ageMap</span>[<span style=color:#e6db74>&#34;yicixin&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ageMap</span>[<span style=color:#e6db74>&#34;yicixin&#34;</span>]
</span></span></code></pre></div><p>所以我们只需要介绍<code>runtime.mapaccess1()</code>,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// mapaccess1 returns a pointer to h[key].  Never returns nil, instead
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it will return a reference to the zero object for the elem type if
</span></span></span><span style=display:flex><span><span style=color:#75715e>// the key is not in the map.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// NOTE: The returned pointer may keep the whole map live, so don&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>// hold onto it for very long.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// mapaccess1返回指向h[key]的指针，永远不会返回nil，如果key不存在，就会返回元素对应类型的空值。
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 注意：返回的指针可能会使得整个map处于活动状态，所以不要长时间持有它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mapaccess1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racereadpc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 判断h是否为nil或者h.count值是否为0，如果h为nil则表示未初始化，则可能panic，如果h.count=0,则表示map为空，则直接返回一个zero值。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hashMightPanic</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// see issue 23734
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 考虑是否处于并发读写状态，否则产生panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map read and map write&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 根据键key计算hash值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 计算低B位的掩码bucketMask(h.B)，比如 B=5，那 m 就是31，低五位二进制是全1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 计算当前bucket的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 根据h.oldbuckets判断是否处于扩容中，如果不是nil则表示当前map正处于扩容状态中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>; <span style=color:#a6e22e>c</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>m</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>oldb</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>oldb</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>oldb</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 计算tophash，即高八位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 真正开始查找key,外层for是循环bucket及溢出桶overflow，内层for是循环桶内的8个slot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>e</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>key 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span></code></pre></div><p>value 的定位公式:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span></code></pre></div><p>其中 dataOffset 表示 第一个 key 相对于 bmap 的偏移量，结构体如下</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>dataOffset</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    }{}.<span style=color:#a6e22e>v</span>)
</span></span></code></pre></div><p>所以键的地址=当前 bucket 的起始位置(<code>unsafe.Pointer(b)</code>) + 第一个 key 的偏移量(<code>dataOffset</code>)+当前 slot 索引值(<code>i</code>) * 每个键的大小(<code>uintptr(t.keysize)</code>)</p><p>而对于值来说，由于 bmap.values 在 b.map.keys 后面，所以要先将 8 个键的地址全部计算上才行，同样值类型也有自己的大小 <code>t.elemsize</code></p><p>bucket 的几种状态码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>emptyRest</span>      = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>emptyOne</span>       = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// 当前cell为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedX</span>     = <span style=color:#ae81ff>2</span> <span style=color:#75715e>// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedY</span>     = <span style=color:#ae81ff>3</span> <span style=color:#75715e>// 扩容相关，第二部分迁移完毕。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedEmpty</span> = <span style=color:#ae81ff>4</span> <span style=color:#75715e>// 当前cell为空，且迁移完成。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>minTopHash</span>     = <span style=color:#ae81ff>5</span> <span style=color:#75715e>// tophash最小值，如果在调用 tophash(hash)时，计算出的值小于此值，则会加上此值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tophash calculates the tophash value for hash.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>uint8</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>top</span> &lt; <span style=color:#a6e22e>minTopHash</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>top</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>minTopHash</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=map-写入>map 写入<a hidden class=anchor aria-hidden=true href=#map-写入>#</a></h3><p>与 map 写入相关的 runtime 函数是<code>runtime.mapassign()</code>，对于某些 key 类型，runtime 还有特定的函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mapassign_faststr</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapassign_fast64</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapassign_fast32</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>uint32</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span></code></pre></div><p>这是<code>runtime.mapassign</code>函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 空map写入会触发panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;assignment to entry in nil map&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// raceenabled-是否启用数据竞争检测
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mapassign</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 如果并发写入会触发panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 计算hash值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// in which case we have not actually done a write.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 设置写入标志位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> ^= <span style=color:#a6e22e>hashWriting</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>) <span style=color:#75715e>// newarray(t.bucket, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 定位bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// tophash的位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>insertk</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// key的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// val的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 当前cell为空, 并且它后面的所有cell也为空, 包括溢出桶overflow, 可以退出循环了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>              <span style=color:#75715e>// b.tophash[i] == top
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// already have a mapping for key. Update it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>needkeyupdate</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果还有溢出桶，继续查询溢出桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>ovf</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Did not find mapping for key. Allocate new cell &amp; add entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// 如果负载因子到了最大或者有太多的溢出桶，并且不在扩容中，开始扩容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 当前bucket和所有的溢出桶都满了，创建新的溢出桶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>newb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newb</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newb</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store new key/elem at insert position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>insertk</span>) = <span style=color:#a6e22e>kmem</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>kmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>) = <span style=color:#a6e22e>vmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 写入key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>inserti</span> = <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 哈希元素数量+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>elem</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>mapassign</code>中并没有对 val 进行直接赋值，而是返回了 val 的地址，真正的赋值操作在哪呢？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>99999</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>看看这段代码对应的汇编:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#ae81ff>0x003f</span> <span style=color:#ae81ff>00063</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>DX</span>, (<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 第一个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0043</span> <span style=color:#ae81ff>00067</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 第二个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0048</span> <span style=color:#ae81ff>00072</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>CX</span>, <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 第三个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>PCDATA</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span> <span style=color:#75715e>// GC 相关
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>CALL</span>    <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>mapassign_fast64</span>(<span style=color:#a6e22e>SB</span>) <span style=color:#75715e>// 调用函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0052</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>82</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// 返回值，即 value 应该存放的内存地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0057</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>87</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>99999</span>, (<span style=color:#a6e22e>AX</span>) <span style=color:#75715e>// 把 99999 放入该地址中
</span></span></span></code></pre></div><h3 id=map-扩容>map 扩容<a hidden class=anchor aria-hidden=true href=#map-扩容>#</a></h3><p>在上文中的 map 写入操作过程中，有关于 map 扩容的代码，在这一部分细谈 map 扩容机制</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><p>在写入时，有两种情况会触发扩容:</p><ul><li>负载因子超过上限，即元素个数 >= 桶个数 * 6.5，这时候说明大部分的桶可能都快满了，如果插入新元素，有大概率需要挂在 overflow 的桶上。</li><li>太多溢出桶，什么情况会导致太多溢出桶而又不超过负载因子上线呢？这可能发生在我们对 map 一边插入，一边删除，导致其中很多桶出现空洞，虽然使用了很多溢出桶，但是总元素个数并没有超出负载因子上限。这时 bucket 的使用率不高，值存储得比较稀疏，在查找时效率会下降，占据了大量内存却无用，等同于内存泄漏。</li></ul><p>满足任意情况且目前不在扩容状态<code>!h.growing()</code>时，即会进行扩容，map 扩容的函数就是<code>hashGrow(t, h)</code></p><p>针对上面两种不同情况，map 的扩容方法也是不一样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we&#39;ve hit the load factor, get bigger.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Otherwise, there are too many overflow buckets,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// so keep the same number of buckets and &#34;grow&#34; laterally.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bigger</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果不是负载因子超出上限，那么进行的是一次等量扩容，bucket的数量不变
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>bigger</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sameSizeGrow，即为等量扩容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>sameSizeGrow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 等量扩容bigger为0，bucket数不变。否则bigger为1，bucket数翻倍
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>newbuckets</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bigger</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>iterator</span> | <span style=color:#a6e22e>oldIterator</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iterator</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>oldIterator</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// commit the grow (atomic wrt gc)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bigger</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span> = <span style=color:#a6e22e>oldbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Promote current overflow buckets to the old generation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the actual copying of the hash table data is done incrementally
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// by growWork() and evacuate().
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 哈希表数据的实际复制是由 growWork() 和 evacuate() 逐步完成的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>bucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 确保我们移动的 oldbucket 对应的是我们马上就要用到的那一个
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果还在 growing 状态，再多移动一个 oldbucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>重要的是真正的数据迁移部分，<code>evacuate</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>oldbucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newbit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noldbuckets</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: reuse overflow buckets instead of using new ones, if there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// is no iterator using the old buckets.  (If !oldIterator.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// xy contains the x and y (low and high) evacuation destinations.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// evacDst用于保存分配上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// xy 包含的是移动的目标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// x 表示新 bucket 数组的前(low)半部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// y 表示新 bucket 数组的后(high)半部分
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>xy</span> [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>evacDst</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果是等量扩容，新旧bucket是一对一，不需要两个evacDst，而当哈希表的容量翻倍时，每个旧桶的元素会都分流到新创建的两个桶中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Only calculate y pointers if we&#39;re growing bigger.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Otherwise GC can see bad pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>+</span><span style=color:#a6e22e>newbit</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>k</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)), <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>e</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>top</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>evacuatedEmpty</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>top</span> &lt; <span style=color:#a6e22e>minTopHash</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad map state&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>k</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>k2</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k2</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>useY</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Compute hash to make our evacuation decision (whether we need
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// to send this key/elem to bucket x or bucket y).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>k2</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iterator</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>reflexivekey</span>() <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>k2</span>, <span style=color:#a6e22e>k2</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// If key != key (NaNs), then the hash could be (and probably
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// will be) entirely different from the old hash. Moreover,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// it isn&#39;t reproducible. Reproducibility is required in the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// presence of iterators, as our evacuation decision must
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// match whatever decision the iterator made.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// Fortunately, we have the freedom to send these keys either
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// way. Also, tophash is meaningless for these kinds of keys.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// We let the low bit of tophash drive the evacuation decision.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// We recompute a new random tophash for the next level so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// these keys will get evenly distributed across all buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// after multiple grows.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>useY</span> = <span style=color:#a6e22e>top</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>top</span> = <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newbit</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>useY</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>evacuatedX</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedY</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>evacuatedX</span>^<span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedY</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad evacuatedN&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>evacuatedX</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>useY</span> <span style=color:#75715e>// evacuatedX + 1 == evacuatedY
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>dst</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#a6e22e>useY</span>]                 <span style=color:#75715e>// evacuation destination
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>bucketCnt</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)] = <span style=color:#a6e22e>top</span> <span style=color:#75715e>// mask dst.i as an optimization, to avoid a bounds check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>) = <span style=color:#a6e22e>k2</span> <span style=color:#75715e>// copy pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>k</span>) <span style=color:#75715e>// copy elem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>) = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// These updates might push these pointers past the end of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// key or elem arrays.  That&#39;s ok, as we have the overflow pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// at the end of the bucket to protect against pointing past the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// end of the bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Unlink the overflow buckets &amp; clear key/elem to help GC.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oldIterator</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Preserve b.tophash because the evacuation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// state is maintained there.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>dataOffset</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldbucket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>advanceEvacuationMark</span>(<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>newbit</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>golang</a></li><li><a href=https://www.yici.xin/tags/map/>map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>源码解析</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/><span class=title>« 上一页</span><br><span>Golang——plan9汇编</span></a>
<a class=next href=https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/><span class=title>下一页 »</span><br><span>Rust Option枚举</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
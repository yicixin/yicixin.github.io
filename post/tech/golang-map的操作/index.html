<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang-mapçš„æ“ä½œ | yicixin's blog</title><meta name=keywords content="golang,map,hashmap,æºç è§£æ"><meta name=description content="åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><meta name=author content="å£¹æ¬¡å¿ƒ"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang-mapçš„æ“ä½œ"><meta property="og:description" content="åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:49:41+08:00"><meta property="article:modified_time" content="2022-12-30T10:49:41+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang-mapçš„æ“ä½œ"><meta name=twitter:description content="åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"ğŸ‘¨ğŸ»â€ğŸ’»æŠ€æœ¯","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang-mapçš„æ“ä½œ","item":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang-mapçš„æ“ä½œ","name":"Golang-mapçš„æ“ä½œ","description":"åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•\n// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h.","keywords":["golang","map","hashmap","æºç è§£æ"],"articleBody":"åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•\n// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚ // å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚ // å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚ // å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket func makemap(t *maptype, hint int, h *hmap) *hmap { // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å° mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­ if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B \u003c hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç° if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼ h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u003c","wordCount":"2376","inLanguage":"zh","datePublished":"2022-12-30T10:49:41+08:00","dateModified":"2022-12-30T10:49:41+08:00","author":[{"@type":"Person","name":"å£¹æ¬¡å¿ƒ"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="Yicixin's blog (Alt + H)">Yicixin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=æ ‡ç­¾ğŸ·ï¸><span>æ ‡ç­¾ğŸ·ï¸</span></a></li><li><a href=https://www.yici.xin/archives/ title=å½’æ¡£ğŸ•°ï¸><span>å½’æ¡£ğŸ•°ï¸</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/tech/>ğŸ‘¨ğŸ»â€ğŸ’»æŠ€æœ¯</a></div><h1 class=post-title>Golang-mapçš„æ“ä½œ</h1><div class=post-meta><span title='2022-12-30 10:49:41 +0800 +0800'>2022-12-30</span>&nbsp;Â·&nbsp;12 åˆ†é’Ÿ&nbsp;Â·&nbsp;2376 å­—&nbsp;Â·&nbsp;å£¹æ¬¡å¿ƒ&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/tech/golang-map%e7%9a%84%e6%93%8d%e4%bd%9c.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>ç›®å½•</span></summary><div class=inner><ul><li><a href=#%e5%88%9b%e5%bb%ba-map aria-label="åˆ›å»º map">åˆ›å»º map</a></li><li><a href=#map-%e7%9a%84%e8%af%bb%e5%8f%96 aria-label="map çš„è¯»å–">map çš„è¯»å–</a></li><li><a href=#map-%e5%86%99%e5%85%a5 aria-label="map å†™å…¥">map å†™å…¥</a></li><li><a href=#map-%e6%89%a9%e5%ae%b9 aria-label="map æ‰©å®¹">map æ‰©å®¹</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=åˆ›å»º-map>åˆ›å»º map<a hidden class=anchor aria-hidden=true href=#åˆ›å»º-map>#</a></h3><p>åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ä¸æŒ‡å®šmapé•¿åº¦
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ageMp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// æŒ‡å®šmapé•¿åº¦
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ageMp</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ageMp</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>int</span>
</span></span></code></pre></div><p>é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// makemap implements Go map creation for make(map[k]v, hint).
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If the compiler has determined that the map or the first bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e>// can be created on the stack, h and/or bucket may be non-nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If h != nil, the map can be created directly in h.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If h.buckets != nil, bucket pointed to can be used as the first bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e>// å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e>// å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e>// å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makemap</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>hint</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>mem</span>, <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>MulUintptr</span>(uintptr(<span style=color:#a6e22e>hint</span>), <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>overflow</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mem</span> &gt; <span style=color:#a6e22e>maxAlloc</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hint</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span> = new(<span style=color:#a6e22e>hmap</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span> = <span style=color:#a6e22e>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Find the size parameter B which will hold the requested # of elements.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B &lt; hint
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>B</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>hint</span>, <span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>B</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> = <span style=color:#a6e22e>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// allocate initial hash table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// if B == 0, the buckets field is allocated lazily later (in mapassign)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// If hint is large zeroing this memory could take a while.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// makeBucketArray initializes a backing array for map buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 1&lt;&lt;b is the minimum number of buckets to allocate.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// dirtyalloc should either be nil or a bucket array previously
</span></span></span><span style=display:flex><span><span style=color:#75715e>// allocated by makeBucketArray with the same t and b parameters.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If dirtyalloc is nil a new backing array will be alloced and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// otherwise dirtyalloc will be cleared and reused as backing array.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„
</span></span></span><span style=display:flex><span><span style=color:#75715e>// 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e>// dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„
</span></span></span><span style=display:flex><span><span style=color:#75715e>// å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>uint8</span>, <span style=color:#a6e22e>dirtyalloc</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) (<span style=color:#a6e22e>buckets</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>base</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketShift</span>(<span style=color:#a6e22e>b</span>) <span style=color:#75715e>// base = 2^b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>nbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>base</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// For small b, overflow buckets are unlikely.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Avoid the overhead of the calculation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// å¯¹äºb&gt;4ï¼ˆæ¡¶çš„æ•°é‡&gt; 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>nbuckets</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bucketShift</span>(<span style=color:#a6e22e>b</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// æ€»å¤§å°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>sz</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>nbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>up</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>roundupsize</span>(<span style=color:#a6e22e>sz</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>up</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>sz</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>nbuckets</span> = <span style=color:#a6e22e>up</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dirtyalloc</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newarray</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>, int(<span style=color:#a6e22e>nbuckets</span>))
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// dirtyalloc was previously generated by
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the above newarray(t.bucket, int(nbuckets))
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// but may not be empty.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>dirtyalloc</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>size</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>nbuckets</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrNoHeapPointers</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>base</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>nbuckets</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// We preallocated some overflow buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// To keep the overhead of tracking these overflow buckets to a minimum,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// we use the convention that if a preallocated overflow bucket&#39;s overflow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// pointer is nil, then there are more available by bumping the pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// We need a safe non-nil pointer for the last overflow bucket; just use buckets.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>nextOverflow</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>base</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))) <span style=color:#75715e>// æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>last</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>nbuckets</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))) <span style=color:#75715e>// æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>last</span>.<span style=color:#a6e22e>setoverflow</span>(<span style=color:#a6e22e>t</span>, (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>buckets</span>)) <span style=color:#75715e>// æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202201182254581.jpeg alt=æ‰‹ç»˜å›¾></p><h3 id=map-çš„è¯»å–>map çš„è¯»å–<a hidden class=anchor aria-hidden=true href=#map-çš„è¯»å–>#</a></h3><p>å¯¹äº map çš„è¯»å–æ“ä½œï¼Œæœ€ç»ˆæ˜¯è°ƒç”¨äº†å‡½æ•° <code>runtime.mapaccess1()</code>å’Œ <code>runtime.mapaccess2()</code> ã€‚ä¸¤è€…çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯è¿”å›å€¼ä¸ä¸€æ ·ï¼Œ<code>runtime.mapaccess1()</code> è¿”å›çš„æ˜¯ä¸€ä¸ªå€¼ï¼Œ<code>runtime.mapaccess2()</code> è¿”å›çš„æ˜¯ä¸¤ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªå€¼è¡¨ç¤º key æ˜¯å¦åœ¨ map ä¸­å­˜åœ¨ã€‚å³æˆ‘ä»¬å¸¸ç”¨çš„ä¸¤ç§ map å–å€¼æ–¹æ³•ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ageMap</span>[<span style=color:#e6db74>&#34;yicixin&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ageMap</span>[<span style=color:#e6db74>&#34;yicixin&#34;</span>]
</span></span></code></pre></div><p>æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä»‹ç»<code>runtime.mapaccess1()</code>,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// mapaccess1 returns a pointer to h[key].  Never returns nil, instead
</span></span></span><span style=display:flex><span><span style=color:#75715e>// it will return a reference to the zero object for the elem type if
</span></span></span><span style=display:flex><span><span style=color:#75715e>// the key is not in the map.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// NOTE: The returned pointer may keep the whole map live, so don&#39;t
</span></span></span><span style=display:flex><span><span style=color:#75715e>// hold onto it for very long.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// mapaccess1è¿”å›æŒ‡å‘h[key]çš„æŒ‡é’ˆï¼Œæ°¸è¿œä¸ä¼šè¿”å›nilï¼Œå¦‚æœkeyä¸å­˜åœ¨ï¼Œå°±ä¼šè¿”å›å…ƒç´ å¯¹åº”ç±»å‹çš„ç©ºå€¼ã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e>// æ³¨æ„ï¼šè¿”å›çš„æŒ‡é’ˆå¯èƒ½ä¼šä½¿å¾—æ•´ä¸ªmapå¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œæ‰€ä»¥ä¸è¦é•¿æ—¶é—´æŒæœ‰å®ƒ
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapaccess1</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mapaccess1</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racereadpc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// åˆ¤æ–­hæ˜¯å¦ä¸ºnilæˆ–è€…h.countå€¼æ˜¯å¦ä¸º0ï¼Œå¦‚æœhä¸ºnilåˆ™è¡¨ç¤ºæœªåˆå§‹åŒ–ï¼Œåˆ™å¯èƒ½panicï¼Œå¦‚æœh.count=0,åˆ™è¡¨ç¤ºmapä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›ä¸€ä¸ªzeroå€¼ã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hashMightPanic</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, <span style=color:#ae81ff>0</span>) <span style=color:#75715e>// see issue 23734
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// è€ƒè™‘æ˜¯å¦å¤„äºå¹¶å‘è¯»å†™çŠ¶æ€ï¼Œå¦åˆ™äº§ç”Ÿpanic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map read and map write&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// æ ¹æ®é”®keyè®¡ç®—hashå€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>      <span style=color:#75715e>// è®¡ç®—ä½Bä½çš„æ©ç bucketMask(h.B)ï¼Œæ¯”å¦‚ B=5ï¼Œé‚£ m å°±æ˜¯31ï¼Œä½äº”ä½äºŒè¿›åˆ¶æ˜¯å…¨1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>      <span style=color:#75715e>// è®¡ç®—å½“å‰bucketçš„åœ°å€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>      <span style=color:#75715e>// æ ¹æ®h.oldbucketsåˆ¤æ–­æ˜¯å¦å¤„äºæ‰©å®¹ä¸­ï¼Œå¦‚æœä¸æ˜¯nilåˆ™è¡¨ç¤ºå½“å‰mapæ­£å¤„äºæ‰©å®¹çŠ¶æ€ä¸­
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>; <span style=color:#a6e22e>c</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// There used to be half as many buckets; mask down one more power of two.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>m</span> <span style=color:#f92672>&gt;&gt;=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>oldb</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>c</span>, (<span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>m</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>oldb</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>oldb</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// è®¡ç®—tophashï¼Œå³é«˜å…«ä½
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// çœŸæ­£å¼€å§‹æŸ¥æ‰¾key,å¤–å±‚foræ˜¯å¾ªç¯bucketåŠæº¢å‡ºæ¡¶overflowï¼Œå†…å±‚foræ˜¯å¾ªç¯æ¡¶å†…çš„8ä¸ªslot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>e</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>e</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>zeroVal</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>key çš„å®šä½å…¬å¼:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span></code></pre></div><p>value çš„å®šä½å…¬å¼:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span></code></pre></div><p>å…¶ä¸­ dataOffset è¡¨ç¤º ç¬¬ä¸€ä¸ª key ç›¸å¯¹äº bmap çš„åç§»é‡ï¼Œç»“æ„ä½“å¦‚ä¸‹</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>dataOffset</span> = <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Offsetof</span>(<span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>    }{}.<span style=color:#a6e22e>v</span>)
</span></span></code></pre></div><p>æ‰€ä»¥é”®çš„åœ°å€=å½“å‰ bucket çš„èµ·å§‹ä½ç½®(<code>unsafe.Pointer(b)</code>) + ç¬¬ä¸€ä¸ª key çš„åç§»é‡(<code>dataOffset</code>)+å½“å‰ slot ç´¢å¼•å€¼(<code>i</code>) * æ¯ä¸ªé”®çš„å¤§å°(<code>uintptr(t.keysize)</code>)</p><p>è€Œå¯¹äºå€¼æ¥è¯´ï¼Œç”±äº bmap.values åœ¨ b.map.keys åé¢ï¼Œæ‰€ä»¥è¦å…ˆå°† 8 ä¸ªé”®çš„åœ°å€å…¨éƒ¨è®¡ç®—ä¸Šæ‰è¡Œï¼ŒåŒæ ·å€¼ç±»å‹ä¹Ÿæœ‰è‡ªå·±çš„å¤§å° <code>t.elemsize</code></p><p>bucket çš„å‡ ç§çŠ¶æ€ç </p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#a6e22e>emptyRest</span>      = <span style=color:#ae81ff>0</span> <span style=color:#75715e>// å½“å‰cellä¸ºç©º, å¹¶ä¸”å®ƒåé¢çš„æ‰€æœ‰cellä¹Ÿä¸ºç©º, åŒ…æ‹¬æº¢å‡ºæ¡¶overflow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>emptyOne</span>       = <span style=color:#ae81ff>1</span> <span style=color:#75715e>// å½“å‰cellä¸ºç©º
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedX</span>     = <span style=color:#ae81ff>2</span> <span style=color:#75715e>// key/elem is valid.  Entry has been evacuated to first half of larger table.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedY</span>     = <span style=color:#ae81ff>3</span> <span style=color:#75715e>// æ‰©å®¹ç›¸å…³ï¼Œç¬¬äºŒéƒ¨åˆ†è¿ç§»å®Œæ¯•ã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuatedEmpty</span> = <span style=color:#ae81ff>4</span> <span style=color:#75715e>// å½“å‰cellä¸ºç©ºï¼Œä¸”è¿ç§»å®Œæˆã€‚
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>minTopHash</span>     = <span style=color:#ae81ff>5</span> <span style=color:#75715e>// tophashæœ€å°å€¼ï¼Œå¦‚æœåœ¨è°ƒç”¨ tophash(hash)æ—¶ï¼Œè®¡ç®—å‡ºçš„å€¼å°äºæ­¤å€¼ï¼Œåˆ™ä¼šåŠ ä¸Šæ­¤å€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// tophash calculates the tophash value for hash.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span> <span style=color:#66d9ef>uintptr</span>) <span style=color:#66d9ef>uint8</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#a6e22e>hash</span> <span style=color:#f92672>&gt;&gt;</span> (<span style=color:#a6e22e>sys</span>.<span style=color:#a6e22e>PtrSize</span><span style=color:#f92672>*</span><span style=color:#ae81ff>8</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>top</span> &lt; <span style=color:#a6e22e>minTopHash</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>top</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>minTopHash</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=map-å†™å…¥>map å†™å…¥<a hidden class=anchor aria-hidden=true href=#map-å†™å…¥>#</a></h3><p>ä¸ map å†™å…¥ç›¸å…³çš„ runtime å‡½æ•°æ˜¯<code>runtime.mapassign()</code>ï¼Œå¯¹äºæŸäº› key ç±»å‹ï¼Œruntime è¿˜æœ‰ç‰¹å®šçš„å‡½æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>mapassign_faststr</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapassign_fast64</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>uint64</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapassign_fast32</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#66d9ef>uint32</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>
</span></span></code></pre></div><p>è¿™æ˜¯<code>runtime.mapassign</code>å‡½æ•°ï¼š</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mapassign</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>key</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ç©ºmapå†™å…¥ä¼šè§¦å‘panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>plainError</span>(<span style=color:#e6db74>&#34;assignment to entry in nil map&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// raceenabled-æ˜¯å¦å¯ç”¨æ•°æ®ç«äº‰æ£€æµ‹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>callerpc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>funcPC</span>(<span style=color:#a6e22e>mapassign</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>racewritepc</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>h</span>), <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>raceReadObjectPC</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>callerpc</span>, <span style=color:#a6e22e>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>msanenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>msanread</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// å¦‚æœå¹¶å‘å†™å…¥ä¼šè§¦å‘panic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// è®¡ç®—hashå€¼
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>key</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set hashWriting after calling t.hasher, since t.hasher may panic,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// in which case we have not actually done a write.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// è®¾ç½®å†™å…¥æ ‡å¿—ä½
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> ^= <span style=color:#a6e22e>hashWriting</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>) <span style=color:#75715e>// newarray(t.bucket, 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>again</span>:
</span></span><span style=display:flex><span>      <span style=color:#75715e>// å®šä½bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bucket</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>hash</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>bucketMask</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uint8</span> <span style=color:#75715e>// tophashçš„ä½ç½®
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>insertk</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// keyçš„åœ°å€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>elem</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// valçš„åœ°å€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>!=</span> <span style=color:#a6e22e>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#75715e>// å½“å‰cellä¸ºç©º, å¹¶ä¸”å®ƒåé¢çš„æ‰€æœ‰cellä¹Ÿä¸ºç©º, åŒ…æ‹¬æº¢å‡ºæ¡¶overflow, å¯ä»¥é€€å‡ºå¾ªç¯äº†
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#a6e22e>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span> <span style=color:#a6e22e>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>              <span style=color:#75715e>// b.tophash[i] == top
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// already have a mapping for key. Update it.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>needkeyupdate</span>() {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)<span style=color:#f92672>+</span><span style=color:#a6e22e>i</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// å¦‚æœè¿˜æœ‰æº¢å‡ºæ¡¶ï¼Œç»§ç»­æŸ¥è¯¢æº¢å‡ºæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ovf</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>ovf</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Did not find mapping for key. Allocate new cell &amp; add entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we hit the max load factor or we have too many overflow buckets,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// and we&#39;re not already in the middle of growing, start growing.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// å¦‚æœè´Ÿè½½å› å­åˆ°äº†æœ€å¤§æˆ–è€…æœ‰å¤ªå¤šçš„æº¢å‡ºæ¡¶ï¼Œå¹¶ä¸”ä¸åœ¨æ‰©å®¹ä¸­ï¼Œå¼€å§‹æ‰©å®¹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>inserti</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// å½“å‰bucketå’Œæ‰€æœ‰çš„æº¢å‡ºæ¡¶éƒ½æ»¡äº†ï¼Œåˆ›å»ºæ–°çš„æº¢å‡ºæ¡¶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>newb</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>inserti</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newb</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>newb</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>elem</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// store new key/elem at insert position
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>kmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>insertk</span>) = <span style=color:#a6e22e>kmem</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insertk</span> = <span style=color:#a6e22e>kmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>vmem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newobject</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>) = <span style=color:#a6e22e>vmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// å†™å…¥key
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>insertk</span>, <span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>inserti</span> = <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// å“ˆå¸Œå…ƒç´ æ•°é‡+1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hashWriting</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^=</span> <span style=color:#a6e22e>hashWriting</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>elem</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>elem</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>elem</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>åœ¨<code>mapassign</code>ä¸­å¹¶æ²¡æœ‰å¯¹ val è¿›è¡Œç›´æ¥èµ‹å€¼ï¼Œè€Œæ˜¯è¿”å›äº† val çš„åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œåœ¨å“ªå‘¢ï¼Ÿ</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = make(<span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>int</span>]<span style=color:#66d9ef>int</span>, <span style=color:#ae81ff>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>1000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>99999</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>çœ‹çœ‹è¿™æ®µä»£ç å¯¹åº”çš„æ±‡ç¼–:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#ae81ff>0x003f</span> <span style=color:#ae81ff>00063</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>DX</span>, (<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// ç¬¬ä¸€ä¸ªå‚æ•°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0043</span> <span style=color:#ae81ff>00067</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>AX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// ç¬¬äºŒä¸ªå‚æ•°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0048</span> <span style=color:#ae81ff>00072</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#a6e22e>CX</span>, <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// ç¬¬ä¸‰ä¸ªå‚æ•°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>PCDATA</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span> <span style=color:#75715e>// GC ç›¸å…³
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x004d</span> <span style=color:#ae81ff>00077</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>CALL</span>    <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>mapassign_fast64</span>(<span style=color:#a6e22e>SB</span>) <span style=color:#75715e>// è°ƒç”¨å‡½æ•°
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0052</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>82</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// è¿”å›å€¼ï¼Œå³ value åº”è¯¥å­˜æ”¾çš„å†…å­˜åœ°å€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0057</span> <span style=color:#ae81ff>000</span><span style=color:#ae81ff>87</span> (<span style=color:#a6e22e>m</span>.<span style=color:#66d9ef>go</span>:<span style=color:#ae81ff>9</span>)    <span style=color:#a6e22e>MOVQ</span>    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>99999</span>, (<span style=color:#a6e22e>AX</span>) <span style=color:#75715e>// æŠŠ 99999 æ”¾å…¥è¯¥åœ°å€ä¸­
</span></span></span></code></pre></div><h3 id=map-æ‰©å®¹>map æ‰©å®¹<a hidden class=anchor aria-hidden=true href=#map-æ‰©å®¹>#</a></h3><p>åœ¨ä¸Šæ–‡ä¸­çš„ map å†™å…¥æ“ä½œè¿‡ç¨‹ä¸­ï¼Œæœ‰å…³äº map æ‰©å®¹çš„ä»£ç ï¼Œåœ¨è¿™ä¸€éƒ¨åˆ†ç»†è°ˆ map æ‰©å®¹æœºåˆ¶</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>tooManyOverflowBuckets</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>again</span> <span style=color:#75715e>// Growing the table invalidates everything, so try again
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span></code></pre></div><p>åœ¨å†™å…¥æ—¶ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¼šè§¦å‘æ‰©å®¹:</p><ul><li>è´Ÿè½½å› å­è¶…è¿‡ä¸Šé™ï¼Œå³å…ƒç´ ä¸ªæ•° >= æ¡¶ä¸ªæ•° * 6.5ï¼Œè¿™æ—¶å€™è¯´æ˜å¤§éƒ¨åˆ†çš„æ¡¶å¯èƒ½éƒ½å¿«æ»¡äº†ï¼Œå¦‚æœæ’å…¥æ–°å…ƒç´ ï¼Œæœ‰å¤§æ¦‚ç‡éœ€è¦æŒ‚åœ¨ overflow çš„æ¡¶ä¸Šã€‚</li><li>å¤ªå¤šæº¢å‡ºæ¡¶ï¼Œä»€ä¹ˆæƒ…å†µä¼šå¯¼è‡´å¤ªå¤šæº¢å‡ºæ¡¶è€Œåˆä¸è¶…è¿‡è´Ÿè½½å› å­ä¸Šçº¿å‘¢ï¼Ÿè¿™å¯èƒ½å‘ç”Ÿåœ¨æˆ‘ä»¬å¯¹ map ä¸€è¾¹æ’å…¥ï¼Œä¸€è¾¹åˆ é™¤ï¼Œå¯¼è‡´å…¶ä¸­å¾ˆå¤šæ¡¶å‡ºç°ç©ºæ´ï¼Œè™½ç„¶ä½¿ç”¨äº†å¾ˆå¤šæº¢å‡ºæ¡¶ï¼Œä½†æ˜¯æ€»å…ƒç´ ä¸ªæ•°å¹¶æ²¡æœ‰è¶…å‡ºè´Ÿè½½å› å­ä¸Šé™ã€‚è¿™æ—¶ bucket çš„ä½¿ç”¨ç‡ä¸é«˜ï¼Œå€¼å­˜å‚¨å¾—æ¯”è¾ƒç¨€ç–ï¼Œåœ¨æŸ¥æ‰¾æ—¶æ•ˆç‡ä¼šä¸‹é™ï¼Œå æ®äº†å¤§é‡å†…å­˜å´æ— ç”¨ï¼Œç­‰åŒäºå†…å­˜æ³„æ¼ã€‚</li></ul><p>æ»¡è¶³ä»»æ„æƒ…å†µä¸”ç›®å‰ä¸åœ¨æ‰©å®¹çŠ¶æ€<code>!h.growing()</code>æ—¶ï¼Œå³ä¼šè¿›è¡Œæ‰©å®¹ï¼Œmap æ‰©å®¹çš„å‡½æ•°å°±æ˜¯<code>hashGrow(t, h)</code></p><p>é’ˆå¯¹ä¸Šé¢ä¸¤ç§ä¸åŒæƒ…å†µï¼Œmap çš„æ‰©å®¹æ–¹æ³•ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>hashGrow</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If we&#39;ve hit the load factor, get bigger.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Otherwise, there are too many overflow buckets,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// so keep the same number of buckets and &#34;grow&#34; laterally.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bigger</span> <span style=color:#f92672>:=</span> uint8(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// å¦‚æœä¸æ˜¯è´Ÿè½½å› å­è¶…å‡ºä¸Šé™ï¼Œé‚£ä¹ˆè¿›è¡Œçš„æ˜¯ä¸€æ¬¡ç­‰é‡æ‰©å®¹ï¼Œbucketçš„æ•°é‡ä¸å˜
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>overLoadFactor</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>count</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>bigger</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// sameSizeGrowï¼Œå³ä¸ºç­‰é‡æ‰©å®¹
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>sameSizeGrow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>oldbuckets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ç­‰é‡æ‰©å®¹biggerä¸º0ï¼Œbucketæ•°ä¸å˜ã€‚å¦åˆ™biggerä¸º1ï¼Œbucketæ•°ç¿»å€
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>newbuckets</span>, <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>makeBucketArray</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span><span style=color:#f92672>+</span><span style=color:#a6e22e>bigger</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;^</span> (<span style=color:#a6e22e>iterator</span> | <span style=color:#a6e22e>oldIterator</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iterator</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>oldIterator</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// commit the grow (atomic wrt gc)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>B</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>bigger</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span> = <span style=color:#a6e22e>oldbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span> = <span style=color:#a6e22e>newbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noverflow</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Promote current overflow buckets to the old generation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>oldoverflow</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>overflow</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>nextOverflow</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span> = new(<span style=color:#a6e22e>mapextra</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>extra</span>.<span style=color:#a6e22e>nextOverflow</span> = <span style=color:#a6e22e>nextOverflow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the actual copying of the hash table data is done incrementally
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// by growWork() and evacuate().
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// å“ˆå¸Œè¡¨æ•°æ®çš„å®é™…å¤åˆ¶æ˜¯ç”± growWork() å’Œ evacuate() é€æ­¥å®Œæˆçš„
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>growWork</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>bucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ç¡®ä¿æˆ‘ä»¬ç§»åŠ¨çš„ oldbucket å¯¹åº”çš„æ˜¯æˆ‘ä»¬é©¬ä¸Šå°±è¦ç”¨åˆ°çš„é‚£ä¸€ä¸ª
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>bucket</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// å¦‚æœè¿˜åœ¨ growing çŠ¶æ€ï¼Œå†å¤šç§»åŠ¨ä¸€ä¸ª oldbucket
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>é‡è¦çš„æ˜¯çœŸæ­£çš„æ•°æ®è¿ç§»éƒ¨åˆ†ï¼Œ<code>evacuate</code>å‡½æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>evacuate</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>maptype</span>, <span style=color:#a6e22e>h</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>hmap</span>, <span style=color:#a6e22e>oldbucket</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newbit</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>noldbuckets</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>evacuated</span>(<span style=color:#a6e22e>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO: reuse overflow buckets instead of using new ones, if there
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// is no iterator using the old buckets.  (If !oldIterator.)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// xy contains the x and y (low and high) evacuation destinations.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// evacDstç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// xy åŒ…å«çš„æ˜¯ç§»åŠ¨çš„ç›®æ ‡
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// x è¡¨ç¤ºæ–° bucket æ•°ç»„çš„å‰(low)åŠéƒ¨åˆ†
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// y è¡¨ç¤ºæ–° bucket æ•°ç»„çš„å(high)åŠéƒ¨åˆ†
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>xy</span> [<span style=color:#ae81ff>2</span>]<span style=color:#a6e22e>evacDst</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// å¦‚æœæ˜¯ç­‰é‡æ‰©å®¹ï¼Œæ–°æ—§bucketæ˜¯ä¸€å¯¹ä¸€ï¼Œä¸éœ€è¦ä¸¤ä¸ªevacDstï¼Œè€Œå½“å“ˆå¸Œè¡¨çš„å®¹é‡ç¿»å€æ—¶ï¼Œæ¯ä¸ªæ—§æ¡¶çš„å…ƒç´ ä¼šéƒ½åˆ†æµåˆ°æ–°åˆ›å»ºçš„ä¸¤ä¸ªæ¡¶ä¸­
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Only calculate y pointers if we&#39;re growing bigger.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// Otherwise GC can see bad pointers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span><span style=color:#a6e22e>bmap</span>)(<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>buckets</span>, (<span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>+</span><span style=color:#a6e22e>newbit</span>)<span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>)))
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ; <span style=color:#a6e22e>b</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>overflow</span>(<span style=color:#a6e22e>t</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>bucketCnt</span>; <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>k</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>)), <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>e</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>top</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isEmpty</span>(<span style=color:#a6e22e>top</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>evacuatedEmpty</span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>top</span> &lt; <span style=color:#a6e22e>minTopHash</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad map state&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>k2</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>k</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>k2</span> = <span style=color:#f92672>*</span>((<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>k2</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>useY</span> <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// Compute hash to make our evacuation decision (whether we need
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#75715e>// to send this key/elem to bucket x or bucket y).
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                    <span style=color:#a6e22e>hash</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>hasher</span>(<span style=color:#a6e22e>k2</span>, uintptr(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>hash0</span>))
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>iterator</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>reflexivekey</span>() <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>.<span style=color:#a6e22e>equal</span>(<span style=color:#a6e22e>k2</span>, <span style=color:#a6e22e>k2</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// If key != key (NaNs), then the hash could be (and probably
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// will be) entirely different from the old hash. Moreover,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// it isn&#39;t reproducible. Reproducibility is required in the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// presence of iterators, as our evacuation decision must
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// match whatever decision the iterator made.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// Fortunately, we have the freedom to send these keys either
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// way. Also, tophash is meaningless for these kinds of keys.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// We let the low bit of tophash drive the evacuation decision.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// We recompute a new random tophash for the next level so
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// these keys will get evenly distributed across all buckets
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#75715e>// after multiple grows.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        <span style=color:#a6e22e>useY</span> = <span style=color:#a6e22e>top</span> <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>top</span> = <span style=color:#a6e22e>tophash</span>(<span style=color:#a6e22e>hash</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hash</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>newbit</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>useY</span> = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>evacuatedX</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedY</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>evacuatedX</span>^<span style=color:#ae81ff>1</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>evacuatedY</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;bad evacuatedN&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>evacuatedX</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>useY</span> <span style=color:#75715e>// evacuatedX + 1 == evacuatedY
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>dst</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>xy</span>[<span style=color:#a6e22e>useY</span>]                 <span style=color:#75715e>// evacuation destination
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>bucketCnt</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>newoverflow</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>), <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>tophash</span>[<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>bucketCnt</span><span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)] = <span style=color:#a6e22e>top</span> <span style=color:#75715e>// mask dst.i as an optimization, to avoid a bounds check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>) = <span style=color:#a6e22e>k2</span> <span style=color:#75715e>// copy pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>k</span>) <span style=color:#75715e>// copy elem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>) = <span style=color:#f92672>*</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>)(<span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>typedmemmove</span>(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elem</span>, <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>, <span style=color:#a6e22e>e</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// These updates might push these pointers past the end of the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// key or elem arrays.  That&#39;s ok, as we have the overflow pointer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// at the end of the bucket to protect against pointing past the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#75715e>// end of the bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>k</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>keysize</span>))
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span> = <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>dst</span>.<span style=color:#a6e22e>e</span>, uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>elemsize</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Unlink the overflow buckets &amp; clear key/elem to help GC.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>flags</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>oldIterator</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucket</span>.<span style=color:#a6e22e>ptrdata</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>oldbuckets</span>, <span style=color:#a6e22e>oldbucket</span><span style=color:#f92672>*</span>uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Preserve b.tophash because the evacuation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// state is maintained there.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>bucketsize</span>) <span style=color:#f92672>-</span> <span style=color:#a6e22e>dataOffset</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>memclrHasPointers</span>(<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>n</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>oldbucket</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>h</span>.<span style=color:#a6e22e>nevacuate</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>advanceEvacuationMark</span>(<span style=color:#a6e22e>h</span>, <span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>newbit</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>golang</a></li><li><a href=https://www.yici.xin/tags/map/>map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>æºç è§£æ</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/><span class=title>Â« ä¸Šä¸€é¡µ</span><br><span>Golangâ€”â€”plan9æ±‡ç¼–</span></a>
<a class=next href=https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/><span class=title>ä¸‹ä¸€é¡µ Â»</span><br><span>Rust Optionæšä¸¾</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="å·²å¤åˆ¶ï¼",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
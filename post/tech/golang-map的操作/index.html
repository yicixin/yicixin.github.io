<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang-mapçš„æ“ä½œ | æ¡æœˆæ‹…é£</title>
<meta name=keywords content="golang,map,hashmap,æºç è§£æ"><meta name=description content="åˆ›å»º map
åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int)
// æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int, 8)
// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic
var ageMp map[string]int
é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚
// å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚
// å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚
// å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å°
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç°
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„
// 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼
// dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„
// å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€
    // å¯¹äºb>4ï¼ˆæ¡¶çš„æ•°é‡> 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚
    if b >= 4 {
        // åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡
        nbuckets += bucketShift(b - 4)
    // æ€»å¤§å°
        sz := t.bucket.size * nbuckets
    // é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°
        up := roundupsize(sz)
        if up != sz {
      // å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š:
        // å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ
        // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
        // å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶
        last.setoverflow(t, (*bmap)(buckets)) // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
    }
    return buckets, nextOverflow
}
ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚"><meta name=author content="å£¹æ¬¡å¿ƒ"><link rel=canonical href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.278e8b2dd0edae6a4a4d865210e46385ee100556bcf14ba56506e7501326056e.css integrity="sha256-J46LLdDtrmpKTYZSEORjhe4QBVa88UulZQbnUBMmBW4=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="Golang-mapçš„æ“ä½œ"><meta property="og:description" content="åˆ›å»º map
åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int)
// æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int, 8)
// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic
var ageMp map[string]int
é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚
// å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚
// å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚
// å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å°
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç°
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„
// 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼
// dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„
// å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€
    // å¯¹äºb>4ï¼ˆæ¡¶çš„æ•°é‡> 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚
    if b >= 4 {
        // åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡
        nbuckets += bucketShift(b - 4)
    // æ€»å¤§å°
        sz := t.bucket.size * nbuckets
    // é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°
        up := roundupsize(sz)
        if up != sz {
      // å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š:
        // å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ
        // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
        // å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶
        last.setoverflow(t, (*bmap)(buckets)) // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
    }
    return buckets, nextOverflow
}
ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:49:41+08:00"><meta property="article:modified_time" content="2022-12-30T10:49:41+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang-mapçš„æ“ä½œ"><meta name=twitter:description content="åˆ›å»º map
åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•
// ä¸æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int)
// æŒ‡å®šmapé•¿åº¦
ageMp := make(map[string]int, 8)
// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic
var ageMp map[string]int
é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•
// makemap implements Go map creation for make(map[k]v, hint).
// If the compiler has determined that the map or the first bucket
// can be created on the stack, h and/or bucket may be non-nil.
// If h != nil, the map can be created directly in h.
// If h.buckets != nil, bucket pointed to can be used as the first bucket.
// ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚
// å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚
// å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚
// å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket
func makemap(t *maptype, hint int, h *hmap) *hmap {
  // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å°
    mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
    if overflow || mem > maxAlloc {
        hint = 0
    }

    // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­
    if h == nil {
        h = new(hmap)
    }
    h.hash0 = fastrand()

    // Find the size parameter B which will hold the requested # of elements.
    // For hint < 0 overLoadFactor returns false since hint < bucketCnt.
      // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B < hint
    B := uint8(0)
    for overLoadFactor(hint, B) {
        B++
    }
    h.B = B

    // allocate initial hash table
    // if B == 0, the buckets field is allocated lazily later (in mapassign)
    // If hint is large zeroing this memory could take a while.
      // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç°
    if h.B != 0 {
        var nextOverflow *bmap
        h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
        if nextOverflow != nil {
            h.extra = new(mapextra)
      // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼
            h.extra.nextOverflow = nextOverflow
        }
    }

    return h
}
// makeBucketArray initializes a backing array for map buckets.
// 1<<b is the minimum number of buckets to allocate.
// dirtyalloc should either be nil or a bucket array previously
// allocated by makeBucketArray with the same t and b parameters.
// If dirtyalloc is nil a new backing array will be alloced and
// otherwise dirtyalloc will be cleared and reused as backing array.
// ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„
// 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼
// dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„
// å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
    base := bucketShift(b) // base = 2^b
    nbuckets := base
    // For small b, overflow buckets are unlikely.
    // Avoid the overhead of the calculation.
    // å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€
    // å¯¹äºb>4ï¼ˆæ¡¶çš„æ•°é‡> 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚
    if b >= 4 {
        // åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡
        nbuckets += bucketShift(b - 4)
    // æ€»å¤§å°
        sz := t.bucket.size * nbuckets
    // é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°
        up := roundupsize(sz)
        if up != sz {
      // å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets
            nbuckets = up / t.bucket.size
        }
    }

    if dirtyalloc == nil {
        buckets = newarray(t.bucket, int(nbuckets))
    } else {
        // dirtyalloc was previously generated by
        // the above newarray(t.bucket, int(nbuckets))
        // but may not be empty.
        buckets = dirtyalloc
        size := t.bucket.size * nbuckets
        if t.bucket.ptrdata != 0 {
            memclrHasPointers(buckets, size)
        } else {
            memclrNoHeapPointers(buckets, size)
        }
    }

    if base != nbuckets {
        // We preallocated some overflow buckets.
        // To keep the overhead of tracking these overflow buckets to a minimum,
        // we use the convention that if a preallocated overflow bucket's overflow
        // pointer is nil, then there are more available by bumping the pointer.
        // We need a safe non-nil pointer for the last overflow bucket; just use buckets.
        // æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š:
        // å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ
        // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
        // å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶
        last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶
        last.setoverflow(t, (*bmap)(buckets)) // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶
    }
    return buckets, nextOverflow
}
ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"ğŸ‘¨ğŸ»â€ğŸ’»æŠ€æœ¯","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang-mapçš„æ“ä½œ","item":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang-mapçš„æ“ä½œ","name":"Golang-mapçš„æ“ä½œ","description":"åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•\n// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚ // å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚ // å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚ // å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket func makemap(t *maptype, hint int, h *hmap) *hmap { // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å° mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­ if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B \u0026lt; hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç° if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼ h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u0026lt;\u0026lt;b is the minimum number of buckets to allocate. // dirtyalloc should either be nil or a bucket array previously // allocated by makeBucketArray with the same t and b parameters. // If dirtyalloc is nil a new backing array will be alloced and // otherwise dirtyalloc will be cleared and reused as backing array. // ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„ // 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼ // dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„ // å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚ func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { base := bucketShift(b) // base = 2^b nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. // å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€ // å¯¹äºb\u0026gt;4ï¼ˆæ¡¶çš„æ•°é‡\u0026gt; 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚ if b \u0026gt;= 4 { // åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡ nbuckets += bucketShift(b - 4) // æ€»å¤§å° sz := t.bucket.size * nbuckets // é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å° up := roundupsize(sz) if up != sz { // å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets nbuckets = up / t.bucket.size } } if dirtyalloc == nil { buckets = newarray(t.bucket, int(nbuckets)) } else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.ptrdata != 0 { memclrHasPointers(buckets, size) } else { memclrNoHeapPointers(buckets, size) } } if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket\u0026#39;s overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. // æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š: // å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶ // å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­ nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) // æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶ last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) // æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶ last.setoverflow(t, (*bmap)(buckets)) // æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶ } return buckets, nextOverflow } ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚\n","keywords":["golang","map","hashmap","æºç è§£æ"],"articleBody":"åˆ›å»º map åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•\n// ä¸æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int) // æŒ‡å®šmapé•¿åº¦ ageMp := make(map[string]int, 8) // ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic var ageMp map[string]int é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•\n// makemap implements Go map creation for make(map[k]v, hint). // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If h.buckets != nil, bucket pointed to can be used as the first bucket. // ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚ // å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚ // å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚ // å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket func makemap(t *maptype, hint int, h *hmap) *hmap { // è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å° mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u003e maxAlloc { hint = 0 } // åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­ if h == nil { h = new(hmap) } h.hash0 = fastrand() // Find the size parameter B which will hold the requested # of elements. // For hint \u003c 0 overLoadFactor returns false since hint \u003c bucketCnt. // é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B \u003c hint B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. // å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç° if h.B != 0 { var nextOverflow *bmap h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) // æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼ h.extra.nextOverflow = nextOverflow } } return h } // makeBucketArray initializes a backing array for map buckets. // 1\u003c","wordCount":"2376","inLanguage":"zh","datePublished":"2022-12-30T10:49:41+08:00","dateModified":"2022-12-30T10:49:41+08:00","author":[{"@type":"Person","name":"å£¹æ¬¡å¿ƒ"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/"},"publisher":{"@type":"Organization","name":"æ¡æœˆæ‹…é£","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="æ¡æœˆæ‹…é£ (Alt + H)">æ¡æœˆæ‹…é£</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=æ ‡ç­¾ğŸ·ï¸><span>æ ‡ç­¾ğŸ·ï¸</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/tech/>ğŸ‘¨ğŸ»â€ğŸ’»æŠ€æœ¯</a></div><h1 class=post-title>Golang-mapçš„æ“ä½œ</h1><div class=post-meta><span title='2022-12-30 10:49:41 +0800 +0800'>2022-12-30</span>&nbsp;Â·&nbsp;å£¹æ¬¡å¿ƒ</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>ç›®å½•</span></summary><div class=inner><ul><li><a href=#%e5%88%9b%e5%bb%ba-map aria-label="åˆ›å»º map">åˆ›å»º map</a></li><li><a href=#map-%e7%9a%84%e8%af%bb%e5%8f%96 aria-label="map çš„è¯»å–">map çš„è¯»å–</a></li><li><a href=#map-%e5%86%99%e5%85%a5 aria-label="map å†™å…¥">map å†™å…¥</a></li><li><a href=#map-%e6%89%a9%e5%ae%b9 aria-label="map æ‰©å®¹">map æ‰©å®¹</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=åˆ›å»º-map>åˆ›å»º map<a hidden class=anchor aria-hidden=true href=#åˆ›å»º-map>#</a></h3><p>åˆ›å»º map çš„è¯­æ³•å¾ˆç®€å•</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// ä¸æŒ‡å®šmapé•¿åº¦</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ageMp</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// æŒ‡å®šmapé•¿åº¦</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>ageMp</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>, <span style=color:#d19a66>8</span>)
</span></span><span style=display:flex><span><span style=color:#7f848e>// ageMp ä¸º nilï¼Œä¸èƒ½å‘å…¶æ·»åŠ å…ƒç´ ï¼Œä¼šç›´æ¥panic</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>var</span> <span style=color:#e06c75>ageMp</span> <span style=color:#c678dd>map</span>[<span style=color:#e5c07b>string</span>]<span style=color:#e5c07b>int</span>
</span></span></code></pre></div><p>é€šè¿‡æ±‡ç¼–è¯­è¨€ï¼Œæˆ‘ä»¬èƒ½å¤Ÿè·Ÿè¸ªåˆ° map çš„åˆ›å»ºæœ€ç»ˆä¼šè°ƒç”¨ runtime.makemap æ–¹æ³•</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// makemap implements Go map creation for make(map[k]v, hint).</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If the compiler has determined that the map or the first bucket</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// can be created on the stack, h and/or bucket may be non-nil.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If h != nil, the map can be created directly in h.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// ç¿»è¯‘ï¼šmakemapå®ç°äº†make(map[k]v, hint)è¿™ç§å½¢å¼è¯­æ³•çš„Go mapåˆ›å»ºã€‚</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// å¦‚æœç¼–è¯‘å™¨å·²ç»ç¡®å®šè¯¥mapæˆ–è€…ç¬¬ä¸€ä¸ªbucketèƒ½å¤Ÿåœ¨è¿™ä¸ªæ ˆä¸Šåˆ›å»ºï¼Œé‚£ä¹ˆhå’Œ(æˆ–)bucketå¯èƒ½ä¸ºénilã€‚</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// å¦‚æœhä¸æ˜¯nilï¼Œé‚£ä¹ˆè¯¥mapèƒ½ç›´æ¥åˆ›å»ºåœ¨è¿™ä¸ªhä¸Šã€‚</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// å¦‚æœh.bucketsä¸æ˜¯nil, åˆ™è¢«æŒ‡å‘çš„bucketèƒ½è¢«ç”¨æ¥åšç¬¬ä¸€ä¸ªbucket</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>makemap</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>hint</span> <span style=color:#e5c07b>int</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>) <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span> {
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// è®¡ç®—æŒ‡å®šçš„å¤§å°æ‰€éœ€è¦çš„å†…å®¹æ˜¯å¦è¶…å‡ºå‡ºç³»ç»Ÿå…è®¸çš„æœ€å¤§åˆ†é…å¤§å°</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>mem</span>, <span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>math</span>.<span style=color:#61afef;font-weight:700>MulUintptr</span>(<span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>hint</span>), <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>mem</span> &gt; <span style=color:#e06c75>maxAlloc</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>hint</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// åˆå§‹åŒ–hmapï¼Œå¹¶æŒ‡å®šéšæœºç§å­</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>hmap</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span> = <span style=color:#61afef;font-weight:700>fastrand</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Find the size parameter B which will hold the requested # of elements.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// é€šè¿‡overLoadFactor(hint, B)å‡½æ•°æ‰¾åˆ°ä¸€ä¸ªèƒ½è£…ä¸‹æŒ‡å®šmapå¤§å°ä¸ªå…ƒç´ ä¸ªæ•°çš„æœ€å°Bï¼Œè¦æ»¡è¶³ è£…è½½å› å­*2^B &lt; hint</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>B</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#d19a66>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> <span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>hint</span>, <span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>B</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> = <span style=color:#e06c75>B</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// allocate initial hash table</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// if B == 0, the buckets field is allocated lazily later (in mapassign)</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If hint is large zeroing this memory could take a while.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å¼€å§‹å¯¹hash tableè¿›è¡Œåˆå§‹åŒ–ã€‚å¦‚æœB==0åˆ™buckets è¿›è¡Œæ‡’åˆå§‹åŒ–æ“ä½œï¼ˆèµ‹å€¼çš„æ—¶å€™æ‰è¿›è¡Œåˆå§‹åŒ–ï¼‰ï¼Œå¦‚æœBå€¼ç‰¹åˆ«å¤§ï¼Œåˆ™åˆå§‹åŒ–éœ€è¦ä¸€æ®µæ—¶é—´ï¼Œä¸»è¦é€šè¿‡ makeBucketArray() å‡½æ•°å®ç°</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>var</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>nextOverflow</span> = <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>, <span style=color:#e5c07b>nil</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>mapextra</span>)
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// æº¢å‡ºæ¡¶åœ°å€èµ‹å€¼</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>nextOverflow</span> = <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>h</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// makeBucketArray initializes a backing array for map buckets.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 1&lt;&lt;b is the minimum number of buckets to allocate.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// dirtyalloc should either be nil or a bucket array previously</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// allocated by makeBucketArray with the same t and b parameters.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// If dirtyalloc is nil a new backing array will be alloced and</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// otherwise dirtyalloc will be cleared and reused as backing array.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// ç¿»è¯‘ï¼šmakeBucketArrayä¸ºmap bucketsåˆå§‹åŒ–ä¸€ä¸ªå¤‡ç”¨æ•°ç»„</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// 2^bæ˜¯è¯¥bucketsé•¿åº¦çš„æœ€å°å€¼</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// dirtyallocä¹‹å‰åº”è¯¥æ˜¯nilæˆ–è€…bucketæ•°ç»„</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// å¦‚æœdirtyalloc ä¸ºnilï¼Œå°†åˆ†é…ä¸€ä¸ªæ–°çš„åå¤‡æ•°ç»„ï¼Œå¦åˆ™å°†æ¸…é™¤dirtyalloc å¹¶ä½œä¸ºåå¤‡æ•°ç»„é‡ç”¨ã€‚</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>b</span> <span style=color:#e5c07b>uint8</span>, <span style=color:#e06c75>dirtyalloc</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) (<span style=color:#e06c75>buckets</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>, <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>base</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>bucketShift</span>(<span style=color:#e06c75>b</span>) <span style=color:#7f848e>// base = 2^b</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>nbuckets</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>base</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// For small b, overflow buckets are unlikely.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Avoid the overhead of the calculation.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// å¯¹äºå°çš„bï¼Œä¸å¤ªå¯èƒ½ä¼šéœ€è¦æº¢å‡ºæ¡¶ï¼Œå¯ä»¥é¿å…è¿™éƒ¨åˆ†è®¡ç®—å¼€é”€</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// å¯¹äºb&gt;4ï¼ˆæ¡¶çš„æ•°é‡&gt; 2^4ï¼‰çš„è¯ï¼Œåˆ™éœ€è¦åˆ›å»º2^(b-4)ä¸ªæº¢å‡ºæ¡¶ã€‚</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span> <span style=color:#56b6c2>&gt;=</span> <span style=color:#d19a66>4</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// åŠ ä¸Šæº¢å‡ºæ¡¶çš„æ•°é‡</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>nbuckets</span> <span style=color:#56b6c2>+=</span> <span style=color:#61afef;font-weight:700>bucketShift</span>(<span style=color:#e06c75>b</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>4</span>)
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// æ€»å¤§å°</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>sz</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>nbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// é’ˆå¯¹æ‰€éœ€è¦çš„å†…å­˜å¤§å°ï¼Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>up</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>roundupsize</span>(<span style=color:#e06c75>sz</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>up</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>sz</span> {
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å¦‚æœæ€»å¤§å°å’Œmallocgcå°†åˆ†é…çš„å†…å­˜å—å¤§å°ä¸åŒï¼Œä»¥mallocgcåˆ†é…çš„ä¸ºå‡†ï¼Œè®¡ç®—nbuckets</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>nbuckets</span> = <span style=color:#e06c75>up</span> <span style=color:#56b6c2>/</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>dirtyalloc</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>buckets</span> = <span style=color:#61afef;font-weight:700>newarray</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>, <span style=color:#e5c07b>int</span>(<span style=color:#e06c75>nbuckets</span>))
</span></span><span style=display:flex><span>    } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// dirtyalloc was previously generated by</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// the above newarray(t.bucket, int(nbuckets))</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// but may not be empty.</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>buckets</span> = <span style=color:#e06c75>dirtyalloc</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>size</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>size</span> <span style=color:#56b6c2>*</span> <span style=color:#e06c75>nbuckets</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>ptrdata</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrHasPointers</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>        } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrNoHeapPointers</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>base</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>nbuckets</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// We preallocated some overflow buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// To keep the overhead of tracking these overflow buckets to a minimum,</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// we use the convention that if a preallocated overflow bucket&#39;s overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// pointer is nil, then there are more available by bumping the pointer.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// æˆ‘ä»¬æå‰åˆ†é…äº†ä¸€äº›æº¢å‡ºæ¡¶ï¼Œä¸ºäº†ä½¿å¾—è¿½è¸ªæº¢å‡ºæ¡¶çš„å¼€é”€æœ€å°ï¼Œæˆ‘ä»¬è¿™æ ·çº¦å®š:</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// å¦‚æœæº¢å‡ºæ¡¶çš„overflowæŒ‡é’ˆä¸ºnilï¼Œé‚£ä¹ˆä»£è¡¨è¿˜æœ‰ç©ºé—´åœ¨å‡ºç°å“ˆå¸Œç¢°æ’æ—¶ä½¿ç”¨ï¼Œ</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowéœ€è¦æŒ‡å‘ä¸€ä¸ªå®‰å…¨çš„éç©ºæŒ‡é’ˆï¼Œè¿™é‡ŒæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// å…·ä½“çš„ç”¨å¤„åœ¨mapå†™å…¥æ—¶ï¼Œéœ€è¦åˆ›å»ºæº¢å‡ºæ¡¶æ—¶ä¼šç”¨åˆ°ï¼Œå…·ä½“åœ¨newoverflowå‡½æ•°ä¸­</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>nextOverflow</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>base</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))) <span style=color:#7f848e>// æŒ‡å‘ç¬¬ä¸€ä¸ªæº¢å‡ºæ¡¶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>last</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>nbuckets</span><span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))) <span style=color:#7f848e>// æŒ‡å‘æœ€åä¸€ä¸ªæº¢å‡ºæ¡¶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>last</span>.<span style=color:#61afef;font-weight:700>setoverflow</span>(<span style=color:#e06c75>t</span>, (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#e06c75>buckets</span>)) <span style=color:#7f848e>// æº¢å‡ºæ¡¶çš„æœ€åä¸€ä¸ªæ¡¶çš„overflowæŒ‡å‘äº†bucketsçš„ç¬¬ä¸€ä¸ªæ¡¶</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>ä»ä¸Šé¢ä»£ç å¯ä»¥å¾—çŸ¥ï¼Œ2^B å¹¶ä¸ç­‰äº buckets çš„å¤§å°ï¼Œå®ƒåªæ˜¯åˆ›å»º buckets æ—¶çš„ base éƒ¨åˆ†ï¼Œåœ¨è¯¥éƒ¨åˆ†åï¼Œè¿˜æœ‰æº¢å‡ºæ¡¶ã€‚æ‰€ä»¥æ­£å¸¸æ¡¶å’Œæº¢å‡ºæ¡¶åœ¨å†…å­˜ä¸Šçš„åˆ†å¸ƒæ˜¯è¿ç»­çš„ï¼Œæº¢å‡ºæ¡¶çš„æŒ‡é’ˆè®°å½•åœ¨äº† hmap çš„ extra å­—æ®µä¸­ã€‚</p><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202201182254581.jpeg alt=æ‰‹ç»˜å›¾></p><h3 id=map-çš„è¯»å–>map çš„è¯»å–<a hidden class=anchor aria-hidden=true href=#map-çš„è¯»å–>#</a></h3><p>å¯¹äº map çš„è¯»å–æ“ä½œï¼Œæœ€ç»ˆæ˜¯è°ƒç”¨äº†å‡½æ•° <code>runtime.mapaccess1()</code>å’Œ <code>runtime.mapaccess2()</code> ã€‚ä¸¤è€…çš„å”¯ä¸€åŒºåˆ«å°±æ˜¯è¿”å›å€¼ä¸ä¸€æ ·ï¼Œ<code>runtime.mapaccess1()</code> è¿”å›çš„æ˜¯ä¸€ä¸ªå€¼ï¼Œ<code>runtime.mapaccess2()</code> è¿”å›çš„æ˜¯ä¸¤ä¸ªå€¼ï¼Œç¬¬äºŒä¸ªå€¼è¡¨ç¤º key æ˜¯å¦åœ¨ map ä¸­å­˜åœ¨ã€‚å³æˆ‘ä»¬å¸¸ç”¨çš„ä¸¤ç§ map å–å€¼æ–¹æ³•ã€‚</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>v</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ageMap</span>[<span style=color:#98c379>&#34;yicixin&#34;</span>]
</span></span><span style=display:flex><span><span style=color:#e06c75>v</span>, <span style=color:#e06c75>ok</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>ageMap</span>[<span style=color:#98c379>&#34;yicixin&#34;</span>]
</span></span></code></pre></div><p>æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦ä»‹ç»<code>runtime.mapaccess1()</code>,</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// it will return a reference to the zero object for the elem type if</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// the key is not in the map.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// NOTE: The returned pointer may keep the whole map live, so don&#39;t</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// hold onto it for very long.</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// mapaccess1è¿”å›æŒ‡å‘h[key]çš„æŒ‡é’ˆï¼Œæ°¸è¿œä¸ä¼šè¿”å›nilï¼Œå¦‚æœkeyä¸å­˜åœ¨ï¼Œå°±ä¼šè¿”å›å…ƒç´ å¯¹åº”ç±»å‹çš„ç©ºå€¼ã€‚</span>
</span></span><span style=display:flex><span><span style=color:#7f848e>// æ³¨æ„ï¼šè¿”å›çš„æŒ‡é’ˆå¯èƒ½ä¼šä½¿å¾—æ•´ä¸ªmapå¤„äºæ´»åŠ¨çŠ¶æ€ï¼Œæ‰€ä»¥ä¸è¦é•¿æ—¶é—´æŒæœ‰å®ƒ</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>mapaccess1</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>raceenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>callerpc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#e06c75>pc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>funcPC</span>(<span style=color:#e06c75>mapaccess1</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>racereadpc</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>h</span>), <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>raceReadObjectPC</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>key</span>, <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>msanenabled</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>msanread</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// åˆ¤æ–­hæ˜¯å¦ä¸ºnilæˆ–è€…h.countå€¼æ˜¯å¦ä¸º0ï¼Œå¦‚æœhä¸ºnilåˆ™è¡¨ç¤ºæœªåˆå§‹åŒ–ï¼Œåˆ™å¯èƒ½panicï¼Œå¦‚æœh.count=0,åˆ™è¡¨ç¤ºmapä¸ºç©ºï¼Œåˆ™ç›´æ¥è¿”å›ä¸€ä¸ªzeroå€¼ã€‚</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hashMightPanic</span>() {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#d19a66>0</span>) <span style=color:#7f848e>// see issue 23734</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>zeroVal</span>[<span style=color:#d19a66>0</span>])
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è€ƒè™‘æ˜¯å¦å¤„äºå¹¶å‘è¯»å†™çŠ¶æ€ï¼Œå¦åˆ™äº§ç”Ÿpanic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map read and map write&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// æ ¹æ®é”®keyè®¡ç®—hashå€¼</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è®¡ç®—ä½Bä½çš„æ©ç bucketMask(h.B)ï¼Œæ¯”å¦‚ B=5ï¼Œé‚£ m å°±æ˜¯31ï¼Œä½äº”ä½äºŒè¿›åˆ¶æ˜¯å…¨1</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>m</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>bucketMask</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è®¡ç®—å½“å‰bucketçš„åœ°å€</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>m</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// æ ¹æ®h.oldbucketsåˆ¤æ–­æ˜¯å¦å¤„äºæ‰©å®¹ä¸­ï¼Œå¦‚æœä¸æ˜¯nilåˆ™è¡¨ç¤ºå½“å‰mapæ­£å¤„äºæ‰©å®¹çŠ¶æ€ä¸­</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>c</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>; <span style=color:#e06c75>c</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// There used to be half as many buckets; mask down one more power of two.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>m</span> <span style=color:#56b6c2>&gt;&gt;=</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>oldb</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>c</span>, (<span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>m</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>evacuated</span>(<span style=color:#e06c75>oldb</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>b</span> = <span style=color:#e06c75>oldb</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è®¡ç®—tophashï¼Œå³é«˜å…«ä½</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// çœŸæ­£å¼€å§‹æŸ¥æ‰¾key,å¤–å±‚foræ˜¯å¾ªç¯bucketåŠæº¢å‡ºæ¡¶overflowï¼Œå†…å±‚foræ˜¯å¾ªç¯æ¡¶å†…çš„8ä¸ªslot</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> ; <span style=color:#e06c75>b</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span>; <span style=color:#e06c75>b</span> = <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>) {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#d19a66>0</span>); <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>==</span> <span style=color:#e06c75>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>break</span> <span style=color:#e06c75>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>e</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>e</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>return</span> <span style=color:#e06c75>e</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>zeroVal</span>[<span style=color:#d19a66>0</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>key çš„å®šä½å…¬å¼:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span></code></pre></div><p>value çš„å®šä½å…¬å¼:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span></code></pre></div><p>å…¶ä¸­ dataOffset è¡¨ç¤º ç¬¬ä¸€ä¸ª key ç›¸å¯¹äº bmap çš„åç§»é‡ï¼Œç»“æ„ä½“å¦‚ä¸‹</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#e06c75>dataOffset</span> = <span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Offsetof</span>(<span style=color:#c678dd>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>b</span> <span style=color:#e06c75>bmap</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>v</span> <span style=color:#e5c07b>int64</span>
</span></span><span style=display:flex><span>    }{}.<span style=color:#e06c75>v</span>)
</span></span></code></pre></div><p>æ‰€ä»¥é”®çš„åœ°å€=å½“å‰ bucket çš„èµ·å§‹ä½ç½®(<code>unsafe.Pointer(b)</code>) + ç¬¬ä¸€ä¸ª key çš„åç§»é‡(<code>dataOffset</code>)+å½“å‰ slot ç´¢å¼•å€¼(<code>i</code>) * æ¯ä¸ªé”®çš„å¤§å°(<code>uintptr(t.keysize)</code>)</p><p>è€Œå¯¹äºå€¼æ¥è¯´ï¼Œç”±äº bmap.values åœ¨ b.map.keys åé¢ï¼Œæ‰€ä»¥è¦å…ˆå°† 8 ä¸ªé”®çš„åœ°å€å…¨éƒ¨è®¡ç®—ä¸Šæ‰è¡Œï¼ŒåŒæ ·å€¼ç±»å‹ä¹Ÿæœ‰è‡ªå·±çš„å¤§å° <code>t.elemsize</code></p><p>bucket çš„å‡ ç§çŠ¶æ€ç </p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#e06c75>emptyRest</span>      = <span style=color:#d19a66>0</span> <span style=color:#7f848e>// å½“å‰cellä¸ºç©º, å¹¶ä¸”å®ƒåé¢çš„æ‰€æœ‰cellä¹Ÿä¸ºç©º, åŒ…æ‹¬æº¢å‡ºæ¡¶overflow</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>emptyOne</span>       = <span style=color:#d19a66>1</span> <span style=color:#7f848e>// å½“å‰cellä¸ºç©º</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedX</span>     = <span style=color:#d19a66>2</span> <span style=color:#7f848e>// key/elem is valid.  Entry has been evacuated to first half of larger table.</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedY</span>     = <span style=color:#d19a66>3</span> <span style=color:#7f848e>// æ‰©å®¹ç›¸å…³ï¼Œç¬¬äºŒéƒ¨åˆ†è¿ç§»å®Œæ¯•ã€‚</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>evacuatedEmpty</span> = <span style=color:#d19a66>4</span> <span style=color:#7f848e>// å½“å‰cellä¸ºç©ºï¼Œä¸”è¿ç§»å®Œæˆã€‚</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>minTopHash</span>     = <span style=color:#d19a66>5</span> <span style=color:#7f848e>// tophashæœ€å°å€¼ï¼Œå¦‚æœåœ¨è°ƒç”¨ tophash(hash)æ—¶ï¼Œè®¡ç®—å‡ºçš„å€¼å°äºæ­¤å€¼ï¼Œåˆ™ä¼šåŠ ä¸Šæ­¤å€¼</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// tophash calculates the tophash value for hash.</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span> <span style=color:#e5c07b>uintptr</span>) <span style=color:#e5c07b>uint8</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#e06c75>hash</span> <span style=color:#56b6c2>&gt;&gt;</span> (<span style=color:#e06c75>sys</span>.<span style=color:#e06c75>PtrSize</span><span style=color:#56b6c2>*</span><span style=color:#d19a66>8</span> <span style=color:#56b6c2>-</span> <span style=color:#d19a66>8</span>))
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>top</span> &lt; <span style=color:#e06c75>minTopHash</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>top</span> <span style=color:#56b6c2>+=</span> <span style=color:#e06c75>minTopHash</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#c678dd>return</span> <span style=color:#e06c75>top</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><h3 id=map-å†™å…¥>map å†™å…¥<a hidden class=anchor aria-hidden=true href=#map-å†™å…¥>#</a></h3><p>ä¸ map å†™å…¥ç›¸å…³çš„ runtime å‡½æ•°æ˜¯<code>runtime.mapassign()</code>ï¼Œå¯¹äºæŸäº› key ç±»å‹ï¼Œruntime è¿˜æœ‰ç‰¹å®šçš„å‡½æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_faststr</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>s</span> <span style=color:#e5c07b>string</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_fast64</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e5c07b>uint64</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span><span style=display:flex><span><span style=color:#61afef;font-weight:700>mapassign_fast32</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e5c07b>uint32</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>
</span></span></code></pre></div><p>è¿™æ˜¯<code>runtime.mapassign</code>å‡½æ•°ï¼š</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#7f848e>// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span>
</span></span><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>mapassign</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>key</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>) <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ç©ºmapå†™å…¥ä¼šè§¦å‘panic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e5c07b>panic</span>(<span style=color:#61afef;font-weight:700>plainError</span>(<span style=color:#98c379>&#34;assignment to entry in nil map&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// raceenabled-æ˜¯å¦å¯ç”¨æ•°æ®ç«äº‰æ£€æµ‹</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>raceenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>callerpc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>getcallerpc</span>()
</span></span><span style=display:flex><span>        <span style=color:#e06c75>pc</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>funcPC</span>(<span style=color:#e06c75>mapassign</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>racewritepc</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>h</span>), <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>raceReadObjectPC</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>key</span>, <span style=color:#e06c75>callerpc</span>, <span style=color:#e06c75>pc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>msanenabled</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>msanread</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#e06c75>size</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å¦‚æœå¹¶å‘å†™å…¥ä¼šè§¦å‘panic</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è®¡ç®—hashå€¼</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>key</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Set hashWriting after calling t.hasher, since t.hasher may panic,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// in which case we have not actually done a write.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// è®¾ç½®å†™å…¥æ ‡å¿—ä½</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> ^= <span style=color:#e06c75>hashWriting</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> = <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>) <span style=color:#7f848e>// newarray(t.bucket, 1)</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>again</span>:
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å®šä½bucket</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>bucket</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>&amp;</span> <span style=color:#61afef;font-weight:700>bucketMask</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>growWork</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>bucket</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>bucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>*</span><span style=color:#e5c07b>uint8</span> <span style=color:#7f848e>// tophashçš„ä½ç½®</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>insertk</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> <span style=color:#7f848e>// keyçš„åœ°å€</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>elem</span> <span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span> <span style=color:#7f848e>// valçš„åœ°å€</span>
</span></span><span style=display:flex><span><span style=color:#e06c75>bucketloop</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#d19a66>0</span>); <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>top</span> {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#61afef;font-weight:700>isEmpty</span>(<span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]) <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>inserti</span> = <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>insertk</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// å½“å‰cellä¸ºç©º, å¹¶ä¸”å®ƒåé¢çš„æ‰€æœ‰cellä¹Ÿä¸ºç©º, åŒ…æ‹¬æº¢å‡ºæ¡¶overflow, å¯ä»¥é€€å‡ºå¾ªç¯äº†</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] <span style=color:#56b6c2>==</span> <span style=color:#e06c75>emptyRest</span> {
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>break</span> <span style=color:#e06c75>bucketloop</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>              <span style=color:#7f848e>// b.tophash[i] == top</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> !<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>) {
</span></span><span style=display:flex><span>                <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// already have a mapping for key. Update it.</span>
</span></span><span style=display:flex><span>            <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>needkeyupdate</span>() {
</span></span><span style=display:flex><span>                <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>k</span>, <span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)<span style=color:#56b6c2>+</span><span style=color:#e06c75>i</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>goto</span> <span style=color:#e06c75>done</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// å¦‚æœè¿˜æœ‰æº¢å‡ºæ¡¶ï¼Œç»§ç»­æŸ¥è¯¢æº¢å‡ºæ¡¶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>ovf</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>ovf</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#c678dd>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>b</span> = <span style=color:#e06c75>ovf</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Did not find mapping for key. Allocate new cell &amp; add entry.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If we hit the max load factor or we have too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// and we&#39;re not already in the middle of growing, start growing.</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å¦‚æœè´Ÿè½½å› å­åˆ°äº†æœ€å¤§æˆ–è€…æœ‰å¤ªå¤šçš„æº¢å‡ºæ¡¶ï¼Œå¹¶ä¸”ä¸åœ¨æ‰©å®¹ä¸­ï¼Œå¼€å§‹æ‰©å®¹</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() <span style=color:#56b6c2>&amp;&amp;</span> (<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) <span style=color:#56b6c2>||</span> <span style=color:#61afef;font-weight:700>tooManyOverflowBuckets</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>goto</span> <span style=color:#e06c75>again</span> <span style=color:#7f848e>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>inserti</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// The current bucket and all the overflow buckets connected to it are full, allocate a new one.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// å½“å‰bucketå’Œæ‰€æœ‰çš„æº¢å‡ºæ¡¶éƒ½æ»¡äº†ï¼Œåˆ›å»ºæ–°çš„æº¢å‡ºæ¡¶</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>newb</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>newoverflow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>inserti</span> = <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>newb</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#d19a66>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#e06c75>insertk</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>newb</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>elem</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>insertk</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// store new key/elem at insert position</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>kmem</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>insertk</span>) = <span style=color:#e06c75>kmem</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>insertk</span> = <span style=color:#e06c75>kmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>vmem</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>newobject</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elem</span>)
</span></span><span style=display:flex><span>        <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>elem</span>) = <span style=color:#e06c75>vmem</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å†™å…¥key</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>insertk</span>, <span style=color:#e06c75>key</span>)
</span></span><span style=display:flex><span>    <span style=color:#56b6c2>*</span><span style=color:#e06c75>inserti</span> = <span style=color:#e06c75>top</span>
</span></span><span style=display:flex><span>      <span style=color:#7f848e>// å“ˆå¸Œå…ƒç´ æ•°é‡+1</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e06c75>done</span>:
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>hashWriting</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;concurrent map writes&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>&amp;^=</span> <span style=color:#e06c75>hashWriting</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>elem</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>elem</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>return</span> <span style=color:#e06c75>elem</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>åœ¨<code>mapassign</code>ä¸­å¹¶æ²¡æœ‰å¯¹ val è¿›è¡Œç›´æ¥èµ‹å€¼ï¼Œè€Œæ˜¯è¿”å›äº† val çš„åœ°å€ï¼ŒçœŸæ­£çš„èµ‹å€¼æ“ä½œåœ¨å“ªå‘¢ï¼Ÿ</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#c678dd>var</span> <span style=color:#e06c75>a</span> = <span style=color:#e5c07b>make</span>(<span style=color:#c678dd>map</span>[<span style=color:#e5c07b>int</span>]<span style=color:#e5c07b>int</span>, <span style=color:#d19a66>7</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#d19a66>1000</span>; <span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>a</span>[<span style=color:#e06c75>i</span>] = <span style=color:#d19a66>99999</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>çœ‹çœ‹è¿™æ®µä»£ç å¯¹åº”çš„æ±‡ç¼–:</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#d19a66>0x003f</span> <span style=color:#d19a66>00063</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>DX</span>, (<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// ç¬¬ä¸€ä¸ªå‚æ•°</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0043</span> <span style=color:#d19a66>00067</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>AX</span>, <span style=color:#d19a66>8</span>(<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// ç¬¬äºŒä¸ªå‚æ•°</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0048</span> <span style=color:#d19a66>00072</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#e06c75>CX</span>, <span style=color:#d19a66>16</span>(<span style=color:#e06c75>SP</span>) <span style=color:#7f848e>// ç¬¬ä¸‰ä¸ªå‚æ•°</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x004d</span> <span style=color:#d19a66>00077</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>PCDATA</span>    $<span style=color:#d19a66>0</span>, $<span style=color:#d19a66>1</span> <span style=color:#7f848e>// GC ç›¸å…³</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x004d</span> <span style=color:#d19a66>00077</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>CALL</span>    <span style=color:#e06c75>runtime</span>.<span style=color:#61afef;font-weight:700>mapassign_fast64</span>(<span style=color:#e06c75>SB</span>) <span style=color:#7f848e>// è°ƒç”¨å‡½æ•°</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0052</span> <span style=color:#d19a66>000</span><span style=color:#d19a66>82</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    <span style=color:#d19a66>24</span>(<span style=color:#e06c75>SP</span>), <span style=color:#e06c75>AX</span> <span style=color:#7f848e>// è¿”å›å€¼ï¼Œå³ value åº”è¯¥å­˜æ”¾çš„å†…å­˜åœ°å€</span>
</span></span><span style=display:flex><span>    <span style=color:#d19a66>0x0057</span> <span style=color:#d19a66>000</span><span style=color:#d19a66>87</span> (<span style=color:#e06c75>m</span>.<span style=color:#c678dd>go</span>:<span style=color:#d19a66>9</span>)    <span style=color:#e06c75>MOVQ</span>    $<span style=color:#d19a66>99999</span>, (<span style=color:#e06c75>AX</span>) <span style=color:#7f848e>// æŠŠ 99999 æ”¾å…¥è¯¥åœ°å€ä¸­</span>
</span></span></code></pre></div><h3 id=map-æ‰©å®¹>map æ‰©å®¹<a hidden class=anchor aria-hidden=true href=#map-æ‰©å®¹>#</a></h3><p>åœ¨ä¸Šæ–‡ä¸­çš„ map å†™å…¥æ“ä½œè¿‡ç¨‹ä¸­ï¼Œæœ‰å…³äº map æ‰©å®¹çš„ä»£ç ï¼Œåœ¨è¿™ä¸€éƒ¨åˆ†ç»†è°ˆ map æ‰©å®¹æœºåˆ¶</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() <span style=color:#56b6c2>&amp;&amp;</span> (<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) <span style=color:#56b6c2>||</span> <span style=color:#61afef;font-weight:700>tooManyOverflowBuckets</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>)
</span></span><span style=display:flex><span>        <span style=color:#c678dd>goto</span> <span style=color:#e06c75>again</span> <span style=color:#7f848e>// Growing the table invalidates everything, so try again</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>åœ¨å†™å…¥æ—¶ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¼šè§¦å‘æ‰©å®¹:</p><ul><li>è´Ÿè½½å› å­è¶…è¿‡ä¸Šé™ï¼Œå³å…ƒç´ ä¸ªæ•° >= æ¡¶ä¸ªæ•° * 6.5ï¼Œè¿™æ—¶å€™è¯´æ˜å¤§éƒ¨åˆ†çš„æ¡¶å¯èƒ½éƒ½å¿«æ»¡äº†ï¼Œå¦‚æœæ’å…¥æ–°å…ƒç´ ï¼Œæœ‰å¤§æ¦‚ç‡éœ€è¦æŒ‚åœ¨ overflow çš„æ¡¶ä¸Šã€‚</li><li>å¤ªå¤šæº¢å‡ºæ¡¶ï¼Œä»€ä¹ˆæƒ…å†µä¼šå¯¼è‡´å¤ªå¤šæº¢å‡ºæ¡¶è€Œåˆä¸è¶…è¿‡è´Ÿè½½å› å­ä¸Šçº¿å‘¢ï¼Ÿè¿™å¯èƒ½å‘ç”Ÿåœ¨æˆ‘ä»¬å¯¹ map ä¸€è¾¹æ’å…¥ï¼Œä¸€è¾¹åˆ é™¤ï¼Œå¯¼è‡´å…¶ä¸­å¾ˆå¤šæ¡¶å‡ºç°ç©ºæ´ï¼Œè™½ç„¶ä½¿ç”¨äº†å¾ˆå¤šæº¢å‡ºæ¡¶ï¼Œä½†æ˜¯æ€»å…ƒç´ ä¸ªæ•°å¹¶æ²¡æœ‰è¶…å‡ºè´Ÿè½½å› å­ä¸Šé™ã€‚è¿™æ—¶ bucket çš„ä½¿ç”¨ç‡ä¸é«˜ï¼Œå€¼å­˜å‚¨å¾—æ¯”è¾ƒç¨€ç–ï¼Œåœ¨æŸ¥æ‰¾æ—¶æ•ˆç‡ä¼šä¸‹é™ï¼Œå æ®äº†å¤§é‡å†…å­˜å´æ— ç”¨ï¼Œç­‰åŒäºå†…å­˜æ³„æ¼ã€‚</li></ul><p>æ»¡è¶³ä»»æ„æƒ…å†µä¸”ç›®å‰ä¸åœ¨æ‰©å®¹çŠ¶æ€<code>!h.growing()</code>æ—¶ï¼Œå³ä¼šè¿›è¡Œæ‰©å®¹ï¼Œmap æ‰©å®¹çš„å‡½æ•°å°±æ˜¯<code>hashGrow(t, h)</code></p><p>é’ˆå¯¹ä¸Šé¢ä¸¤ç§ä¸åŒæƒ…å†µï¼Œmap çš„æ‰©å®¹æ–¹æ³•ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ã€‚</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>hashGrow</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>) {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// If we&#39;ve hit the load factor, get bigger.</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// Otherwise, there are too many overflow buckets,</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// so keep the same number of buckets and &#34;grow&#34; laterally.</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>bigger</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uint8</span>(<span style=color:#d19a66>1</span>)
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// å¦‚æœä¸æ˜¯è´Ÿè½½å› å­è¶…å‡ºä¸Šé™ï¼Œé‚£ä¹ˆè¿›è¡Œçš„æ˜¯ä¸€æ¬¡ç­‰é‡æ‰©å®¹ï¼Œbucketçš„æ•°é‡ä¸å˜</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>overLoadFactor</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>count</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span>) {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>bigger</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// sameSizeGrowï¼Œå³ä¸ºç­‰é‡æ‰©å®¹</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>|=</span> <span style=color:#e06c75>sameSizeGrow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#e06c75>oldbuckets</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// ç­‰é‡æ‰©å®¹biggerä¸º0ï¼Œbucketæ•°ä¸å˜ã€‚å¦åˆ™biggerä¸º1ï¼Œbucketæ•°ç¿»å€</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>newbuckets</span>, <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>makeBucketArray</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>bigger</span>, <span style=color:#e5c07b>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>flags</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> <span style=color:#56b6c2>&amp;^</span> (<span style=color:#e06c75>iterator</span> | <span style=color:#e06c75>oldIterator</span>)
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iterator</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#e06c75>flags</span> <span style=color:#56b6c2>|=</span> <span style=color:#e06c75>oldIterator</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// commit the grow (atomic wrt gc)</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>B</span> <span style=color:#56b6c2>+=</span> <span style=color:#e06c75>bigger</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span> = <span style=color:#e06c75>flags</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span> = <span style=color:#e06c75>oldbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span> = <span style=color:#e06c75>newbuckets</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>    <span style=color:#e06c75>h</span>.<span style=color:#e06c75>noverflow</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// Promote current overflow buckets to the old generation.</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>oldoverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;oldoverflow is not nil&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>oldoverflow</span> = <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>overflow</span> = <span style=color:#e5c07b>nil</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>nextOverflow</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> <span style=color:#56b6c2>==</span> <span style=color:#e5c07b>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span> = <span style=color:#e5c07b>new</span>(<span style=color:#e06c75>mapextra</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#e06c75>h</span>.<span style=color:#e06c75>extra</span>.<span style=color:#e06c75>nextOverflow</span> = <span style=color:#e06c75>nextOverflow</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// the actual copying of the hash table data is done incrementally</span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// by growWork() and evacuate().</span>
</span></span><span style=display:flex><span>  <span style=color:#7f848e>// å“ˆå¸Œè¡¨æ•°æ®çš„å®é™…å¤åˆ¶æ˜¯ç”± growWork() å’Œ evacuate() é€æ­¥å®Œæˆçš„</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>growWork</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>bucket</span> <span style=color:#e5c07b>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// ç¡®ä¿æˆ‘ä»¬ç§»åŠ¨çš„ oldbucket å¯¹åº”çš„æ˜¯æˆ‘ä»¬é©¬ä¸Šå°±è¦ç”¨åˆ°çš„é‚£ä¸€ä¸ª</span>
</span></span><span style=display:flex><span>    <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>bucket</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>oldbucketmask</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// å¦‚æœè¿˜åœ¨ growing çŠ¶æ€ï¼Œå†å¤šç§»åŠ¨ä¸€ä¸ª oldbucket</span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>growing</span>() {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>h</span>, <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>é‡è¦çš„æ˜¯çœŸæ­£çš„æ•°æ®è¿ç§»éƒ¨åˆ†ï¼Œ<code>evacuate</code>å‡½æ•°ã€‚</p><div class=highlight><pre tabindex=0 style=color:#abb2bf;background-color:#282c34;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#c678dd>func</span> <span style=color:#61afef;font-weight:700>evacuate</span>(<span style=color:#e06c75>t</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>maptype</span>, <span style=color:#e06c75>h</span> <span style=color:#56b6c2>*</span><span style=color:#e06c75>hmap</span>, <span style=color:#e06c75>oldbucket</span> <span style=color:#e5c07b>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>    <span style=color:#e06c75>newbit</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>noldbuckets</span>()
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> !<span style=color:#61afef;font-weight:700>evacuated</span>(<span style=color:#e06c75>b</span>) {
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// TODO: reuse overflow buckets instead of using new ones, if there</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// is no iterator using the old buckets.  (If !oldIterator.)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// xy contains the x and y (low and high) evacuation destinations.</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// evacDstç”¨äºä¿å­˜åˆ†é…ä¸Šä¸‹æ–‡</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// xy åŒ…å«çš„æ˜¯ç§»åŠ¨çš„ç›®æ ‡</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// x è¡¨ç¤ºæ–° bucket æ•°ç»„çš„å‰(low)åŠéƒ¨åˆ†</span>
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// y è¡¨ç¤ºæ–° bucket æ•°ç»„çš„å(high)åŠéƒ¨åˆ†</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>var</span> <span style=color:#e06c75>xy</span> [<span style=color:#d19a66>2</span>]<span style=color:#e06c75>evacDst</span>
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#d19a66>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>b</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>x</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>        <span style=color:#e06c75>x</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>x</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#7f848e>// å¦‚æœæ˜¯ç­‰é‡æ‰©å®¹ï¼Œæ–°æ—§bucketæ˜¯ä¸€å¯¹ä¸€ï¼Œä¸éœ€è¦ä¸¤ä¸ªevacDstï¼Œè€Œå½“å“ˆå¸Œè¡¨çš„å®¹é‡ç¿»å€æ—¶ï¼Œæ¯ä¸ªæ—§æ¡¶çš„å…ƒç´ ä¼šéƒ½åˆ†æµåˆ°æ–°åˆ›å»ºçš„ä¸¤ä¸ªæ¡¶ä¸­</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Only calculate y pointers if we&#39;re growing bigger.</span>
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Otherwise GC can see bad pointers.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#d19a66>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>b</span> = (<span style=color:#56b6c2>*</span><span style=color:#e06c75>bmap</span>)(<span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>buckets</span>, (<span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>+</span><span style=color:#e06c75>newbit</span>)<span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>)))
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>y</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>y</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>y</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>for</span> ; <span style=color:#e06c75>b</span> <span style=color:#56b6c2>!=</span> <span style=color:#e5c07b>nil</span>; <span style=color:#e06c75>b</span> = <span style=color:#e06c75>b</span>.<span style=color:#61afef;font-weight:700>overflow</span>(<span style=color:#e06c75>t</span>) {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>k</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>e</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>            <span style=color:#c678dd>for</span> <span style=color:#e06c75>i</span> <span style=color:#56b6c2>:=</span> <span style=color:#d19a66>0</span>; <span style=color:#e06c75>i</span> &lt; <span style=color:#e06c75>bucketCnt</span>; <span style=color:#e06c75>i</span>, <span style=color:#e06c75>k</span>, <span style=color:#e06c75>e</span> = <span style=color:#e06c75>i</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span>, <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>k</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>)), <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>e</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>)) {
</span></span><span style=display:flex><span>                <span style=color:#e06c75>top</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>]
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#61afef;font-weight:700>isEmpty</span>(<span style=color:#e06c75>top</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] = <span style=color:#e06c75>evacuatedEmpty</span>
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>continue</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>top</span> &lt; <span style=color:#e06c75>minTopHash</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;bad map state&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>k2</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>k</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>k2</span> = <span style=color:#56b6c2>*</span>((<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>k2</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>var</span> <span style=color:#e06c75>useY</span> <span style=color:#e5c07b>uint8</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> !<span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>sameSizeGrow</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#7f848e>// Compute hash to make our evacuation decision (whether we need</span>
</span></span><span style=display:flex><span>                    <span style=color:#7f848e>// to send this key/elem to bucket x or bucket y).</span>
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>hash</span> <span style=color:#56b6c2>:=</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>hasher</span>(<span style=color:#e06c75>k2</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>hash0</span>))
</span></span><span style=display:flex><span>                    <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>iterator</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> <span style=color:#56b6c2>&amp;&amp;</span> !<span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>reflexivekey</span>() <span style=color:#56b6c2>&amp;&amp;</span> !<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>.<span style=color:#61afef;font-weight:700>equal</span>(<span style=color:#e06c75>k2</span>, <span style=color:#e06c75>k2</span>) {
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// If key != key (NaNs), then the hash could be (and probably</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// will be) entirely different from the old hash. Moreover,</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// it isn&#39;t reproducible. Reproducibility is required in the</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// presence of iterators, as our evacuation decision must</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// match whatever decision the iterator made.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// Fortunately, we have the freedom to send these keys either</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// way. Also, tophash is meaningless for these kinds of keys.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// We let the low bit of tophash drive the evacuation decision.</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// We recompute a new random tophash for the next level so</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// these keys will get evenly distributed across all buckets</span>
</span></span><span style=display:flex><span>                        <span style=color:#7f848e>// after multiple grows.</span>
</span></span><span style=display:flex><span>                        <span style=color:#e06c75>useY</span> = <span style=color:#e06c75>top</span> <span style=color:#56b6c2>&amp;</span> <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>                        <span style=color:#e06c75>top</span> = <span style=color:#61afef;font-weight:700>tophash</span>(<span style=color:#e06c75>hash</span>)
</span></span><span style=display:flex><span>                    } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#c678dd>if</span> <span style=color:#e06c75>hash</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>newbit</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>                            <span style=color:#e06c75>useY</span> = <span style=color:#d19a66>1</span>
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>evacuatedX</span><span style=color:#56b6c2>+</span><span style=color:#d19a66>1</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>evacuatedY</span> <span style=color:#56b6c2>||</span> <span style=color:#e06c75>evacuatedX</span>^<span style=color:#d19a66>1</span> <span style=color:#56b6c2>!=</span> <span style=color:#e06c75>evacuatedY</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>throw</span>(<span style=color:#98c379>&#34;bad evacuatedN&#34;</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>i</span>] = <span style=color:#e06c75>evacuatedX</span> <span style=color:#56b6c2>+</span> <span style=color:#e06c75>useY</span> <span style=color:#7f848e>// evacuatedX + 1 == evacuatedY</span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span> <span style=color:#56b6c2>:=</span> <span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>xy</span>[<span style=color:#e06c75>useY</span>]                 <span style=color:#7f848e>// evacuation destination</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span> <span style=color:#56b6c2>==</span> <span style=color:#e06c75>bucketCnt</span> {
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span> = <span style=color:#e06c75>h</span>.<span style=color:#61afef;font-weight:700>newoverflow</span>(<span style=color:#e06c75>t</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>)
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span> = <span style=color:#d19a66>0</span>
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>unsafe</span>.<span style=color:#61afef;font-weight:700>Pointer</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>), <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>                    <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>b</span>.<span style=color:#e06c75>tophash</span>[<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span><span style=color:#56b6c2>&amp;</span>(<span style=color:#e06c75>bucketCnt</span><span style=color:#56b6c2>-</span><span style=color:#d19a66>1</span>)] = <span style=color:#e06c75>top</span> <span style=color:#7f848e>// mask dst.i as an optimization, to avoid a bounds check</span>
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectkey</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>) = <span style=color:#e06c75>k2</span> <span style=color:#7f848e>// copy pointer</span>
</span></span><span style=display:flex><span>                } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>key</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e06c75>k</span>) <span style=color:#7f848e>// copy elem</span>
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#c678dd>if</span> <span style=color:#e06c75>t</span>.<span style=color:#61afef;font-weight:700>indirectelem</span>() {
</span></span><span style=display:flex><span>                    <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>) = <span style=color:#56b6c2>*</span>(<span style=color:#56b6c2>*</span><span style=color:#e06c75>unsafe</span>.<span style=color:#e06c75>Pointer</span>)(<span style=color:#e06c75>e</span>)
</span></span><span style=display:flex><span>                } <span style=color:#c678dd>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#61afef;font-weight:700>typedmemmove</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elem</span>, <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>, <span style=color:#e06c75>e</span>)
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>i</span><span style=color:#56b6c2>++</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// These updates might push these pointers past the end of the</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// key or elem arrays.  That&#39;s ok, as we have the overflow pointer</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// at the end of the bucket to protect against pointing past the</span>
</span></span><span style=display:flex><span>                <span style=color:#7f848e>// end of the bucket.</span>
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>k</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>keysize</span>))
</span></span><span style=display:flex><span>                <span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span> = <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>dst</span>.<span style=color:#e06c75>e</span>, <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>elemsize</span>))
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#7f848e>// Unlink the overflow buckets &amp; clear key/elem to help GC.</span>
</span></span><span style=display:flex><span>        <span style=color:#c678dd>if</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>flags</span><span style=color:#56b6c2>&amp;</span><span style=color:#e06c75>oldIterator</span> <span style=color:#56b6c2>==</span> <span style=color:#d19a66>0</span> <span style=color:#56b6c2>&amp;&amp;</span> <span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucket</span>.<span style=color:#e06c75>ptrdata</span> <span style=color:#56b6c2>!=</span> <span style=color:#d19a66>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#e06c75>b</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>h</span>.<span style=color:#e06c75>oldbuckets</span>, <span style=color:#e06c75>oldbucket</span><span style=color:#56b6c2>*</span><span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>))
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// Preserve b.tophash because the evacuation</span>
</span></span><span style=display:flex><span>            <span style=color:#7f848e>// state is maintained there.</span>
</span></span><span style=display:flex><span>            <span style=color:#e06c75>ptr</span> <span style=color:#56b6c2>:=</span> <span style=color:#61afef;font-weight:700>add</span>(<span style=color:#e06c75>b</span>, <span style=color:#e06c75>dataOffset</span>)
</span></span><span style=display:flex><span>            <span style=color:#e06c75>n</span> <span style=color:#56b6c2>:=</span> <span style=color:#e5c07b>uintptr</span>(<span style=color:#e06c75>t</span>.<span style=color:#e06c75>bucketsize</span>) <span style=color:#56b6c2>-</span> <span style=color:#e06c75>dataOffset</span>
</span></span><span style=display:flex><span>            <span style=color:#61afef;font-weight:700>memclrHasPointers</span>(<span style=color:#e06c75>ptr</span>, <span style=color:#e06c75>n</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#c678dd>if</span> <span style=color:#e06c75>oldbucket</span> <span style=color:#56b6c2>==</span> <span style=color:#e06c75>h</span>.<span style=color:#e06c75>nevacuate</span> {
</span></span><span style=display:flex><span>        <span style=color:#61afef;font-weight:700>advanceEvacuationMark</span>(<span style=color:#e06c75>h</span>, <span style=color:#e06c75>t</span>, <span style=color:#e06c75>newbit</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>Golang</a></li><li><a href=https://www.yici.xin/tags/map/>Map</a></li><li><a href=https://www.yici.xin/tags/hashmap/>Hashmap</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>æºç è§£æ</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/%E8%BD%AC%E6%8D%A2bytes%E5%92%8Cstring%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/><span class=title>Â« ä¸Šä¸€é¡µ</span><br><span>è½¬æ¢byteså’Œstringçš„æœ€ä½³å®è·µ</span>
</a><a class=next href=https://www.yici.xin/post/tech/keynote%E4%B8%AD%E8%B4%B4%E4%BB%A3%E7%A0%81/><span class=title>ä¸‹ä¸€é¡µ Â»</span><br><span>å¦‚ä½•åœ¨Keynoteä¸­è´´å‡ºå¥½çœ‹çš„ä»£ç </span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>æ¡æœˆæ‹…é£</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="å¤åˆ¶";function s(){t.innerHTML="å·²å¤åˆ¶ï¼",setTimeout(()=>{t.innerHTML="å¤åˆ¶"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
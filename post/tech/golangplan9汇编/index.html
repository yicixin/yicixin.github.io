<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang——plan9汇编 | yicixin's blog</title><meta name=keywords content="assembly,plan9,golang"><meta name=description content="基本指令 栈相关 在 plan9 汇编中，虽然存在push、pop指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作SP寄存器的位置来替换。
SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧 ... // 省略无用代码 ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧 栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。
x86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭
数据搬运 plan9 汇编中，常数以$num形式表示，可以是负数，一般为 10 进制，当然也可以用$0x123的十六进制形式。
MOVB $1, DI // 1 byte MOVW $0x10, BX // 2 bytes MOVD $1, DX // 4 bytes MOVQ $-10, AX // 8 bytes plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang——plan9汇编"><meta property="og:description" content="基本指令 栈相关 在 plan9 汇编中，虽然存在push、pop指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作SP寄存器的位置来替换。
SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧 ... // 省略无用代码 ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧 栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。
x86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭
数据搬运 plan9 汇编中，常数以$num形式表示，可以是负数，一般为 10 进制，当然也可以用$0x123的十六进制形式。
MOVB $1, DI // 1 byte MOVW $0x10, BX // 2 bytes MOVD $1, DX // 4 bytes MOVQ $-10, AX // 8 bytes plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-30T10:51:52+08:00"><meta property="article:modified_time" content="2022-12-30T10:51:52+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang——plan9汇编"><meta name=twitter:description content="基本指令 栈相关 在 plan9 汇编中，虽然存在push、pop指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作SP寄存器的位置来替换。
SUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧 ... // 省略无用代码 ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧 栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。
x86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭
数据搬运 plan9 汇编中，常数以$num形式表示，可以是负数，一般为 10 进制，当然也可以用$0x123的十六进制形式。
MOVB $1, DI // 1 byte MOVW $0x10, BX // 2 bytes MOVD $1, DX // 4 bytes MOVQ $-10, AX // 8 bytes plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang——plan9汇编","item":"https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang——plan9汇编","name":"Golang——plan9汇编","description":"基本指令 栈相关 在 plan9 汇编中，虽然存在push、pop指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作SP寄存器的位置来替换。\nSUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧 ... // 省略无用代码 ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧 栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。\nx86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭\n数据搬运 plan9 汇编中，常数以$num形式表示，可以是负数，一般为 10 进制，当然也可以用$0x123的十六进制形式。\nMOVB $1, DI // 1 byte MOVW $0x10, BX // 2 bytes MOVD $1, DX // 4 bytes MOVQ $-10, AX // 8 bytes plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。","keywords":["assembly","plan9","golang"],"articleBody":"基本指令 栈相关 在 plan9 汇编中，虽然存在push、pop指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作SP寄存器的位置来替换。\nSUBQ $0x18, SP // 对 SP 做减法，为函数分配函数栈帧 ... // 省略无用代码 ADDQ $0x18, SP // 对 SP 做加法，清除函数栈帧 栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。\nx86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭\n数据搬运 plan9 汇编中，常数以$num形式表示，可以是负数，一般为 10 进制，当然也可以用$0x123的十六进制形式。\nMOVB $1, DI // 1 byte MOVW $0x10, BX // 2 bytes MOVD $1, DX // 4 bytes MOVQ $-10, AX // 8 bytes plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。\n当然，还有个最明显的差异是 plan9 的操作数和 x86 是相反的，x86 汇编的 mov 是将右值移动到左部寄存器，而 plan9 是相反的。\n计算指令 常用的计算指令会有:\nADDQ AX, BX // BX += AX SUBQ AX, BX // BX -= AX IMULQ AX, BX // BX *= AX 计算指令和 MOV 指令一样，也有不同的后缀来对应操作数的字节大小，例如 ADDQ/ADDW/ADDB，这里每个后缀的意思和 MOV 一致。\n跳转 // 无条件跳转 JMP addr // 跳转到地址，地址可为代码中的地址 JMP label // 跳转到标签，可以跳转到同一函数内的标签位置 JMP 2(PC) // 以当前指令为基础，向前/后跳转 x 行，PC——程序计数器 JMP -2(PC) // 同上 // 有条件跳转 JZ target // 如果 zero flag 被 set 过，则跳转 寄存器 plan9 中使用寄存器不需要带 r 或 e 的前缀，如 rax，只要写 AX 即可:\nMOVQ $101, AX // mov rax, 101 下面是通用通用寄存器的名字在 X64 和 plan9 中的对应关系:\nX64 rax rbx rcx rdx rdi rsi rbp rsp r8 r9 r10 r11 r12 r13 r14 rip Plan9 AX BX CX DX DI SI BP SP R8 R9 R10 R11 R12 R13 R14 PC 伪寄存器 plan9 汇编还引入了 4 个伪寄存器，既然叫做伪寄存器，意味着它们并没有真实对应的寄存器，援引官方文档的描述:\nFP: Frame pointer: arguments and locals. PC: Program counter: jumps and branches. SB: Static base pointer: global symbols. SP: Stack pointer: the highest address within the local stack frame. 这里添加一些解释：\nFP: 常用于引用函数的输入参数，使用形如 symbol+offset(FP) 的方式。如 arg0+0(FP)，arg1+8(FP)，使用 FP 不加 symbol 时，无法通过编译，虽然在汇编层面来讲，symbol 并没有什么用，主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，但实际上它不是 x86 里的那个 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个栈帧底部的 BP 寄存器，而 plan9 中的 FP 寄存器不是指向栈帧底部，这个原因要谈到 go 的调用规约，在 go 中，参数和返回值所占的内存都是分配在caller的栈上的，如果在callee中使用类似 x86 的 FP 寄存器，其实是拿不到参数的，因为参数根本不在callee的栈中，这时候就要通过 FP 寄存器在caller的栈中取参数。虽然调用规约不同，但是 FP 寄存器的作用的确是类似的(取参数)，我想这就是把它称为 Frame pointer 的原因吧。 PC: 实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。 SB: 全局静态基指针，一般用来声明函数或全局变量。 SP: 常用于引用函数中的局部变量，plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 symbol+offset(SP) 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间。假如局部变量都是 8 字节，那么第一个局部变量就可以用 localvar0-8(SP) 来表示。注意，伪寄存器 SP 与硬件寄存器 SP 是两个不同的东西，在栈帧大小为 0 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 symbol+offset(SP) 形式，则表示伪寄存器 SP。如果是 offset(SP) 则表示硬件寄存器 SP。 我们这里对容易混淆的几点简单进行说明：\n伪 SP 和硬件 SP 不是一回事，在手写代码时，伪 SP 和硬件 SP 的区分方法是看该 SP 前是否有 symbol。如果有 symbol，那么即为伪寄存器，如果没有，那么说明是硬件 SP 寄存器。 SP 和 FP 的相对位置是会变的，所以不应该尝试用伪 SP 寄存器去找那些用 FP + offset 来引用的值，例如函数的入参和返回值。 在 go tool objdump/go tool compile -S 输出的代码中，是没有伪 SP 和 FP 寄存器的，我们上面说的区分伪 SP 和硬件 SP 寄存器的方法，对于上述两个命令的输出结果是没法使用的。在编译和反汇编的结果中，只有真实的 SP 寄存器。 变量声明 所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。\n使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:\nDATA symbol+offset(SB)/width, value offset 需要稍微注意，其含义是该值相对于符号 symbol 的偏移，而不是相对于全局某个地址的偏移，在后面声明数组时可以体现。\n使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。\nGLOBL divtab(SB), RODATA, $64 GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子:\nDATA age+0x00(SB)/4, $18 // forever 18 GLOBL age(SB), RODATA, $4 DATA pi+0(SB)/8, $3.1415926 GLOBL pi(SB), RODATA, $8 DATA birthYear+0(SB)/4, $1988 GLOBL birthYear(SB), RODATA, $4 正如之前所说，所有符号在声明时，其 offset 一般都是 0。\n有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:\nDATA bio\u003c\u003e+0(SB)/8, $\"oh yes i\" DATA bio\u003c\u003e+8(SB)/8, $\"am here \" GLOBL bio\u003c\u003e(SB), RODATA, $16 大部分都比较好理解，不过这里我们又引入了新的标记 \u003c\u003e，这个跟在符号名之后，表示该全局变量只在当前文件中生效，类似于 C 语言中的 static。如果在另外文件中引用该变量的话，会报 relocation target not found 的错误。\n本小节中提到的 flag，除了RODATA还可以有其它的取值:\nNOPROF = 1 (For TEXT items.) Don’t profile the marked function. This flag is deprecated. DUPOK = 2 It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use. NOSPLIT = 4 (For TEXT items.) Don’t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself. NOPTR = 16 (For DATA and GLOBL items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector. WRAPPER = 32 (For TEXT items.) This is a wrapper function and should not count as disabling recover. NEEDCTXT = 64 (For TEXT items.) This function is a closure so it uses its incoming context register. 当使用这些 flag 的字面量时，需要在汇编文件中 #include \"textflag.h\"。\ngo 文件与汇编文件 汇编文件引用 go 文件的全局变量 .go 文件中的全局变量在.s 文件中是可以访问的，举个例子：\n编写如下的 main.go 代码，其中 get 函数只是声明，未编写其函数体，程序是无法运行的。\npackage main var a = 999 func get() int func main() { println(get()) } 在同目录下编写refer.s汇编文件:\n#include \"textflag.h\" TEXT ·get(SB), NOSPLIT, $0-8 MOVQ ·a(SB), AX MOVQ AX, ret+0(FP) RET 在该汇编中对 get 函数进行了补充，同时引用了全局变量 a，将其值返回。\n要运行该程序，不能直接使用go run指令，会报错./main.go:5:6: missing function body，要使用go build构建程序再执行。\n汇编文件中实现函数 // func add(a, b int) int // =\u003e 该声明定义在同一个 package 下的任意 .go 文件中 // =\u003e 只有函数签名，没有实现 TEXT ·add(SB), NOSPLIT, $0-8 MOVQ a+0(FP), AX MOVQ a+8(FP), BX ADDQ AX, BX MOVQ BX, ret+16(FP) RET 在 plan9 中 TEXT 是一个指令，用来定义一个函数。除了 TEXT 之外还有前面变量声明说到的 DATA/GLOBL。\n注意代码中的·，这是一个中点。在程序编译链接后，所有·都会替换为.。\n可见手写汇编代码时，是可以用到 FP 寄存器。但是使用go tool compile来输出汇编时，就没有 FP 了，读者可以自行实验。\n栈结构 下面是一个典型的函数的栈结构图:\n----------------- current func arg0 ----------------- \u003c----------- FP(pseudo FP) caller ret addr +---------------+ | caller BP(*) | ----------------- \u003c----------- SP(pseudo SP，实际上是当前栈帧的 BP 位置) | Local Var0 | ----------------- | Local Var1 | ----------------- | Local Var2 | ----------------- | ........ | ----------------- | Local VarN | ----------------- | | | | | temporarily | | unused space | | | | | ----------------- | call retn | ----------------- | call ret(n-1)| ----------------- | .......... | ----------------- | call ret1 | ----------------- | call argn | ----------------- | ..... | ----------------- | call arg3 | ----------------- | call arg2 | |---------------| | call arg1 | ----------------- \u003c------------ hardware SP 位置 return addr +---------------+ 从原理上来讲，如果当前函数调用了其它函数，那么 return addr 也是在 caller 的栈上的，不过往栈上插 return addr 的过程是由 CALL 指令完成的，在 RET 时，SP 又会恢复到图上位置。我们在计算 SP 和参数相对位置时，可以认为硬件 SP 指向的就是图上的位置。\n图上的 caller BP，指的是 caller 的 BP 寄存器值，有些人把 caller BP 叫作 caller 的 frame pointer，实际上这个习惯是从 x86 架构沿袭来的。Go 的 asm 文档中把伪寄存器 FP 也称为 frame pointer，但是这两个 frame pointer 根本不是一回事。\n此外需要注意的是，caller BP 是在编译期由编译器插入的，用户手写代码时，计算 frame size 时是不包括这个 caller BP 部分的。是否插入 caller BP 的主要判断依据是:\n函数的栈帧大小大于 0 下述函数返回 true func Framepointer_enabled(goos, goarch string) bool { return framepointer_enabled != 0 \u0026\u0026 goarch == \"amd64\" \u0026\u0026 goos != \"nacl\" } 如果编译器在最终的汇编结果中没有插入 caller BP(源代码中所称的 frame pointer)的情况下，伪 SP 和伪 FP 之间只有 8 个字节的 caller 的 return address，而插入了 BP 的话，就会多出额外的 8 字节。也就说伪 SP 和伪 FP 的相对位置是不固定的，有可能是间隔 8 个字节，也有可能间隔 16 个字节。并且判断依据会根据平台和 Go 的版本有所不同。\n图上可以看到，FP 伪寄存器指向函数的传入参数的开始位置，因为栈是朝低地址方向增长，为了通过寄存器引用参数时方便，所以参数的摆放方向和栈的增长方向是相反的，即：\nFP high ----------------------\u003e low argN, ... arg3, arg2, arg1, arg0 假设所有参数均为 8 字节，这样我们就可以用 symname+0(FP) 访问第一个 参数，symname+8(FP) 访问第二个参数，以此类推。用伪 SP 来引用局部变量，原理上来讲差不多，不过因为伪 SP 指向的是局部变量的底部，所以 symname-8(SP) 表示的是第一个局部变量，symname-16(SP)表示第二个，以此类推。当然，这里假设局部变量都占用 8 个字节。\n图的最上部的 caller return address 和 current func arg0 都是由 caller 来分配空间的。不算在当前的栈帧内。\n因为官方文档本身较模糊，我们来一个函数调用的全景图，来看一下这些真假 SP/FP/BP 到底是个什么关系:\ncaller +------------------+ | | +----------------------\u003e -------------------- | | | | | caller parent BP | | BP(pseudo SP) -------------------- | | | | | Local Var0 | | -------------------- | | | | | ....... | | -------------------- | | | | | Local VarN | -------------------- caller stack frame | | | callee arg2 | | |------------------| | | | | | callee arg1 | | |------------------| | | | | | callee arg0 | | ----------------------------------------------+ FP(virtual register) | | | | | | return addr | parent return address | +----------------------\u003e +------------------+--------------------------- \u003c-------------------------------+ | callee BP | | | (callee frame pointer) | | BP(pseudo SP) ---------------------------- | | | | | Local Var0 | | ---------------------------- | | | | Local Var1 | ---------------------------- callee stack frame | | | ..... | ---------------------------- | | | | | Local VarN | | SP(Real Register) ---------------------------- | | | | | | | | | | | | | | | | +--------------------------+ \u003c-------------------------------+ callee argsize 和 framesize 计算规则 argsize 在函数声明中:\nTEXT pkgname·add(SB),NOSPLIT,$16-32 前面已经说过 $16-32 表示 $framesize-argsize。Go 在函数调用时，参数和返回值都需要由 caller 在其栈帧上备好空间。callee 在声明时仍然需要知道这个 argsize。argsize 的计算方法是，参数大小求和+返回值大小，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。\n不过真实世界永远没有我们假设的这么美好，函数参数往往混合了多种类型，还需要考虑内存对齐问题。\n如果不确定自己的函数签名需要多大的 argsize，可以通过简单实现一个相同签名的空函数，然后 go tool objdump 来逆向查找应该分配多少空间。\nframesize 函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：\n局部变量，及其每个变量的 size。 在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。 原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会有什么影响。 在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。 示例 add/sub/mul math.go:\npackage main import \"fmt\" func add(a, b int) int // 汇编函数声明 func sub(a, b int) int // 汇编函数声明 func mul(a, b int) int // 汇编函数声明 func main() { fmt.Println(add(10, 11)) fmt.Println(sub(99, 15)) fmt.Println(mul(11, 12)) } math.s:\n#include \"textflag.h\" // 因为我们声明函数用到了 NOSPLIT 这样的 flag，所以需要将 textflag.h 包含进来 // func add(a, b int) int TEXT ·add(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX // 参数 a MOVQ b+8(FP), BX // 参数 b ADDQ BX, AX // AX += BX MOVQ AX, ret+16(FP) // 返回 RET // func sub(a, b int) int TEXT ·sub(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX MOVQ b+8(FP), BX SUBQ BX, AX // AX -= BX MOVQ AX, ret+16(FP) RET // func mul(a, b int) int TEXT ·mul(SB), NOSPLIT, $0-24 MOVQ a+0(FP), AX MOVQ b+8(FP), BX IMULQ BX, AX // AX *= BX MOVQ AX, ret+16(FP) RET // 最后一行的空行是必须的，否则可能报 unexpected EOF 把这两个文件放在任意目录下，执行 go build 并运行就可以看到效果了。\n伪寄存器 SP 、伪寄存器 FP 和硬件寄存器 SP # 来写一段简单的代码证明伪 SP、伪 FP 和硬件 SP 的位置关系。 spspfp.s:\n#include \"textflag.h\" // func output(int) (int, int, int) TEXT ·output(SB), $8-48 MOVQ 24(SP), DX // 不带 symbol，这里的 SP 是硬件寄存器 SP MOVQ DX, ret3+24(FP) // 第三个返回值 MOVQ perhapsArg1+16(SP), BX // 当前函数栈大小 \u003e 0，所以 FP 在 SP 的上方 16 字节处 MOVQ BX, ret2+16(FP) // 第二个返回值 MOVQ arg1+0(FP), AX MOVQ AX, ret1+8(FP) // 第一个返回值 RET spspfp.go:\npackage main import ( \"fmt\" ) func output(int) (int, int, int) // 汇编函数声明 func main() { a, b, c := output(987654321) fmt.Println(a, b, c) } 执行上面的代码，可以得到输出:\n987654321 987654321 987654321 和代码结合思考，可以知道我们当前的栈结构是这样的:\n------ ret2 (8 bytes) ------ ret1 (8 bytes) ------ ret0 (8 bytes) ------ arg0 (8 bytes) ------ FP ret addr (8 bytes) ------ caller BP (8 bytes) ------ pseudo SP frame content (8 bytes) ------ hardware SP 本小节例子的 framesize 是大于 0 的，读者可以尝试修改 framesize 为 0，然后调整代码中引用伪 SP 和硬件 SP 时的 offset，来研究 framesize 为 0 时，伪 FP，伪 SP 和硬件 SP 三者之间的相对位置。\n本小节的例子是为了告诉大家，伪 SP 和伪 FP 的相对位置是会变化的，手写时不应该用伪 SP 和 \u003e0 的 offset 来引用数据，否则结果可能会出乎你的预料。\n汇编调用非汇编函数 # output.s:\n#include \"textflag.h\" // func output(a,b int) int TEXT ·output(SB), NOSPLIT, $24-24 MOVQ a+0(FP), DX // 第一个入参a MOVQ DX, 0(SP) // 硬件SP 设置为add的第一个参数 MOVQ b+8(FP), CX // 第二个入参b MOVQ CX, 8(SP) // 设置为add的第二个参数 CALL ·add(SB) // 在调用 add 之前，已经把参数都通过物理寄存器 SP 搬到了函数的栈顶 MOVQ 16(SP), AX // add 函数会把返回值放在这个位置 MOVQ AX, ret+16(FP) // return result RET output.go:\npackage main import \"fmt\" func add(x, y int) int { return x + y } func output(a, b int) int func main() { s := output(10, 13) fmt.Println(s) } 汇编中的循环 # 通过 DECQ 和 JZ 结合，可以实现高级语言里的循环逻辑:\nsum.s:\n#include \"textflag.h\" // func sum(sl []int64) int64 TEXT ·sum(SB), NOSPLIT, $0-32 MOVQ $0, SI MOVQ sl+0(FP), BX // \u0026sl[0], addr of the first elem MOVQ sl+8(FP), CX // len(sl) INCQ CX // CX++, 因为要循环 len 次 start: DECQ CX // CX-- JZ done ADDQ (BX), SI // SI += *BX ADDQ $8, BX // 指针移动 JMP start done: // 返回地址是 24 是怎么得来的呢？ // 可以通过 go tool compile -S math.go 得知 // 在调用 sum 函数时，会传入三个值，分别为: // slice 的首地址、slice 的 len， slice 的 cap // 不过我们这里的求和只需要 len，但 cap 依然会占用参数的空间 // 就是 16(FP) MOVQ SI, ret+24(FP) RET sum.go:\npackage main func sum([]int64) int64 func main() { println(sum([]int64{1, 2, 3, 4, 5})) } 引用 plan9 assembly 完全解析 ","wordCount":"1748","inLanguage":"zh","datePublished":"2022-12-30T10:51:52+08:00","dateModified":"2022-12-30T10:51:52+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golangplan9%E6%B1%87%E7%BC%96/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li><li><a href=https://www.yici.xin/archives/ title=归档🕰️><span>归档🕰️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Golang——plan9汇编</h1><div class=post-meta><span title='2022-12-30 10:51:52 +0800 +0800'>2022-12-30</span>&nbsp;·&nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/tech/golang%e2%80%94%e2%80%94plan9%e6%b1%87%e7%bc%96.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%8c%87%e4%bb%a4 aria-label=基本指令>基本指令</a><ul><li><a href=#%e6%a0%88%e7%9b%b8%e5%85%b3 aria-label=栈相关>栈相关</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e6%90%ac%e8%bf%90 aria-label=数据搬运>数据搬运</a></li><li><a href=#%e8%ae%a1%e7%ae%97%e6%8c%87%e4%bb%a4 aria-label=计算指令>计算指令</a></li><li><a href=#%e8%b7%b3%e8%bd%ac aria-label=跳转>跳转</a></li></ul></li><li><a href=#%e5%af%84%e5%ad%98%e5%99%a8 aria-label=寄存器>寄存器</a><ul><li><a href=#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8 aria-label=伪寄存器>伪寄存器</a></li></ul></li><li><a href=#%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e aria-label=变量声明>变量声明</a></li><li><a href=#go-%e6%96%87%e4%bb%b6%e4%b8%8e%e6%b1%87%e7%bc%96%e6%96%87%e4%bb%b6 aria-label="go 文件与汇编文件">go 文件与汇编文件</a><ul><li><a href=#%e6%b1%87%e7%bc%96%e6%96%87%e4%bb%b6%e5%bc%95%e7%94%a8-go-%e6%96%87%e4%bb%b6%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f aria-label="汇编文件引用 go 文件的全局变量">汇编文件引用 go 文件的全局变量</a></li><li><a href=#%e6%b1%87%e7%bc%96%e6%96%87%e4%bb%b6%e4%b8%ad%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0 aria-label=汇编文件中实现函数>汇编文件中实现函数</a></li></ul></li><li><a href=#%e6%a0%88%e7%bb%93%e6%9e%84 aria-label=栈结构>栈结构</a></li><li><a href=#argsize-%e5%92%8c-framesize-%e8%ae%a1%e7%ae%97%e8%a7%84%e5%88%99 aria-label="argsize 和 framesize 计算规则">argsize 和 framesize 计算规则</a><ul><li><a href=#argsize aria-label=argsize>argsize</a></li><li><a href=#framesize aria-label=framesize>framesize</a></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b aria-label=示例>示例</a><ul><li><a href=#addsubmul aria-label=add/sub/mul>add/sub/mul</a></li><li><a href=#%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8-sp-%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8-fp-%e5%92%8c%e7%a1%ac%e4%bb%b6%e5%af%84%e5%ad%98%e5%99%a8-sp-httpsgoxargincomdocsassemblyassembly%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8-sp-%e4%bc%aa%e5%af%84%e5%ad%98%e5%99%a8-fp-%e5%92%8c%e7%a1%ac%e4%bb%b6%e5%af%84%e5%ad%98%e5%99%a8-sp aria-label="伪寄存器 SP 、伪寄存器 FP 和硬件寄存器 SP #">伪寄存器 SP 、伪寄存器 FP 和硬件寄存器 SP <a href=https://go.xargin.com/docs/assembly/assembly/#%E4%BC%AA%E5%AF%84%E5%AD%98%E5%99%A8-sp-%E4%BC%AA%E5%AF%84%E5%AD%98%E5%99%A8-fp-%E5%92%8C%E7%A1%AC%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8-sp>#</a></a></li><li><a href=#%e6%b1%87%e7%bc%96%e8%b0%83%e7%94%a8%e9%9d%9e%e6%b1%87%e7%bc%96%e5%87%bd%e6%95%b0-httpsgoxargincomdocsassemblyassembly%e6%b1%87%e7%bc%96%e8%b0%83%e7%94%a8%e9%9d%9e%e6%b1%87%e7%bc%96%e5%87%bd%e6%95%b0 aria-label="汇编调用非汇编函数 #">汇编调用非汇编函数 <a href=https://go.xargin.com/docs/assembly/assembly/#%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8%E9%9D%9E%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0>#</a></a></li><li><a href=#%e6%b1%87%e7%bc%96%e4%b8%ad%e7%9a%84%e5%be%aa%e7%8e%af-httpsgoxargincomdocsassemblyassembly%e6%b1%87%e7%bc%96%e4%b8%ad%e7%9a%84%e5%be%aa%e7%8e%af aria-label="汇编中的循环 #">汇编中的循环 <a href=https://go.xargin.com/docs/assembly/assembly/#%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF>#</a></a></li></ul></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=基本指令>基本指令<a hidden class=anchor aria-hidden=true href=#基本指令>#</a></h2><h3 id=栈相关>栈相关<a hidden class=anchor aria-hidden=true href=#栈相关>#</a></h3><p>在 plan9 汇编中，虽然存在<code>push、pop</code>指令，但是在生成的代码中一般是看不到的，通常栈的这两种操作会以操作<code>SP</code>寄存器的位置来替换。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>SUBQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x18</span>, <span style=color:#a6e22e>SP</span> <span style=color:#75715e>// 对 SP 做减法，为函数分配函数栈帧
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>...</span>               <span style=color:#75715e>// 省略无用代码
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ADDQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x18</span>, <span style=color:#a6e22e>SP</span> <span style=color:#75715e>// 对 SP 做加法，清除函数栈帧
</span></span></span></code></pre></div><p>栈的方向是从内存高位置向低位置的，所以对 SP 寄存器做减法，就是给栈分配内存，加法即回收内存。</p><blockquote><p>x86 汇编中 push 和 pop 指令可以接一个寄存器，如 pop ax，表示将栈顶元素放入 ax 寄存器并且栈顶寄存器自动回退，而 plan9 只是做了栈顶寄存器操作，对于赋值操作需要使用 mov 指令 😭</p></blockquote><h3 id=数据搬运>数据搬运<a hidden class=anchor aria-hidden=true href=#数据搬运>#</a></h3><p>plan9 汇编中，常数以<code>$num</code>形式表示，可以是负数，一般为 10 进制，当然也可以用<code>$0x123</code>的十六进制形式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>MOVB</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>DI</span>      <span style=color:#75715e>// 1 byte
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MOVW</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x10</span>, <span style=color:#a6e22e>BX</span>   <span style=color:#75715e>// 2 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MOVD</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#a6e22e>DX</span>      <span style=color:#75715e>// 4 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>MOVQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#f92672>-</span><span style=color:#ae81ff>10</span>, <span style=color:#a6e22e>AX</span>     <span style=color:#75715e>// 8 bytes
</span></span></span></code></pre></div><p>plan9 汇编中使用的通常是带有后缀的 MOV 指令，不同后缀的区别是移动的字节大小。这和 x86 的汇编不一样，在 x86 汇编中，决定移动字节大小的是寄存器。</p><blockquote><p>当然，还有个最明显的差异是 plan9 的操作数和 x86 是相反的，x86 汇编的 mov 是将右值移动到左部寄存器，而 plan9 是相反的。</p></blockquote><h3 id=计算指令>计算指令<a hidden class=anchor aria-hidden=true href=#计算指令>#</a></h3><p>常用的计算指令会有:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>ADDQ</span>  <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>BX</span>   <span style=color:#75715e>// BX += AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>SUBQ</span>  <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>BX</span>   <span style=color:#75715e>// BX -= AX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>IMULQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>BX</span>   <span style=color:#75715e>// BX *= AX
</span></span></span></code></pre></div><blockquote><p>计算指令和 MOV 指令一样，也有不同的后缀来对应操作数的字节大小，例如 ADDQ/ADDW/ADDB，这里每个后缀的意思和 MOV 一致。</p></blockquote><h3 id=跳转>跳转<a hidden class=anchor aria-hidden=true href=#跳转>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 无条件跳转
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>JMP</span> <span style=color:#a6e22e>addr</span>   <span style=color:#75715e>// 跳转到地址，地址可为代码中的地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>JMP</span> <span style=color:#a6e22e>label</span>  <span style=color:#75715e>// 跳转到标签，可以跳转到同一函数内的标签位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>JMP</span> <span style=color:#ae81ff>2</span>(<span style=color:#a6e22e>PC</span>)  <span style=color:#75715e>// 以当前指令为基础，向前/后跳转 x 行，PC——程序计数器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>JMP</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>(<span style=color:#a6e22e>PC</span>) <span style=color:#75715e>// 同上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 有条件跳转
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>JZ</span> <span style=color:#a6e22e>target</span> <span style=color:#75715e>// 如果 zero flag 被 set 过，则跳转
</span></span></span></code></pre></div><h2 id=寄存器>寄存器<a hidden class=anchor aria-hidden=true href=#寄存器>#</a></h2><p>plan9 中使用寄存器不需要带 r 或 e 的前缀，如 rax，只要写 AX 即可:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>MOVQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>101</span>, <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// mov rax, 101
</span></span></span></code></pre></div><p>下面是通用通用寄存器的名字在 X64 和 plan9 中的对应关系:</p><table><thead><tr><th>X64</th><th>rax</th><th>rbx</th><th>rcx</th><th>rdx</th><th>rdi</th><th>rsi</th><th>rbp</th><th>rsp</th><th>r8</th><th>r9</th><th>r10</th><th>r11</th><th>r12</th><th>r13</th><th>r14</th><th>rip</th></tr></thead><tbody><tr><td>Plan9</td><td>AX</td><td>BX</td><td>CX</td><td>DX</td><td>DI</td><td>SI</td><td>BP</td><td>SP</td><td>R8</td><td>R9</td><td>R10</td><td>R11</td><td>R12</td><td>R13</td><td>R14</td><td>PC</td></tr></tbody></table><h3 id=伪寄存器>伪寄存器<a hidden class=anchor aria-hidden=true href=#伪寄存器>#</a></h3><p>plan9 汇编还引入了 4 个伪寄存器，既然叫做伪寄存器，意味着它们并没有真实对应的寄存器，援引官方文档的描述:</p><blockquote><ul><li><code>FP</code>: Frame pointer: arguments and locals.</li><li><code>PC</code>: Program counter: jumps and branches.</li><li><code>SB</code>: Static base pointer: global symbols.</li><li><code>SP</code>: Stack pointer: the highest address within the local stack frame.</li></ul></blockquote><p>这里添加一些解释：</p><ul><li>FP: 常用于引用函数的输入参数，使用形如 <code>symbol+offset(FP)</code> 的方式。如 <code>arg0+0(FP)</code>，<code>arg1+8(FP)</code>，使用 FP 不加 symbol 时，无法通过编译，虽然在汇编层面来讲，symbol 并没有什么用，主要是为了提升代码可读性。另外，官方文档虽然将伪寄存器 FP 称之为 frame pointer，但实际上它不是 x86 里的那个 frame pointer，按照传统的 x86 的习惯来讲，frame pointer 是指向整个栈帧底部的 BP 寄存器，而 plan9 中的 FP 寄存器不是指向栈帧底部，这个原因要谈到 go 的调用规约，在 go 中，参数和返回值所占的内存都是分配在<code>caller</code>的栈上的，如果在<code>callee</code>中使用类似 x86 的 FP 寄存器，其实是拿不到参数的，因为参数根本不在<code>callee</code>的栈中，这时候就要通过 FP 寄存器在<code>caller</code>的栈中取参数。虽然调用规约不同，但是 FP 寄存器的作用的确是类似的(取参数)，我想这就是把它称为 Frame pointer 的原因吧。</li><li>PC: 实际上就是在体系结构的知识中常见的 pc 寄存器，在 x86 平台下对应 ip 寄存器，amd64 上则是 rip。</li><li>SB: 全局静态基指针，一般用来声明函数或全局变量。</li><li>SP: 常用于引用函数中的局部变量，plan9 的这个 SP 寄存器指向当前栈帧的局部变量的开始位置，使用形如 <code>symbol+offset(SP)</code> 的方式，引用函数的局部变量。offset 的合法取值是 [-framesize, 0)，注意是个左闭右开的区间。假如局部变量都是 8 字节，那么第一个局部变量就可以用 <code>localvar0-8(SP)</code> 来表示。注意，伪寄存器 SP 与硬件寄存器 SP 是两个不同的东西，在栈帧大小为 0 的情况下，伪寄存器 SP 和硬件寄存器 SP 指向同一位置。手写汇编代码时，如果是 <code>symbol+offset(SP)</code> 形式，则表示伪寄存器 SP。如果是 <code>offset(SP)</code> 则表示硬件寄存器 SP。</li></ul><p>我们这里对容易混淆的几点简单进行说明：</p><ol><li>伪 SP 和硬件 SP 不是一回事，在手写代码时，伪 SP 和硬件 SP 的区分方法是看该 SP 前是否有 symbol。如果有 symbol，那么即为伪寄存器，如果没有，那么说明是硬件 SP 寄存器。</li><li>SP 和 FP 的相对位置是会变的，所以不应该尝试用伪 SP 寄存器去找那些用 FP + offset 来引用的值，例如函数的入参和返回值。</li><li>在 go tool objdump/go tool compile -S 输出的代码中，是没有伪 SP 和 FP 寄存器的，我们上面说的区分伪 SP 和硬件 SP 寄存器的方法，对于上述两个命令的输出结果是没法使用的。在编译和反汇编的结果中，只有真实的 SP 寄存器。</li></ol><h2 id=变量声明>变量声明<a hidden class=anchor aria-hidden=true href=#变量声明>#</a></h2><p>所谓的变量，一般是存储在 .rodata 或者 .data 段中的只读值。对应到应用层的话，就是已初始化过的全局的 const、var、static 变量/常量。</p><p>使用 DATA 结合 GLOBL 来定义一个变量。DATA 的用法为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>DATA</span>    <span style=color:#a6e22e>symbol</span><span style=color:#f92672>+</span><span style=color:#a6e22e>offset</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#a6e22e>width</span>, <span style=color:#a6e22e>value</span>
</span></span></code></pre></div><p><strong>offset 需要稍微注意，其含义是该值相对于符号 symbol 的偏移，而不是相对于全局某个地址的偏移，在后面声明数组时可以体现。</strong></p><p>使用 GLOBL 指令将变量声明为 global，额外接收两个参数，一个是 flag，另一个是变量的总大小。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>GLOBL</span> <span style=color:#a6e22e>divtab</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>RODATA</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>64</span>
</span></span></code></pre></div><p>GLOBL 必须跟在 DATA 指令之后，下面是一个定义了多个 readonly 的全局变量的完整例子:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>DATA</span> <span style=color:#a6e22e>age</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0x00</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>18</span>  <span style=color:#75715e>// forever 18
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>GLOBL</span> <span style=color:#a6e22e>age</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>RODATA</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DATA</span> <span style=color:#a6e22e>pi</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>3.1415926</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>GLOBL</span> <span style=color:#a6e22e>pi</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>RODATA</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DATA</span> <span style=color:#a6e22e>birthYear</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1988</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>GLOBL</span> <span style=color:#a6e22e>birthYear</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>RODATA</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>4</span>
</span></span></code></pre></div><p>正如之前所说，所有符号在声明时，其 offset 一般都是 0。</p><p>有时也可能会想在全局变量中定义数组，或字符串，这时候就需要用上非 0 的 offset 了，例如:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>DATA</span> <span style=color:#a6e22e>bio</span>&lt;&gt;<span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#e6db74>&#34;oh yes i&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DATA</span> <span style=color:#a6e22e>bio</span>&lt;&gt;<span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SB</span>)<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#e6db74>&#34;am here &#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>GLOBL</span> <span style=color:#a6e22e>bio</span>&lt;&gt;(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>RODATA</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>16</span>
</span></span></code></pre></div><p>大部分都比较好理解，不过这里我们又引入了新的标记 <code>&lt;></code>，这个跟在符号名之后，表示该全局变量只在当前文件中生效，类似于 C 语言中的 static。如果在另外文件中引用该变量的话，会报 <code>relocation target not found</code> 的错误。</p><p>本小节中提到的 flag，除了<code>RODATA</code>还可以有其它的取值:</p><blockquote><ul><li><code>NOPROF</code> = 1
(For <code>TEXT</code> items.) Don’t profile the marked function. This flag is deprecated.</li><li><code>DUPOK</code> = 2
It is legal to have multiple instances of this symbol in a single binary. The linker will choose one of the duplicates to use.</li><li><code>NOSPLIT</code> = 4
(For <code>TEXT</code> items.) Don’t insert the preamble to check if the stack must be split. The frame for the routine, plus anything it calls, must fit in the spare space at the top of the stack segment. Used to protect routines such as the stack splitting code itself.</li><li><code>NOPTR</code> = 16
(For <code>DATA</code> and <code>GLOBL</code> items.) This data contains no pointers and therefore does not need to be scanned by the garbage collector.</li><li><code>WRAPPER</code> = 32
(For <code>TEXT</code> items.) This is a wrapper function and should not count as disabling <code>recover</code>.</li><li><code>NEEDCTXT</code> = 64
(For <code>TEXT</code> items.) This function is a closure so it uses its incoming context register.</li></ul></blockquote><p>当使用这些 flag 的字面量时，需要在汇编文件中 <code>#include "textflag.h"</code>。</p><h2 id=go-文件与汇编文件>go 文件与汇编文件<a hidden class=anchor aria-hidden=true href=#go-文件与汇编文件>#</a></h2><h3 id=汇编文件引用-go-文件的全局变量>汇编文件引用 go 文件的全局变量<a hidden class=anchor aria-hidden=true href=#汇编文件引用-go-文件的全局变量>#</a></h3><p>.go 文件中的全局变量在.s 文件中是可以访问的，举个例子：</p><p>编写如下的 main.go 代码，其中 get 函数只是声明，未编写其函数体，程序是无法运行的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> = <span style=color:#ae81ff>999</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>get</span>() <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println(<span style=color:#a6e22e>get</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在同目录下编写<code>refer.s</code>汇编文件:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>#include &#34;textflag.h&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>TEXT ·get(SB), NOSPLIT, $0-8
</span></span><span style=display:flex><span>    MOVQ ·a(SB), AX
</span></span><span style=display:flex><span>    MOVQ AX, ret+0(FP)
</span></span><span style=display:flex><span>    RET
</span></span></code></pre></div><p>在该汇编中对 get 函数进行了补充，同时引用了全局变量 a，将其值返回。</p><p>要运行该程序，不能直接使用<code>go run</code>指令，会报错<code>./main.go:5:6: missing function body</code>，要使用<code>go build</code>构建程序再执行。</p><h3 id=汇编文件中实现函数>汇编文件中实现函数<a hidden class=anchor aria-hidden=true href=#汇编文件中实现函数>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// func add(a, b int) int
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   =&gt; 该声明定义在同一个 package 下的任意 .go 文件中
</span></span></span><span style=display:flex><span><span style=color:#75715e>//   =&gt; 只有函数签名，没有实现
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADDQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>BX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>在 plan9 中 TEXT 是一个指令，用来定义一个函数。除了 TEXT 之外还有前面变量声明说到的 DATA/GLOBL。</p><p>注意代码中的<code>·</code>，这是一个中点。在程序编译链接后，所有<code>·</code>都会替换为<code>.</code>。</p><blockquote><p>可见手写汇编代码时，是可以用到 FP 寄存器。但是使用<code>go tool compile</code>来输出汇编时，就没有 FP 了，读者可以自行实验。</p></blockquote><h2 id=栈结构>栈结构<a hidden class=anchor aria-hidden=true href=#栈结构>#</a></h2><p>下面是一个典型的函数的栈结构图:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       current func arg0
</span></span><span style=display:flex><span>                       ----------------- &lt;----------- FP(pseudo FP)
</span></span><span style=display:flex><span>                        caller ret addr
</span></span><span style=display:flex><span>                       +---------------+
</span></span><span style=display:flex><span>                       | caller BP(*)  |
</span></span><span style=display:flex><span>                       ----------------- &lt;----------- SP(pseudo SP，实际上是当前栈帧的 BP 位置)
</span></span><span style=display:flex><span>                       |   Local Var0  |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |   Local Var1  |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |   Local Var2  |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |   ........    |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |   Local VarN  |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |               |
</span></span><span style=display:flex><span>                       |               |
</span></span><span style=display:flex><span>                       |  temporarily  |
</span></span><span style=display:flex><span>                       |  unused space |
</span></span><span style=display:flex><span>                       |               |
</span></span><span style=display:flex><span>                       |               |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call retn    |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call ret(n-1)|
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  ..........   |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call ret1    |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call argn    |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |   .....       |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call arg3    |
</span></span><span style=display:flex><span>                       -----------------
</span></span><span style=display:flex><span>                       |  call arg2    |
</span></span><span style=display:flex><span>                       |---------------|
</span></span><span style=display:flex><span>                       |  call arg1    |
</span></span><span style=display:flex><span>                       -----------------   &lt;------------  hardware SP 位置
</span></span><span style=display:flex><span>                         return addr
</span></span><span style=display:flex><span>                       +---------------+
</span></span></code></pre></div><p>从原理上来讲，如果当前函数调用了其它函数，那么 return addr 也是在 caller 的栈上的，不过往栈上插 return addr 的过程是由 CALL 指令完成的，在 RET 时，SP 又会恢复到图上位置。我们在计算 SP 和参数相对位置时，可以认为硬件 SP 指向的就是图上的位置。</p><p>图上的 caller BP，指的是 caller 的 BP 寄存器值，有些人把 caller BP 叫作 caller 的 frame pointer，实际上这个习惯是从 x86 架构沿袭来的。Go 的 asm 文档中把伪寄存器 FP 也称为 frame pointer，但是这两个 frame pointer 根本不是一回事。</p><p>此外需要注意的是，caller BP 是在编译期由编译器插入的，用户手写代码时，计算 frame size 时是不包括这个 caller BP 部分的。是否插入 caller BP 的主要判断依据是:</p><ol><li>函数的栈帧大小大于 0</li><li>下述函数返回 true</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Framepointer_enabled</span>(<span style=color:#a6e22e>goos</span>, <span style=color:#a6e22e>goarch</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>framepointer_enabled</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goarch</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;amd64&#34;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>goos</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;nacl&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果编译器在最终的汇编结果中没有插入 caller BP(源代码中所称的 frame pointer)的情况下，伪 SP 和伪 FP 之间只有 8 个字节的 caller 的 return address，而插入了 BP 的话，就会多出额外的 8 字节。也就说伪 SP 和伪 FP 的相对位置是不固定的，有可能是间隔 8 个字节，也有可能间隔 16 个字节。并且判断依据会根据平台和 Go 的版本有所不同。</p><p>图上可以看到，FP 伪寄存器指向函数的传入参数的开始位置，因为栈是朝低地址方向增长，为了通过寄存器引用参数时方便，所以参数的摆放方向和栈的增长方向是相反的，即：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>                              FP
</span></span><span style=display:flex><span>high ----------------------&gt; low
</span></span><span style=display:flex><span>argN, ... arg3, arg2, arg1, arg0
</span></span></code></pre></div><p>假设所有参数均为 8 字节，这样我们就可以用 symname+0(FP) 访问第一个 参数，symname+8(FP) 访问第二个参数，以此类推。用伪 SP 来引用局部变量，原理上来讲差不多，不过因为伪 SP 指向的是局部变量的底部，所以 symname-8(SP) 表示的是第一个局部变量，symname-16(SP)表示第二个，以此类推。当然，这里假设局部变量都占用 8 个字节。</p><p>图的最上部的 caller return address 和 current func arg0 都是由 caller 来分配空间的。不算在当前的栈帧内。</p><p>因为官方文档本身较模糊，我们来一个函数调用的全景图，来看一下这些真假 SP/FP/BP 到底是个什么关系:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>                                       caller
</span></span><span style=display:flex><span>                                 +------------------+
</span></span><span style=display:flex><span>                                 |                  |
</span></span><span style=display:flex><span>       +----------------------&gt;  --------------------
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         | caller parent BP |
</span></span><span style=display:flex><span>       |           BP(pseudo SP) --------------------
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         |   Local Var0     |
</span></span><span style=display:flex><span>       |                         --------------------
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         |   .......        |
</span></span><span style=display:flex><span>       |                         --------------------
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         |   Local VarN     |
</span></span><span style=display:flex><span>                                 --------------------
</span></span><span style=display:flex><span> caller stack frame              |                  |
</span></span><span style=display:flex><span>                                 |   callee arg2    |
</span></span><span style=display:flex><span>       |                         |------------------|
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         |   callee arg1    |
</span></span><span style=display:flex><span>       |                         |------------------|
</span></span><span style=display:flex><span>       |                         |                  |
</span></span><span style=display:flex><span>       |                         |   callee arg0    |
</span></span><span style=display:flex><span>       |                         ----------------------------------------------+  FP(virtual register)
</span></span><span style=display:flex><span>       |                         |                  |                          |
</span></span><span style=display:flex><span>       |                         |   return addr    |  parent return address   |
</span></span><span style=display:flex><span>       +----------------------&gt;  +------------------+---------------------------    &lt;-------------------------------+
</span></span><span style=display:flex><span>                                                    |  callee BP               |                                    |
</span></span><span style=display:flex><span>                                                    |  (callee frame pointer)  |                                    |
</span></span><span style=display:flex><span>                                     BP(pseudo SP)  ----------------------------                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |     Local Var0           |                                    |
</span></span><span style=display:flex><span>                                                    ----------------------------                                    |
</span></span><span style=display:flex><span>                                                    |                          |
</span></span><span style=display:flex><span>                                                    |     Local Var1           |
</span></span><span style=display:flex><span>                                                    ----------------------------                            callee stack frame
</span></span><span style=display:flex><span>                                                    |                          |
</span></span><span style=display:flex><span>                                                    |       .....              |
</span></span><span style=display:flex><span>                                                    ----------------------------                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |     Local VarN           |                                    |
</span></span><span style=display:flex><span>                                  SP(Real Register) ----------------------------                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    |                          |                                    |
</span></span><span style=display:flex><span>                                                    +--------------------------+    &lt;-------------------------------+
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                                                              callee
</span></span></code></pre></div><h2 id=argsize-和-framesize-计算规则>argsize 和 framesize 计算规则<a hidden class=anchor aria-hidden=true href=#argsize-和-framesize-计算规则>#</a></h2><h3 id=argsize>argsize<a hidden class=anchor aria-hidden=true href=#argsize>#</a></h3><p>在函数声明中:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span> <span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>pkgname</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>16</span><span style=color:#f92672>-</span><span style=color:#ae81ff>32</span>
</span></span></code></pre></div><p>前面已经说过 $16-32 表示 $framesize-argsize。Go 在函数调用时，参数和返回值都需要由 caller 在其栈帧上备好空间。callee 在声明时仍然需要知道这个 argsize。argsize 的计算方法是，<strong>参数大小求和+返回值大小</strong>，例如入参是 3 个 int64 类型，返回值是 1 个 int64 类型，那么这里的 argsize = sizeof(int64) * 4。</p><p>不过真实世界永远没有我们假设的这么美好，函数参数往往混合了多种类型，还需要考虑内存对齐问题。</p><p>如果不确定自己的函数签名需要多大的 argsize，可以通过简单实现一个相同签名的空函数，然后 go tool objdump 来逆向查找应该分配多少空间。</p><h3 id=framesize>framesize<a hidden class=anchor aria-hidden=true href=#framesize>#</a></h3><p>函数的 framesize 就稍微复杂一些了，手写代码的 framesize 不需要考虑由编译器插入的 caller BP，要考虑：</p><ol><li>局部变量，及其每个变量的 size。</li><li>在函数中是否有对其它函数调用时，如果有的话，调用时需要将 callee 的参数、返回值考虑在内。虽然 return address(rip)的值也是存储在 caller 的 stack frame 上的，但是这个过程是由 CALL 指令和 RET 指令完成 PC 寄存器的保存和恢复的，在手写汇编时，同样也是不需要考虑这个 PC 寄存器在栈上所需占用的 8 个字节的。</li><li>原则上来说，调用函数时只要不把局部变量覆盖掉就可以了。稍微多分配几个字节的 framesize 也不会有什么影响。</li><li>在确保逻辑没有问题的前提下，你愿意覆盖局部变量也没有问题。只要保证进入和退出汇编函数时的 caller 和 callee 能正确拿到返回值就可以。</li></ol><h2 id=示例>示例<a hidden class=anchor aria-hidden=true href=#示例>#</a></h2><h3 id=addsubmul>add/sub/mul<a hidden class=anchor aria-hidden=true href=#addsubmul>#</a></h3><p>math.go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> <span style=color:#75715e>// 汇编函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> <span style=color:#75715e>// 汇编函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mul</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> <span style=color:#75715e>// 汇编函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>add</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>11</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>sub</span>(<span style=color:#ae81ff>99</span>, <span style=color:#ae81ff>15</span>))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>mul</span>(<span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>12</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>math.s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>include</span> <span style=color:#e6db74>&#34;textflag.h&#34;</span> <span style=color:#75715e>// 因为我们声明函数用到了 NOSPLIT 这样的 flag，所以需要将 textflag.h 包含进来
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func add(a, b int) int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// 参数 a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span> <span style=color:#75715e>// 参数 b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ADDQ</span> <span style=color:#a6e22e>BX</span>, <span style=color:#a6e22e>AX</span>    <span style=color:#75715e>// AX += BX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>) <span style=color:#75715e>// 返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func sub(a, b int) int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>sub</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>SUBQ</span> <span style=color:#a6e22e>BX</span>, <span style=color:#a6e22e>AX</span>    <span style=color:#75715e>// AX -= BX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func mul(a, b int) int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>mul</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span>  <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span>  <span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>IMULQ</span> <span style=color:#a6e22e>BX</span>, <span style=color:#a6e22e>AX</span>    <span style=color:#75715e>// AX *= BX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span>  <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>RET</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 最后一行的空行是必须的，否则可能报 unexpected EOF
</span></span></span></code></pre></div><p>把这两个文件放在任意目录下，执行 <code>go build</code> 并运行就可以看到效果了。</p><h3 id=伪寄存器-sp-伪寄存器-fp-和硬件寄存器-sp-httpsgoxargincomdocsassemblyassembly伪寄存器-sp-伪寄存器-fp-和硬件寄存器-sp>伪寄存器 SP 、伪寄存器 FP 和硬件寄存器 SP <a href=https://go.xargin.com/docs/assembly/assembly/#%E4%BC%AA%E5%AF%84%E5%AD%98%E5%99%A8-sp-%E4%BC%AA%E5%AF%84%E5%AD%98%E5%99%A8-fp-%E5%92%8C%E7%A1%AC%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8-sp>#</a><a hidden class=anchor aria-hidden=true href=#伪寄存器-sp-伪寄存器-fp-和硬件寄存器-sp-httpsgoxargincomdocsassemblyassembly伪寄存器-sp-伪寄存器-fp-和硬件寄存器-sp>#</a></h3><p>来写一段简单的代码证明伪 SP、伪 FP 和硬件 SP 的位置关系。 spspfp.s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>include</span> <span style=color:#e6db74>&#34;textflag.h&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func output(int) (int, int, int)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>output</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span><span style=color:#f92672>-</span><span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>DX</span> <span style=color:#75715e>// 不带 symbol，这里的 SP 是硬件寄存器 SP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>ret3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>) <span style=color:#75715e>// 第三个返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>perhapsArg1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>BX</span> <span style=color:#75715e>// 当前函数栈大小 &gt; 0，所以 FP 在 SP 的上方 16 字节处
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>BX</span>, <span style=color:#a6e22e>ret2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>) <span style=color:#75715e>// 第二个返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>arg1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>)  <span style=color:#75715e>// 第一个返回值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>spspfp.go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>output</span>(<span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>) <span style=color:#75715e>// 汇编函数声明
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>output</span>(<span style=color:#ae81ff>987654321</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>执行上面的代码，可以得到输出:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#ae81ff>987654321</span> <span style=color:#ae81ff>987654321</span> <span style=color:#ae81ff>987654321</span>
</span></span></code></pre></div><p>和代码结合思考，可以知道我们当前的栈结构是这样的:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>------
</span></span><span style=display:flex><span>ret2 <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------
</span></span><span style=display:flex><span>ret1 <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------
</span></span><span style=display:flex><span>ret0 <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------
</span></span><span style=display:flex><span>arg0 <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------ FP
</span></span><span style=display:flex><span>ret addr <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------
</span></span><span style=display:flex><span>caller BP <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------ pseudo SP
</span></span><span style=display:flex><span>frame content <span style=color:#f92672>(</span><span style=color:#ae81ff>8</span> bytes<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>------ hardware SP
</span></span></code></pre></div><p>本小节例子的 framesize 是大于 0 的，读者可以尝试修改 framesize 为 0，然后调整代码中引用伪 SP 和硬件 SP 时的 offset，来研究 framesize 为 0 时，伪 FP，伪 SP 和硬件 SP 三者之间的相对位置。</p><p>本小节的例子是为了告诉大家，伪 SP 和伪 FP 的相对位置是会变化的，手写时不应该用伪 SP 和 >0 的 offset 来引用数据，否则结果可能会出乎你的预料。</p><h3 id=汇编调用非汇编函数-httpsgoxargincomdocsassemblyassembly汇编调用非汇编函数>汇编调用非汇编函数 <a href=https://go.xargin.com/docs/assembly/assembly/#%E6%B1%87%E7%BC%96%E8%B0%83%E7%94%A8%E9%9D%9E%E6%B1%87%E7%BC%96%E5%87%BD%E6%95%B0>#</a><a hidden class=anchor aria-hidden=true href=#汇编调用非汇编函数-httpsgoxargincomdocsassemblyassembly汇编调用非汇编函数>#</a></h3><p>output.s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>include</span> <span style=color:#e6db74>&#34;textflag.h&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func output(a,b int) int
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>output</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>24</span><span style=color:#f92672>-</span><span style=color:#ae81ff>24</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>a</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DX</span> <span style=color:#75715e>// 第一个入参a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>DX</span>, <span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 硬件SP 设置为add的第一个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>b</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>CX</span> <span style=color:#75715e>// 第二个入参b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>CX</span>, <span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>SP</span>) <span style=color:#75715e>// 设置为add的第二个参数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>CALL</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>SB</span>) <span style=color:#75715e>// 在调用 add 之前，已经把参数都通过物理寄存器 SP 搬到了函数的栈顶
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>SP</span>), <span style=color:#a6e22e>AX</span> <span style=color:#75715e>// add 函数会把返回值放在这个位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>) <span style=color:#75715e>// return result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>output.go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>x</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>y</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>output</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>output</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>13</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=汇编中的循环-httpsgoxargincomdocsassemblyassembly汇编中的循环>汇编中的循环 <a href=https://go.xargin.com/docs/assembly/assembly/#%E6%B1%87%E7%BC%96%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF>#</a><a hidden class=anchor aria-hidden=true href=#汇编中的循环-httpsgoxargincomdocsassemblyassembly汇编中的循环>#</a></h3><p>通过 DECQ 和 JZ 结合，可以实现高级语言里的循环逻辑:</p><p>sum.s:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span><span style=color:#a6e22e>include</span> <span style=color:#e6db74>&#34;textflag.h&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// func sum(sl []int64) int64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>sum</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>SI</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>sl</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span> <span style=color:#75715e>// &amp;sl[0], addr of the first elem
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>sl</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>CX</span> <span style=color:#75715e>// len(sl)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>INCQ</span> <span style=color:#a6e22e>CX</span>           <span style=color:#75715e>// CX++, 因为要循环 len 次
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>start</span>:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DECQ</span> <span style=color:#a6e22e>CX</span>       <span style=color:#75715e>// CX--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>JZ</span>   <span style=color:#a6e22e>done</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ADDQ</span> (<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>SI</span> <span style=color:#75715e>// SI += *BX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ADDQ</span> <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>8</span>, <span style=color:#a6e22e>BX</span>   <span style=color:#75715e>// 指针移动
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>JMP</span>  <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回地址是 24 是怎么得来的呢？
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 可以通过 go tool compile -S math.go 得知
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 在调用 sum 函数时，会传入三个值，分别为:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// slice 的首地址、slice 的 len， slice 的 cap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 不过我们这里的求和只需要 len，但 cap 依然会占用参数的空间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 就是 16(FP)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>MOVQ</span> <span style=color:#a6e22e>SI</span>, <span style=color:#a6e22e>ret</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>sum.go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sum</span>([]<span style=color:#66d9ef>int64</span>) <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    println(<span style=color:#a6e22e>sum</span>([]<span style=color:#66d9ef>int64</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>}))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><ul><li><a href=https://go.xargin.com/docs/assembly/assembly>plan9 assembly 完全解析</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/assembly/>assembly</a></li><li><a href=https://www.yici.xin/tags/plan9/>plan9</a></li><li><a href=https://www.yici.xin/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/rust%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/><span class=title>« 上一页</span><br><span>Rust错误处理</span></a>
<a class=next href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><span class=title>下一页 »</span><br><span>Golang-map的操作</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
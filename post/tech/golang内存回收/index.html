<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Golang内存回收 | yicixin's blog</title>
<meta name=keywords content="golang,GC,内存回收,源码解析"><meta name=description content="GC源码分布: 流程 文件 标记准备 runtime/mgc.go 调步策略 runtime/mgcpacer.go 并发标记 runtime/mgcmark.go 清扫流程 runtime/msweep.go 位图标识 runtime/mbitmap.go 触发屏障 runtime/mbwbuf.go 内存回收 runtime/mgcscavenge.go GC触发链路: 触发 GC 的事件类型可以分为如下三种：
类型 触发事件 校验条件 gcTriggerHeap 分配对象时触发 堆已分配内存达到阈值 gcTriggerTime 由 forcegchelper 守护协程定时触发 每2分钟触发一次 gcTriggerCycle 用户调用 runtime.GC 方法 上一轮 GC 已结束 触发类型的源码:
type gcTriggerKind int const ( // 堆触发 gcTriggerHeap gcTriggerKind = iota // 定时触发 gcTriggerTime // 手动触发 gcTriggerCycle ) // 进行触发条件的校验 func (t gcTrigger) test() bool { if !memstats.enablegc || panicking.Load() !"><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/golang%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Golang内存回收"><meta property="og:description" content="GC源码分布: 流程 文件 标记准备 runtime/mgc.go 调步策略 runtime/mgcpacer.go 并发标记 runtime/mgcmark.go 清扫流程 runtime/msweep.go 位图标识 runtime/mbitmap.go 触发屏障 runtime/mbwbuf.go 内存回收 runtime/mgcscavenge.go GC触发链路: 触发 GC 的事件类型可以分为如下三种：
类型 触发事件 校验条件 gcTriggerHeap 分配对象时触发 堆已分配内存达到阈值 gcTriggerTime 由 forcegchelper 守护协程定时触发 每2分钟触发一次 gcTriggerCycle 用户调用 runtime.GC 方法 上一轮 GC 已结束 触发类型的源码:
type gcTriggerKind int const ( // 堆触发 gcTriggerHeap gcTriggerKind = iota // 定时触发 gcTriggerTime // 手动触发 gcTriggerCycle ) // 进行触发条件的校验 func (t gcTrigger) test() bool { if !memstats.enablegc || panicking.Load() !"><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/golang%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-27T18:26:23+08:00"><meta property="article:modified_time" content="2022-12-27T18:26:23+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang内存回收"><meta name=twitter:description content="GC源码分布: 流程 文件 标记准备 runtime/mgc.go 调步策略 runtime/mgcpacer.go 并发标记 runtime/mgcmark.go 清扫流程 runtime/msweep.go 位图标识 runtime/mbitmap.go 触发屏障 runtime/mbwbuf.go 内存回收 runtime/mgcscavenge.go GC触发链路: 触发 GC 的事件类型可以分为如下三种：
类型 触发事件 校验条件 gcTriggerHeap 分配对象时触发 堆已分配内存达到阈值 gcTriggerTime 由 forcegchelper 守护协程定时触发 每2分钟触发一次 gcTriggerCycle 用户调用 runtime.GC 方法 上一轮 GC 已结束 触发类型的源码:
type gcTriggerKind int const ( // 堆触发 gcTriggerHeap gcTriggerKind = iota // 定时触发 gcTriggerTime // 手动触发 gcTriggerCycle ) // 进行触发条件的校验 func (t gcTrigger) test() bool { if !memstats.enablegc || panicking.Load() !"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Golang内存回收","item":"https://www.yici.xin/post/tech/golang%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang内存回收","name":"Golang内存回收","description":"GC源码分布: 流程 文件 标记准备 runtime/mgc.go 调步策略 runtime/mgcpacer.go 并发标记 runtime/mgcmark.go 清扫流程 runtime/msweep.go 位图标识 runtime/mbitmap.go 触发屏障 runtime/mbwbuf.go 内存回收 runtime/mgcscavenge.go GC触发链路: 触发 GC 的事件类型可以分为如下三种：\n类型 触发事件 校验条件 gcTriggerHeap 分配对象时触发 堆已分配内存达到阈值 gcTriggerTime 由 forcegchelper 守护协程定时触发 每2分钟触发一次 gcTriggerCycle 用户调用 runtime.GC 方法 上一轮 GC 已结束 触发类型的源码:\ntype gcTriggerKind int const ( // 堆触发 gcTriggerHeap gcTriggerKind = iota // 定时触发 gcTriggerTime // 手动触发 gcTriggerCycle ) // 进行触发条件的校验 func (t gcTrigger) test() bool { if !memstats.enablegc || panicking.Load() !","keywords":["golang","GC","内存回收","源码解析"],"articleBody":"GC源码分布: 流程 文件 标记准备 runtime/mgc.go 调步策略 runtime/mgcpacer.go 并发标记 runtime/mgcmark.go 清扫流程 runtime/msweep.go 位图标识 runtime/mbitmap.go 触发屏障 runtime/mbwbuf.go 内存回收 runtime/mgcscavenge.go GC触发链路: 触发 GC 的事件类型可以分为如下三种：\n类型 触发事件 校验条件 gcTriggerHeap 分配对象时触发 堆已分配内存达到阈值 gcTriggerTime 由 forcegchelper 守护协程定时触发 每2分钟触发一次 gcTriggerCycle 用户调用 runtime.GC 方法 上一轮 GC 已结束 触发类型的源码:\ntype gcTriggerKind int const ( // 堆触发 gcTriggerHeap gcTriggerKind = iota // 定时触发 gcTriggerTime // 手动触发 gcTriggerCycle ) // 进行触发条件的校验 func (t gcTrigger) test() bool { if !memstats.enablegc || panicking.Load() != 0 || gcphase != _GCoff { return false } switch t.kind { case gcTriggerHeap: // 触发堆大小 trigger, _ := gcController.trigger() // 比较大小是否满足 return gcController.heapLive.Load() \u003e= trigger case gcTriggerTime: // gcController.gcPercent \u003c 0 表示不进行GC if gcController.gcPercent.Load() \u003c 0 { return false } // 上次gc时间 lastgc := int64(atomic.Load64(\u0026memstats.last_gc_nanotime)) return lastgc != 0 \u0026\u0026 t.now-lastgc \u003e forcegcperiod case gcTriggerCycle: // t.n \u003e work.cycles, but accounting for wraparound. return int32(t.n-work.cycles.Load()) \u003e 0 } return true } 定时触发GC \u003c!DOCTYPE HTML\u003e 方法 文件 作用 init runtime/proc.go 开启一个 forcegchelper 协程 forcegchelper runtime/proc.go 循环阻塞挂起+定时触发 gc main runtime/proc.go 调用 sysmon 方法 sysmon runtime/proc.go 定时唤醒 forcegchelper，从而触发 gc gcTrigger.test runtime/mgc.go 校验是否满足 gc 触发条件 gcStart runtime/mgc.go 标记准备阶段主流程方法 init + forcegchelper\n// start forcegc helper goroutine func init() { go forcegchelper() } // runtime 包下的全局变量 var forcegc forcegcstate type forcegcstate struct { lock mutex g *g idle atomic.Bool } func forcegchelper() { // 获取当前g forcegc.g = getg() // 初始化锁 lockInit(\u0026forcegc.lock, lockRankForcegc) for { lock(\u0026forcegc.lock) if forcegc.idle.Load() { throw(\"forcegc: phase error\") } forcegc.idle.Store(true) // 将当前 goroutine 置于等待状态并解锁 goparkunlock(\u0026forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, 1) // this goroutine is explicitly resumed by sysmon if debug.gctrace \u003e 0 { println(\"GC forced\") } // Time-triggered, fully concurrent. // 被唤醒后执行gcStart，进入标记准备阶段，触发类型即定时触发 gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()}) } } 唤醒forcegchelper的地方在proc.go的main函数中:\n// The main goroutine. func main() { ... // 通过 systemstack 操作切换至 g0，并调用 sysmon 方法，轮询尝试将 forcegchelper 协程添加到 gList 中，并在 injectglist 方法内将其唤醒 systemstack(func() { newm(sysmon, nil, -1) }) ... } func sysmon() { // ... for { // 通过 gcTrigger.test 方法检查是否需要发起 gc，触发类型为 gcTriggerTime：定时触发 if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() \u0026\u0026 atomic.Load(\u0026forcegc.idle) != 0 { lock(\u0026forcegc.lock) forcegc.idle = 0 var list gList // 需要发起 gc，则将 forcegc.g 注入 list 中, injectglist 方法内部会执行唤醒操作 list.push(forcegc.g) injectglist(\u0026list) unlock(\u0026forcegc.lock) } // ... } } 对象分配触发 \u003c!DOCTYPE HTML\u003e 方法 文件 作用 mallocgc runtime/malloc.go 分配对象主流程方法 gcTrigger.test runtime/mgc.go 校验是否满足 gc 触发条件 gcStart runtime/mgc.go 标记准备阶段主流程方法 在分配对象的malloc方法中，倘若满足如下两个条件之一，都会发起一次触发GC的尝试：\n需要初始化一个大小超过32KB的大对象 待初始化对象在mcache中对应spanClass的mspan空间已用尽 对象分配:\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer { // ... // 标志是否需要触发gc shouldhelpgc := false // ... if size \u003c= maxSmallSize { if noscan \u0026\u0026 size \u003c maxTinySize { // ... if v == 0 { // 倘若 mcache 中对应 spanClass 的 mspan 已满，置 true v, span, shouldhelpgc = c.nextFree(tinySpanClass) } // ... } else { // ... if v == 0 { // 倘若 mcache 中对应 spanClass 的 mspan 已满，置 true v, span, shouldhelpgc = c.nextFree(spc) } // ... } } else { // 申请大小大于 32KB 的大对象，直接置为 true shouldhelpgc = true // ... } // ... // 尝试触发 gc，类型为 gcTriggerHeap if shouldhelpgc { if t := (gcTrigger{kind: gcTriggerHeap}); t.test() { gcStart(t) } } // ... } 手动触发 方法 文件 作用 GC runtime/mgc.go 手动触发GC主流程方法 gcStart runtime/mgc.go 标记准备阶段主流程方法 最后一种触发的GC形式是手动触发，入口位于 runtime 包的公共方法：runtime.GC：\nfunc GC() { // ... // 触发gc，类型为手动触发，针对这种类型的校验条件是，上一轮GC已经完成，此时能够开启新一轮GC任务. gcStart(gcTrigger{kind: gcTriggerCycle, n: n + 1}) // ... } GC执行流程 标记准备 方法 文件 作用 gcStart runtime/mgc.go 标记准备阶段主流程方法 gcBgMarkStartWorkers runtime/mgc.go 批量启动标记协程 ，数量对应于 P 的个数 gcBgMarkWorker runtime/mgc.go 标记协程主流程方法，启动之初会先阻塞挂起，待被唤醒后真正执行任务 stopTheWorldWithSema runtime/mgc.go 即STW，停止P. gcControllerState.startCycle runtime/mgcspacer.go 限制标记协程执行频率，目标是令标记协程对CPU的占用率趋近于 25% setGCPhase runtime/mgc.go 更新GC阶段. 当为标记阶段（GCMark）时会启用混合写屏障 gcMarkTinyAllocs runtime/mgc.go 标记 mcache 中的 tiny 对象 startTheWorldWithSema runtime/mgc.go 与STW相反，会重新唤醒各个P 主流程-gcStart：\n再次检查GC触发条件是否达成 异步启动对应于P数量的标记协程 Stop the world 控制标记协程数量和执行时长，使得CPU占用率趋近25% 设置GC阶段为GCMark，开启混合混合写屏障 标记mcache中的tiny对象 Start the world func gcStart(trigger gcTrigger) { // 由于这是从 malloc 调用的，并且 malloc 是在许多可能持有锁的库的内部调用的，所以不要尝试在不可抢占或可能不稳定的情况下启动 GC。 mp := acquirem() // 不满足的情况直接return if gp := getg(); gp == mp.g0 || mp.locks \u003e 1 || mp.preemptoff != \"\" { releasem(mp) return } releasem(mp) mp = nil // 检查gc条件 for trigger.test() \u0026\u0026 sweepone() != ^uintptr(0) { sweep.nbgsweep++ } // 上锁 semacquire(\u0026work.startSema) // 加锁 double check if !trigger.test() { semrelease(\u0026work.startSema) return } // ... // 进入了 GC 模式，会根据 P 的数量启动多个 GC 并发标记协程，但是会先阻塞挂起，等待被唤醒，在标记阶段才开始执行 gcBgMarkStartWorkers() // ... // 切换到 g0，执行 Stop the world 操作 systemstack(stopTheWorldWithSema) // ... // 限制标记协程占用 CPU 时间片的比例为趋近 25% gcController.startCycle(now, int(gomaxprocs), trigger) // 设置GC阶段为_GCmark，启用混合写屏障 setGCPhase(_GCmark) // ... // 对 mcache 中的 tiny 对象进行标记 gcMarkTinyAllocs() // 切换至 g0，重新 start the world systemstack(func() { now = startTheWorldWithSema(trace.enabled) // ... }) // ... } gcBgMarkStartWorkers-异步启动标记协程：\nvar gcBgMarkWorkerCount int32 func gcBgMarkStartWorkers() { // Background marking is performed by per-P G's. Ensure that each P has // a background GC G. // // Worker Gs don't exit if gomaxprocs is reduced. If it is raised // again, we can reuse the old workers; no need to create new workers. // 这些WorkerG不会随着P的数量减少而退出，这样的话，如果要求的数量重新上调，可以重用旧的而不用创建新的worker for gcBgMarkWorkerCount \u003c gomaxprocs { go gcBgMarkWorker() notetsleepg(\u0026work.bgMarkReady, -1) noteclear(\u0026work.bgMarkReady) // The worker is now guaranteed to be added to the pool before // its P's next findRunnableGCWorker. gcBgMarkWorkerCount++ } } // gcBgMarkWorker 方法中将g包装成一个node添加到全局的gcBgMarkWorkerPool中，保证标记协程与P的一对一关联，并调用 gopark 方法将当前 g 挂起，等待被唤醒. func gcBgMarkWorker() { gp := getg() node := new(gcBgMarkWorkerNode) gp.m.preemptoff = \"\" node.gp.set(gp) node.m.set(acquirem()) // 唤醒外部的 for 循环 notewakeup(\u0026work.bgMarkReady) for { // 当前 g 阻塞至此，直到 gcController.findRunnableGCWorker 方法被调用，会将当前 g 唤醒 gopark(func(g *g, nodep unsafe.Pointer) bool { node := (*gcBgMarkWorkerNode)(nodep) // ... // 将当前 g 包装成一个 node 添加到 gcBgMarkWorkerPool 中 gcBgMarkWorkerPool.push(\u0026node.node) return true }, unsafe.Pointer(node), waitReasonGCWorkerIdle, traceEvGoBlock, 0) // ... } } Stop-the-world:\ngcStart 方法在调用gcBgMarkStartWorkers方法异步启动标记协程后，会执行STW操作停止所有用户协程，其实现位于 stopTheWorldWithSema 方法，核心点如下：\n取锁：sched.lock 将 sched.gcwaiting 标识置为 1，后续的调度流程见其标识，都会阻塞挂起 抢占所有g，并将 P 的状态置为 syscall 将所有P的状态改为 stop 倘若部分任务无法抢占，则等待其完成后再进行抢占 调用方法worldStopped收尾，世界停止了 func stopTheWorldWithSema() { _g_ := getg() // 全局调度锁 lock(\u0026sched.lock) sched.stopwait = gomaxprocs // 此标识置 1，之后所有的调度都会阻塞等待 atomic.Store(\u0026sched.gcwaiting, 1) // 发送抢占信息抢占所有 G，后将 p 状态置为 syscall preemptall() // 将当前 p 的状态置为 stop _g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic. sched.stopwait-- // 把所有 p 的状态置为 stop for _, p := range allp { s := p.status if s == _Psyscall \u0026\u0026 atomic.Cas(\u0026p.status, s, _Pgcstop) { // ... p.syscalltick++ sched.stopwait-- } } // 把空闲 p 的状态置为 stop now := nanotime() for { p, _ := pidleget(now) if p == nil { break } p.status = _Pgcstop sched.stopwait-- } wait := sched.stopwait \u003e 0 unlock(\u0026sched.lock) // 倘若有 p 无法被抢占，则阻塞直到将其统统抢占完成 if wait { for { // wait for 100us, then try to re-preempt in case of any races if notetsleep(\u0026sched.stopnote, 100*1000) { noteclear(\u0026sched.stopnote) break } preemptall() } } // native 方法，stop the world worldStopped() } 控制标记协程频率:\ngcStart方法中，还会通过gcController.startCycle方法，将标记协程对CPU的占用率控制在 25% 左右. 此时，根据P的数量是否能被4整除，分为两种处理方式：\n倘若P的个数能被4整除，则简单将标记协程的数量设置为P/4 倘若P的个数不能被4整除，则通过控制标记协程执行时长的方式，来使全局标记协程对CPU的使用率趋近于25% // 目标：标记协程对CPU的使用率维持在25%的水平 const gcBackgroundUtilization = 0.25 func (c *gcControllerState) startCycle(markStartTime int64, procs int, trigger gcTrigger) { // ... // P 的个数 * 0.25 totalUtilizationGoal := float64(procs) * gcBackgroundUtilization // P 的个数 * 0.25 后四舍五入取整 c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5) utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1 const maxUtilError = 0.3 // 倘若 P 的个数不能被 4 整除 if utilError \u003c -maxUtilError || utilError \u003e maxUtilError { if float64(c.dedicatedMarkWorkersNeeded) \u003e totalUtilizationGoal { c.dedicatedMarkWorkersNeeded-- } // 计算出每个 P 需要额外执行标记任务的时间片比例 c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(procs) // 倘若 P 的个数可以被 4 整除，则无需控制执行时长 } else { c.fractionalUtilizationGoal = 0 } // ... } 设置写屏障:\ngcStart方法会调用setGCPhase方法，标志GC正式进入并发标记（GCmark）阶段. 我们观察该方法代码实现，可以注意到，在_GCMark和_GCMarkTermination阶段中，会启用混合写屏障.\nfunc setGCPhase(x uint32) { atomic.Store(\u0026gcphase, x) writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo } 在混合写屏障机制中，核心是会将需要置灰的对象添加到当前P的wbBuf缓存中. 随后在并发标记缺灰、标记终止前置检查等时机会执行wbBufFlush1方法，批量地将wbBuf中的对象释放出来进行置灰，保证达到预期的效果.\n// src/runtime/mwbbuf.go:168 func wbBufFlush(dst *uintptr, src uintptr) { // ... systemstack(func() { wbBufFlush1(getg().m.p.ptr()) }) } wbBufFlush1方法中涉及了对象置灰操作，其包含了在对应mspan的bitmap中打点标记以及将对象添加到gcw队列两步.\nfunc wbBufFlush1(_p_ *p) { // 获取当前 P 通过屏障机制缓存的指针 start := uintptr(unsafe.Pointer(\u0026_p_.wbBuf.buf[0])) n := (_p_.wbBuf.next - start) / unsafe.Sizeof(_p_.wbBuf.buf[0]) ptrs := _p_.wbBuf.buf[:n] // 将缓存的指针作标记，添加到 gcw 队列 gcw := \u0026_p_.gcw pos := 0 for _, ptr := range ptrs { // ... obj, span, objIndex := findObject(ptr, 0, 0) if obj == 0 { continue } // 打标 mbits := span.markBitsForIndex(objIndex) if mbits.isMarked() { continue } mbits.setMarked() // ... } // 所有缓存对象入队 gcw.putBatch(ptrs[:pos]) _p_.wbBuf.reset() } tiny对象标记:\ngcMarkTinyAllocs方法中，遍历所有的P，对mcache中的Tiny对象分别调用greyobject方法进行置灰.\nfunc gcMarkTinyAllocs() { assertWorldStopped() for _, p := range allp { c := p.mcache if c == nil || c.tiny == 0 { continue } _, span, objIndex := findObject(c.tiny, 0, 0) gcw := \u0026p.gcw greyobject(c.tiny, 0, 0, span, gcw, objIndex) } } Start the world:\n将所有P唤醒. 倘若缺少M，则构造新的M为P补齐.\nfunc startTheWorldWithSema(emitTraceEvent bool) int64 { assertWorldStopped() // ... p1 := procresize(procs) // 重启世界 worldStarted() // 遍历所有 p，将其唤醒 for p1 != nil { p := p1 p1 = p1.link.ptr() if p.m != 0 { mp := p.m.ptr() p.m = 0 if mp.nextp != 0 { throw(\"startTheWorld: inconsistent mp-\u003enextp\") } mp.nextp.set(p) notewakeup(\u0026mp.park) } else { newm(nil, p, -1) } } // ... return startTime } 并发标记 标记清扫 ","wordCount":"1331","inLanguage":"zh","datePublished":"2022-12-27T18:26:23+08:00","dateModified":"2022-12-27T18:26:23+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/golang%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Golang内存回收</h1><div class=post-meta>&lt;span title='2022-12-27 18:26:23 +0800 +0800'>2022-12-27&lt;/span>&amp;nbsp;·&amp;nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/tech/golang%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#gc%e6%ba%90%e7%a0%81%e5%88%86%e5%b8%83 aria-label=GC源码分布:>GC源码分布:</a></li><li><a href=#gc%e8%a7%a6%e5%8f%91%e9%93%be%e8%b7%af aria-label=GC触发链路:>GC触发链路:</a><ul><li><a href=#%e5%ae%9a%e6%97%b6%e8%a7%a6%e5%8f%91gc aria-label=定时触发GC>定时触发GC</a></li><li><a href=#%e5%af%b9%e8%b1%a1%e5%88%86%e9%85%8d%e8%a7%a6%e5%8f%91 aria-label=对象分配触发>对象分配触发</a></li><li><a href=#%e6%89%8b%e5%8a%a8%e8%a7%a6%e5%8f%91 aria-label=手动触发>手动触发</a></li></ul></li><li><a href=#gc%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b aria-label=GC执行流程>GC执行流程</a><ul><li><a href=#%e6%a0%87%e8%ae%b0%e5%87%86%e5%a4%87 aria-label=标记准备>标记准备</a></li><li><a href=#%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0 aria-label=并发标记>并发标记</a></li><li><a href=#%e6%a0%87%e8%ae%b0%e6%b8%85%e6%89%ab aria-label=标记清扫>标记清扫</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=gc源码分布>GC源码分布:<a hidden class=anchor aria-hidden=true href=#gc源码分布>#</a></h2><table><thead><tr><th style=text-align:center><strong>流程</strong></th><th style=text-align:center><strong>文件</strong></th></tr></thead><tbody><tr><td style=text-align:center>标记准备</td><td style=text-align:center>runtime/mgc.go</td></tr><tr><td style=text-align:center>调步策略</td><td style=text-align:center>runtime/mgcpacer.go</td></tr><tr><td style=text-align:center>并发标记</td><td style=text-align:center>runtime/mgcmark.go</td></tr><tr><td style=text-align:center>清扫流程</td><td style=text-align:center>runtime/msweep.go</td></tr><tr><td style=text-align:center>位图标识</td><td style=text-align:center>runtime/mbitmap.go</td></tr><tr><td style=text-align:center>触发屏障</td><td style=text-align:center>runtime/mbwbuf.go</td></tr><tr><td style=text-align:center>内存回收</td><td style=text-align:center>runtime/mgcscavenge.go</td></tr></tbody></table><h2 id=gc触发链路>GC触发链路:<a hidden class=anchor aria-hidden=true href=#gc触发链路>#</a></h2><p>触发 GC 的事件类型可以分为如下三种：</p><table><thead><tr><th style=text-align:center><strong>类型</strong></th><th style=text-align:center><strong>触发事件</strong></th><th style=text-align:center><strong>校验条件</strong></th></tr></thead><tbody><tr><td style=text-align:center>gcTriggerHeap</td><td style=text-align:center>分配对象时触发</td><td style=text-align:center>堆已分配内存达到阈值</td></tr><tr><td style=text-align:center>gcTriggerTime</td><td style=text-align:center>由 forcegchelper 守护协程定时触发</td><td style=text-align:center>每2分钟触发一次</td></tr><tr><td style=text-align:center>gcTriggerCycle</td><td style=text-align:center>用户调用 runtime.GC 方法</td><td style=text-align:center>上一轮 GC 已结束</td></tr></tbody></table><p>触发类型的源码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gcTriggerKind</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 堆触发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gcTriggerHeap</span> <span style=color:#a6e22e>gcTriggerKind</span> = <span style=color:#66d9ef>iota</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 定时触发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gcTriggerTime</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 手动触发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gcTriggerCycle</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 进行触发条件的校验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#a6e22e>gcTrigger</span>) <span style=color:#a6e22e>test</span>() <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>memstats</span>.<span style=color:#a6e22e>enablegc</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>panicking</span>.<span style=color:#a6e22e>Load</span>() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>gcphase</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_GCoff</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>kind</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcTriggerHeap</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 触发堆大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>trigger</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>trigger</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 比较大小是否满足
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>heapLive</span>.<span style=color:#a6e22e>Load</span>() <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>trigger</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcTriggerTime</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e>// gcController.gcPercent &lt; 0 表示不进行GC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>gcPercent</span>.<span style=color:#a6e22e>Load</span>() &lt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 上次gc时间
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>lastgc</span> <span style=color:#f92672>:=</span> int64(<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load64</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>memstats</span>.<span style=color:#a6e22e>last_gc_nanotime</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>lastgc</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>now</span><span style=color:#f92672>-</span><span style=color:#a6e22e>lastgc</span> &gt; <span style=color:#a6e22e>forcegcperiod</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#a6e22e>gcTriggerCycle</span>:
</span></span><span style=display:flex><span>		<span style=color:#75715e>// t.n &gt; work.cycles, but accounting for wraparound.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>return</span> int32(<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>n</span><span style=color:#f92672>-</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>cycles</span>.<span style=color:#a6e22e>Load</span>()) &gt; <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=定时触发gc>定时触发GC<a hidden class=anchor aria-hidden=true href=#定时触发gc>#</a></h3><!doctype html><html lang=en><head><style type=text/css>#chart{padding-bottom:66%;position:relative;display:block;width:100%;border-bottom:5px solid}#chart iframe{position:absolute;top:0;left:0}</style><title></title></head><body><div id=chart><iframe id=embed_dom width=100% height=100% name=embed_dom frameborder=0 src="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=golang-%E5%AE%9A%E6%97%B6gc%E8%A7%A6%E5%8F%91%E8%B7%AF%E5%BE%84.drawio#R7Zhbl5owEMc%2FjY%2FbI0G5vNa19qHtOXvsZX2MMEB2A2NDUOmnb5CwQHHV9qirnj7J%2FDO5zeQ3AXvmKF5PBF1En9EH3iN9f90z73uEGGRgqJ9CyUvFce1SCAXztVMtTNkv0GJfqxnzIW05SkQu2aItepgk4MmWRoXAVdstQN6edUFD6AhTj%2FKu%2BoP5MtK7IHatfwQWRtXMhuWWLTGtnPVO0oj6uGpI5rhnjgSiLJ%2Fi9Qh4EbwqLmW%2FD6%2B0vixMQCIP6XD38O0L%2ByoI2N9n9KfxkE2EdWfqtcm82jD4av%2FaRCEjDDGhfFyr7wVmiQ%2FFqH1l1T6fEBdKNJT4BFLmOpk0k6ikSMZct8KaycfG86wY6t1QW%2FdrPfLGyCsjkSJ%2FbBqNXoVZd9tYVb8AE6kXUoS8tPX2toRQSylmwoMdcauOIhUhyB1%2BpPQrgtqYQCdoAhiDWqxyEMCpZMv2oaP67IYvfnV61YPO8F9kW4%2B7pDzTM7GEyc4RqBNcZGgVMQnTBd3EY6UobyezE2DG%2BQg5is1Ypk%2FBCTylp1LgMzRaLM%2BBeaBaXs3CEoSE9c646VZTQ5dXxUMzt6qRdbUUNWi1%2BqcKtNEJ6o1z9e8okQNRqm6EC2GJdFgKUG009CLgCxA3ABUx9lNl2OfEatCJeehN1cE5cQkbguMPtkXbIXPTso4Tbcu9sBpm%2Fy9hh5aw4YElzLqoCjbs0BRTlpwUpSAAy9tauHzbnff7J3kbIPYbk%2BReC0nHI8I6kAjnooiwOkSkeRrjLTDx52X%2B5lAYV%2FjpWV8ps2qMs9wvznW%2BIjsdnFjyBJ4MOUtP%2B8p2pnvG2c%2BUQc4KFbkWqI4HR3Xo99IxuCg4qmU3P2ZQ7f%2F5pGCc58tx4JztW0aZ9V%2Bom7bGH9Hm%2BDc%3D"></iframe></div></body></html><br><table><thead><tr><th style=text-align:center><strong>方法</strong></th><th style=text-align:center><strong>文件</strong></th><th style=text-align:center><strong>作用</strong></th></tr></thead><tbody><tr><td style=text-align:center>init</td><td style=text-align:center>runtime/proc.go</td><td style=text-align:center>开启一个 forcegchelper 协程</td></tr><tr><td style=text-align:center>forcegchelper</td><td style=text-align:center>runtime/proc.go</td><td style=text-align:center>循环阻塞挂起+定时触发 gc</td></tr><tr><td style=text-align:center>main</td><td style=text-align:center>runtime/proc.go</td><td style=text-align:center>调用 sysmon 方法</td></tr><tr><td style=text-align:center>sysmon</td><td style=text-align:center>runtime/proc.go</td><td style=text-align:center>定时唤醒 forcegchelper，从而触发 gc</td></tr><tr><td style=text-align:center>gcTrigger.test</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>校验是否满足 gc 触发条件</td></tr><tr><td style=text-align:center>gcStart</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记准备阶段主流程方法</td></tr></tbody></table><p>init + forcegchelper</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// start forcegc helper goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>forcegchelper</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// runtime 包下的全局变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span>  <span style=color:#a6e22e>forcegc</span>   <span style=color:#a6e22e>forcegcstate</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>forcegcstate</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>mutex</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>g</span>    <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>idle</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>forcegchelper</span>() {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 获取当前g
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>g</span> = <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 初始化锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lockInit</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>lockRankForcegc</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span>.<span style=color:#a6e22e>Load</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;forcegc: phase error&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将当前 goroutine 置于等待状态并解锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>goparkunlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>, <span style=color:#a6e22e>waitReasonForceGCIdle</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// this goroutine is explicitly resumed by sysmon
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>debug</span>.<span style=color:#a6e22e>gctrace</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			println(<span style=color:#e6db74>&#34;GC forced&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Time-triggered, fully concurrent.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 被唤醒后执行gcStart，进入标记准备阶段，触发类型即定时触发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>gcTrigger</span>{<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>gcTriggerTime</span>, <span style=color:#a6e22e>now</span>: <span style=color:#a6e22e>nanotime</span>()})
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>唤醒forcegchelper的地方在proc.go的main函数中:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// The main goroutine.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>  	<span style=color:#75715e>// 通过 systemstack 操作切换至 g0，并调用 sysmon 方法，轮询尝试将 forcegchelper 协程添加到 gList 中，并在 injectglist 方法内将其唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>newm</span>(<span style=color:#a6e22e>sysmon</span>, <span style=color:#66d9ef>nil</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		})
</span></span><span style=display:flex><span>  <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>sysmon</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> { 
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 通过 gcTrigger.test 方法检查是否需要发起 gc，触发类型为 gcTriggerTime：定时触发
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>gcTrigger</span>{<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>gcTriggerTime</span>, <span style=color:#a6e22e>now</span>: <span style=color:#a6e22e>now</span>}); <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>test</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Load</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {     
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>idle</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>list</span> <span style=color:#a6e22e>gList</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 需要发起 gc，则将 forcegc.g 注入 list 中, injectglist 方法内部会执行唤醒操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>g</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>forcegc</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=对象分配触发>对象分配触发<a hidden class=anchor aria-hidden=true href=#对象分配触发>#</a></h3><!doctype html><html lang=en><head><style type=text/css>#chart{padding-bottom:66%;position:relative;display:block;width:100%;border-bottom:5px solid}#chart iframe{position:absolute;top:0;left:0}</style><title></title></head><body><div id=chart><iframe id=embed_dom width=100% height=100% name=embed_dom frameborder=0 src="https://viewer.diagrams.net/?tags=%7B%7D&amp;highlight=0000ff&amp;edit=_blank&amp;layers=1&amp;nav=1&amp;title=golang-gc%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%A6%E5%8F%91%E8%B7%AF%E5%BE%84.drawio#R5VfbjpswEP0aHrsCHAw85tbdh1ZqlW277ZsDEyA1mcg4t%2F36GjC3kqRZbdKqrRQRz%2FGMmZnjY8Ag43R%2FL9g6fo8hcMM2w71BJoZtW%2FbAUn85cigRz3dLIBJJqJ0aYJY8gwZNjW6SELKOo0TkMll3wQBXKwhkB2NC4K7rtkDeveuaRdADZgHjffRLEspYV2G7Df4ASRRXd7aoX86krHLWlWQxC3HXgsjUIGOBKMtRuh8Dz5tX9aWMe3titk5MwEpeEiCe78nHz5%2B%2BLbNwO18%2BiEfPJm9snZs8VAVDqOrXJgoZY4QrxqcNOhK4WYWQr2oqq%2FF5h7hWoKXAJUh50GSyjUQFxTLlehb2iXxqjb%2FmS9052prs9cqFcdBGmWee3MnyNZThRgRwpuZqGzERgTzjR2qS1O4GTEGKg4oTwJlMtt08mN5mUe1Xh37ARGVom1oS9X7QgiDE6S5R5qWjGj7VoJVGAxUsv4BxnfCW8Y0uIWWcYxAFva3QEJ0ztYsTCbM1K3q7U2rvkrrAldSM57WPFgnnY%2BQoirVIyMBbBArPpMDv0JqhgQfzRU3xFoSE%2FXmS%2B6TogMFPvTV1b3eNdK2q%2F3FLttQ8TWOHgJd22%2FkP9UUu1Nfglfp6FTGkJ4MoeBRJFIG4k5DJf0AM9TP0nBro71SD%2B7eoQXVYHJ7aRisqN5uwwrqBigYXqoj%2BSRUNeioypo4xNA2P5gN19ZwCmRi%2BVyBeMeXnuDfRyMg0puo6zX9qSr0hDpUzNYau4Y%2F6QowxnW%2ByC0TYFR1YoQPuMdH51CWMdmVrOVd6IpGuCG3f7IvQPSJC%2F1YipEdOvpnaZjc%2B8hzwwsGx7nv2nFB6nW5T99dHnn%2BdE0%2BZzbt7%2BXLWfAGR6Q8%3D"></iframe></div></body></html><br><table><thead><tr><th style=text-align:center><strong>方法</strong></th><th style=text-align:center><strong>文件</strong></th><th style=text-align:center><strong>作用</strong></th></tr></thead><tbody><tr><td style=text-align:center>mallocgc</td><td style=text-align:center>runtime/malloc.go</td><td style=text-align:center>分配对象主流程方法</td></tr><tr><td style=text-align:center>gcTrigger.test</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>校验是否满足 gc 触发条件</td></tr><tr><td style=text-align:center>gcStart</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记准备阶段主流程方法</td></tr></tbody></table><p>在分配对象的malloc方法中，倘若满足如下两个条件之一，都会发起一次触发GC的尝试：</p><ul><li>需要初始化一个大小超过32KB的大对象</li><li>待初始化对象在mcache中对应spanClass的mspan空间已用尽</li></ul><p>对象分配:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>mallocgc</span>(<span style=color:#a6e22e>size</span> <span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>typ</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>_type</span>, <span style=color:#a6e22e>needzero</span> <span style=color:#66d9ef>bool</span>) <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	<span style=color:#75715e>// 标志是否需要触发gc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>shouldhelpgc</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>&lt;=</span> <span style=color:#a6e22e>maxSmallSize</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>noscan</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>size</span> &lt; <span style=color:#a6e22e>maxTinySize</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 倘若 mcache 中对应 spanClass 的 mspan 已满，置 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>nextFree</span>(<span style=color:#a6e22e>tinySpanClass</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>v</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 倘若 mcache 中对应 spanClass 的 mspan 已满，置 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                <span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>nextFree</span>(<span style=color:#a6e22e>spc</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 申请大小大于 32KB 的大对象，直接置为 true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>shouldhelpgc</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 尝试触发 gc，类型为 gcTriggerHeap
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>shouldhelpgc</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>gcTrigger</span>{<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>gcTriggerHeap</span>}); <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>t</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=手动触发>手动触发<a hidden class=anchor aria-hidden=true href=#手动触发>#</a></h3><table><thead><tr><th style=text-align:center><strong>方法</strong></th><th style=text-align:center><strong>文件</strong></th><th style=text-align:center><strong>作用</strong></th></tr></thead><tbody><tr><td style=text-align:center>GC</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>手动触发GC主流程方法</td></tr><tr><td style=text-align:center>gcStart</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记准备阶段主流程方法</td></tr></tbody></table><p>最后一种触发的GC形式是手动触发，入口位于 runtime 包的公共方法：runtime.GC：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GC</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  	<span style=color:#75715e>// 触发gc，类型为手动触发，针对这种类型的校验条件是，上一轮GC已经完成，此时能够开启新一轮GC任务.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>gcTrigger</span>{<span style=color:#a6e22e>kind</span>: <span style=color:#a6e22e>gcTriggerCycle</span>, <span style=color:#a6e22e>n</span>: <span style=color:#a6e22e>n</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>})
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=gc执行流程>GC执行流程<a hidden class=anchor aria-hidden=true href=#gc执行流程>#</a></h2><h3 id=标记准备>标记准备<a hidden class=anchor aria-hidden=true href=#标记准备>#</a></h3><table><thead><tr><th style=text-align:center><strong>方法</strong></th><th style=text-align:center><strong>文件</strong></th><th style=text-align:center><strong>作用</strong></th></tr></thead><tbody><tr><td style=text-align:center>gcStart</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记准备阶段主流程方法</td></tr><tr><td style=text-align:center>gcBgMarkStartWorkers</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>批量启动标记协程 ，数量对应于 P 的个数</td></tr><tr><td style=text-align:center>gcBgMarkWorker</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记协程主流程方法，启动之初会先阻塞挂起，待被唤醒后真正执行任务</td></tr><tr><td style=text-align:center>stopTheWorldWithSema</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>即STW，停止P.</td></tr><tr><td style=text-align:center>gcControllerState.startCycle</td><td style=text-align:center>runtime/mgcspacer.go</td><td style=text-align:center>限制标记协程执行频率，目标是令标记协程对CPU的占用率趋近于 25%</td></tr><tr><td style=text-align:center>setGCPhase</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>更新GC阶段. 当为标记阶段（GCMark）时会启用混合写屏障</td></tr><tr><td style=text-align:center>gcMarkTinyAllocs</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>标记 mcache 中的 tiny 对象</td></tr><tr><td style=text-align:center>startTheWorldWithSema</td><td style=text-align:center>runtime/mgc.go</td><td style=text-align:center>与STW相反，会重新唤醒各个P</td></tr></tbody></table><p>主流程-gcStart：</p><ul><li>再次检查GC触发条件是否达成</li><li>异步启动对应于P数量的标记协程</li><li>Stop the world</li><li>控制标记协程数量和执行时长，使得CPU占用率趋近25%</li><li>设置GC阶段为GCMark，开启混合混合写屏障</li><li>标记mcache中的tiny对象</li><li>Start the world</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcStart</span>(<span style=color:#a6e22e>trigger</span> <span style=color:#a6e22e>gcTrigger</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 由于这是从 malloc 调用的，并且 malloc 是在许多可能持有锁的库的内部调用的，所以不要尝试在不可抢占或可能不稳定的情况下启动 GC。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 不满足的情况直接return
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>(); <span style=color:#a6e22e>gp</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>g0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>locks</span> &gt; <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>preemptoff</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 检查gc条件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>trigger</span>.<span style=color:#a6e22e>test</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sweepone</span>() <span style=color:#f92672>!=</span> ^uintptr(<span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>sweep</span>.<span style=color:#a6e22e>nbgsweep</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 上锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>startSema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 加锁 double check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>trigger</span>.<span style=color:#a6e22e>test</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>startSema</span>)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 进入了 GC 模式，会根据 P 的数量启动多个 GC 并发标记协程，但是会先阻塞挂起，等待被唤醒，在标记阶段才开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcBgMarkStartWorkers</span>()
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 切换到 g0，执行 Stop the world 操作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>stopTheWorldWithSema</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 限制标记协程占用 CPU 时间片的比例为趋近 25%
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>now</span>, int(<span style=color:#a6e22e>gomaxprocs</span>), <span style=color:#a6e22e>trigger</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 设置GC阶段为_GCmark，启用混合写屏障
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>_GCmark</span>)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 对 mcache 中的 tiny 对象进行标记
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>gcMarkTinyAllocs</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 切换至 g0，重新 start the world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>startTheWorldWithSema</span>(<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>enabled</span>)
</span></span><span style=display:flex><span>     <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  })
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>gcBgMarkStartWorkers-异步启动标记协程：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>gcBgMarkWorkerCount</span> <span style=color:#66d9ef>int32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkStartWorkers</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Background marking is performed by per-P G&#39;s. Ensure that each P has
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// a background GC G.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Worker Gs don&#39;t exit if gomaxprocs is reduced. If it is raised
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// again, we can reuse the old workers; no need to create new workers.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 这些WorkerG不会随着P的数量减少而退出，这样的话，如果要求的数量重新上调，可以重用旧的而不用创建新的worker
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>gcBgMarkWorkerCount</span> &lt; <span style=color:#a6e22e>gomaxprocs</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>gcBgMarkWorker</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>notetsleepg</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>noteclear</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>		<span style=color:#75715e>// The worker is now guaranteed to be added to the pool before
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// its P&#39;s next findRunnableGCWorker.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gcBgMarkWorkerCount</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// gcBgMarkWorker 方法中将g包装成一个node添加到全局的gcBgMarkWorkerPool中，保证标记协程与P的一对一关联，并调用 gopark 方法将当前 g 挂起，等待被唤醒.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcBgMarkWorker</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>gcBgMarkWorkerNode</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>preemptoff</span> = <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>acquirem</span>())
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 唤醒外部的 for 循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>work</span>.<span style=color:#a6e22e>bgMarkReady</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当前 g 阻塞至此，直到 gcController.findRunnableGCWorker 方法被调用，会将当前 g 唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>gopark</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>nodep</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>node</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>gcBgMarkWorkerNode</span>)(<span style=color:#a6e22e>nodep</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// 将当前 g 包装成一个 node 添加到 gcBgMarkWorkerPool 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>gcBgMarkWorkerPool</span>.<span style=color:#a6e22e>push</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>node</span>.<span style=color:#a6e22e>node</span>)          
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        }, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>node</span>), <span style=color:#a6e22e>waitReasonGCWorkerIdle</span>, <span style=color:#a6e22e>traceEvGoBlock</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Stop-the-world:</p><p>gcStart 方法在调用gcBgMarkStartWorkers方法异步启动标记协程后，会执行STW操作停止所有用户协程，其实现位于 stopTheWorldWithSema 方法，核心点如下：</p><ul><li>取锁：sched.lock</li><li>将 sched.gcwaiting 标识置为 1，后续的调度流程见其标识，都会阻塞挂起</li><li>抢占所有g，并将 P 的状态置为 syscall</li><li>将所有P的状态改为 stop</li><li>倘若部分任务无法抢占，则等待其完成后再进行抢占</li><li>调用方法worldStopped收尾，世界停止了</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>stopTheWorldWithSema</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_g_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 全局调度锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span> = <span style=color:#a6e22e>gomaxprocs</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 此标识置 1，之后所有的调度都会阻塞等待
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 发送抢占信息抢占所有 G，后将 p 状态置为 syscall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>preemptall</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将当前 p 的状态置为 stop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>_g_</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>_Pgcstop</span> <span style=color:#75715e>// Pgcstop is only diagnostic.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 把所有 p 的状态置为 stop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>allp</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>status</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_Psyscall</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Cas</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>_Pgcstop</span>) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>syscalltick</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 把空闲 p 的状态置为 stop
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>now</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>nanotime</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pidleget</span>(<span style=color:#a6e22e>now</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>status</span> = <span style=color:#a6e22e>_Pgcstop</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wait</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopwait</span> &gt; <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 倘若有 p 无法被抢占，则阻塞直到将其统统抢占完成
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>wait</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// wait for 100us, then try to re-preempt in case of any races
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>notetsleep</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopnote</span>, <span style=color:#ae81ff>100</span><span style=color:#f92672>*</span><span style=color:#ae81ff>1000</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>noteclear</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>stopnote</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>preemptall</span>()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// native 方法，stop the world
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>worldStopped</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>控制标记协程频率:</p><p>gcStart方法中，还会通过gcController.startCycle方法，将标记协程对CPU的占用率控制在 25% 左右. 此时，根据P的数量是否能被4整除，分为两种处理方式：</p><ul><li>倘若P的个数能被4整除，则简单将标记协程的数量设置为P/4</li><li>倘若P的个数不能被4整除，则通过控制标记协程执行时长的方式，来使全局标记协程对CPU的使用率趋近于25%</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 目标：标记协程对CPU的使用率维持在25%的水平
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>gcBackgroundUtilization</span> = <span style=color:#ae81ff>0.25</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>c</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>gcControllerState</span>) <span style=color:#a6e22e>startCycle</span>(<span style=color:#a6e22e>markStartTime</span> <span style=color:#66d9ef>int64</span>, <span style=color:#a6e22e>procs</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>trigger</span> <span style=color:#a6e22e>gcTrigger</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// P 的个数 * 0.25
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>procs</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>gcBackgroundUtilization</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// P 的个数 * 0.25 后四舍五入取整
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span> = int64(<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>utilError</span> <span style=color:#f92672>:=</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)<span style=color:#f92672>/</span><span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>maxUtilError</span> = <span style=color:#ae81ff>0.3</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 倘若 P 的个数不能被 4 整除
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>utilError</span> &lt; <span style=color:#f92672>-</span><span style=color:#a6e22e>maxUtilError</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>utilError</span> &gt; <span style=color:#a6e22e>maxUtilError</span> {        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>) &gt; <span style=color:#a6e22e>totalUtilizationGoal</span> {    
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 计算出每个 P 需要额外执行标记任务的时间片比例
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = (<span style=color:#a6e22e>totalUtilizationGoal</span> <span style=color:#f92672>-</span> float64(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>dedicatedMarkWorkersNeeded</span>)) <span style=color:#f92672>/</span> float64(<span style=color:#a6e22e>procs</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 倘若 P 的个数可以被 4 整除，则无需控制执行时长
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>fractionalUtilizationGoal</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>设置写屏障:</p><p>gcStart方法会调用setGCPhase方法，标志GC正式进入并发标记（GCmark）阶段. 我们观察该方法代码实现，可以注意到，在_GCMark和_GCMarkTermination阶段中，会启用混合写屏障.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>setGCPhase</span>(<span style=color:#a6e22e>x</span> <span style=color:#66d9ef>uint32</span>) {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gcphase</span>, <span style=color:#a6e22e>x</span>)
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>needed</span> = <span style=color:#a6e22e>gcphase</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_GCmark</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>gcphase</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>_GCmarktermination</span>
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>enabled</span> = <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>needed</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>writeBarrier</span>.<span style=color:#a6e22e>cgo</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在混合写屏障机制中，核心是会将需要置灰的对象添加到当前P的wbBuf缓存中. 随后在并发标记缺灰、标记终止前置检查等时机会执行wbBufFlush1方法，批量地将wbBuf中的对象释放出来进行置灰，保证达到预期的效果.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// src/runtime/mwbbuf.go:168
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>wbBufFlush</span>(<span style=color:#a6e22e>dst</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>uintptr</span>, <span style=color:#a6e22e>src</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>systemstack</span>(<span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>wbBufFlush1</span>(<span style=color:#a6e22e>getg</span>().<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>())
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>wbBufFlush1方法中涉及了对象置灰操作，其包含了在对应mspan的bitmap中打点标记以及将对象添加到gcw队列两步.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>wbBufFlush1</span>(<span style=color:#a6e22e>_p_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前 P 通过屏障机制缓存的指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>wbBuf</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>0</span>]))
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> (<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>wbBuf</span>.<span style=color:#a6e22e>next</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>) <span style=color:#f92672>/</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Sizeof</span>(<span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>wbBuf</span>.<span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>0</span>])
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptrs</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>wbBuf</span>.<span style=color:#a6e22e>buf</span>[:<span style=color:#a6e22e>n</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 将缓存的指针作标记，添加到 gcw 队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>gcw</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>pos</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>ptr</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>ptrs</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>obj</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findObject</span>(<span style=color:#a6e22e>ptr</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>obj</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 打标
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>mbits</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>span</span>.<span style=color:#a6e22e>markBitsForIndex</span>(<span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>isMarked</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mbits</span>.<span style=color:#a6e22e>setMarked</span>()
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 所有缓存对象入队
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>gcw</span>.<span style=color:#a6e22e>putBatch</span>(<span style=color:#a6e22e>ptrs</span>[:<span style=color:#a6e22e>pos</span>])
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_p_</span>.<span style=color:#a6e22e>wbBuf</span>.<span style=color:#a6e22e>reset</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>tiny对象标记:</p><p>gcMarkTinyAllocs方法中，遍历所有的P，对mcache中的Tiny对象分别调用greyobject方法进行置灰.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gcMarkTinyAllocs</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>assertWorldStopped</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>allp</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>mcache</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>objIndex</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findObject</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>gcw</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>gcw</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>greyobject</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>tiny</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>span</span>, <span style=color:#a6e22e>gcw</span>, <span style=color:#a6e22e>objIndex</span>)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Start the world:</p><p>将所有P唤醒. 倘若缺少M，则构造新的M为P补齐.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>startTheWorldWithSema</span>(<span style=color:#a6e22e>emitTraceEvent</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>int64</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>assertWorldStopped</span>()
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...   
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>p1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>procresize</span>(<span style=color:#a6e22e>procs</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 重启世界
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>worldStarted</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 遍历所有 p，将其唤醒
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>p1</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p1</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>p1</span> = <span style=color:#a6e22e>p1</span>.<span style=color:#a6e22e>link</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>m</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;startTheWorld: inconsistent mp-&gt;nextp&#34;</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>nextp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>p</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>park</span>)
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {           
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>newm</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>p</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>startTime</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=并发标记>并发标记<a hidden class=anchor aria-hidden=true href=#并发标记>#</a></h3><h3 id=标记清扫>标记清扫<a hidden class=anchor aria-hidden=true href=#标记清扫>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/golang/>golang</a></li><li><a href=https://www.yici.xin/tags/gc/>GC</a></li><li><a href=https://www.yici.xin/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/>内存回收</a></li><li><a href=https://www.yici.xin/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/>源码解析</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golang%E8%AF%BB%E5%86%99%E9%94%81/><span class=title>« 上一页</span><br><span>Golang读写锁</span>
</a><a class=next href=https://www.yici.xin/post/tech/golang%E4%BA%92%E6%96%A5%E9%94%81/><span class=title>下一页 »</span><br><span>Golang互斥锁-Mutex</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
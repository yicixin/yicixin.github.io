<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Go channel | 绝知</title>
<meta name=keywords content="channel,golang"><meta name=description content="数据结构
channel 的底层源码和相关实现在/src/runtime/chan.go中。
type hchan struct {
	qcount   uint           // 队列中所有数据总数
	dataqsiz uint           // 环形队列的 size
	buf      unsafe.Pointer // 指向 dataqsiz 长度的数组
	elemsize uint16         // 元素大小
	closed   uint32
	elemtype *_type         // 元素类型
	sendx    uint           // 已发送的元素在环形队列中的位置
	recvx    uint           // 已接收的元素在环形队列中的位置
	recvq    waitq          // 接收者的等待队列
	sendq    waitq          // 发送者的等待队列

	// lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。
	// 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， 
    // 因为这会因为堆栈 shrinking 而发生死锁。
	lock mutex
}


recvq 和 sendq 是等待队列，waitq 类型是一个双向链表："><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/go-channel/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.09ec7b2639f9095779b73636ae4b3857a1b98d87bcdb44b187c9a7c6a5c1cfb9.css integrity="sha256-Cex7Jjn5CVd5tzY2rks4V6G5jYe820Sxh8mnxqXBz7k=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/go-channel/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="Go channel"><meta property="og:description" content="数据结构
channel 的底层源码和相关实现在/src/runtime/chan.go中。
type hchan struct {
	qcount   uint           // 队列中所有数据总数
	dataqsiz uint           // 环形队列的 size
	buf      unsafe.Pointer // 指向 dataqsiz 长度的数组
	elemsize uint16         // 元素大小
	closed   uint32
	elemtype *_type         // 元素类型
	sendx    uint           // 已发送的元素在环形队列中的位置
	recvx    uint           // 已接收的元素在环形队列中的位置
	recvq    waitq          // 接收者的等待队列
	sendq    waitq          // 发送者的等待队列

	// lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。
	// 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， 
    // 因为这会因为堆栈 shrinking 而发生死锁。
	lock mutex
}


recvq 和 sendq 是等待队列，waitq 类型是一个双向链表："><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/go-channel/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-11-21T09:45:13+08:00"><meta property="article:modified_time" content="2022-11-21T09:45:13+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go channel"><meta name=twitter:description content="数据结构
channel 的底层源码和相关实现在/src/runtime/chan.go中。
type hchan struct {
	qcount   uint           // 队列中所有数据总数
	dataqsiz uint           // 环形队列的 size
	buf      unsafe.Pointer // 指向 dataqsiz 长度的数组
	elemsize uint16         // 元素大小
	closed   uint32
	elemtype *_type         // 元素类型
	sendx    uint           // 已发送的元素在环形队列中的位置
	recvx    uint           // 已接收的元素在环形队列中的位置
	recvq    waitq          // 接收者的等待队列
	sendq    waitq          // 发送者的等待队列

	// lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。
	// 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， 
    // 因为这会因为堆栈 shrinking 而发生死锁。
	lock mutex
}


recvq 和 sendq 是等待队列，waitq 类型是一个双向链表："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Go channel","item":"https://www.yici.xin/post/tech/go-channel/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go channel","name":"Go channel","description":"数据结构 channel 的底层源码和相关实现在/src/runtime/chan.go中。\ntype hchan struct { qcount uint // 队列中所有数据总数 dataqsiz uint // 环形队列的 size buf unsafe.Pointer // 指向 dataqsiz 长度的数组 elemsize uint16 // 元素大小 closed uint32 elemtype *_type // 元素类型 sendx uint // 已发送的元素在环形队列中的位置 recvx uint // 已接收的元素在环形队列中的位置 recvq waitq // 接收者的等待队列 sendq waitq // 发送者的等待队列 // lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。 // 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， // 因为这会因为堆栈 shrinking 而发生死锁。 lock mutex } recvq 和 sendq 是等待队列，waitq 类型是一个双向链表：\n","keywords":["channel","golang"],"articleBody":"数据结构 channel 的底层源码和相关实现在/src/runtime/chan.go中。\ntype hchan struct { qcount uint // 队列中所有数据总数 dataqsiz uint // 环形队列的 size buf unsafe.Pointer // 指向 dataqsiz 长度的数组 elemsize uint16 // 元素大小 closed uint32 elemtype *_type // 元素类型 sendx uint // 已发送的元素在环形队列中的位置 recvx uint // 已接收的元素在环形队列中的位置 recvq waitq // 接收者的等待队列 sendq waitq // 发送者的等待队列 // lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。 // 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， // 因为这会因为堆栈 shrinking 而发生死锁。 lock mutex } recvq 和 sendq 是等待队列，waitq 类型是一个双向链表：\ntype waitq struct { first *sudog last *sudog } // sudog 表示一个在等待列表中的g, 例如在一个channel上等待发送/接收. // sudog 是 Go 中非常重要的数据结构. // g 与同步对象关系可以是多对多的，一个 g 能出现在许多等待队列上(例如使用select等待多个channel)，因此一个 g 可能有很多sudog。 // 并且多个 g 可能正在等待同一个同步对象(多个协程等待同一个channel)，因此一个对象可能有许多 sudog。 // sudog 是从特殊池中分配出来的。使用 acquireSudog 和 releaseSudog 分配和释放它们。 type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. g *g next *sudog prev *sudog elem unsafe.Pointer // data element (may point to stack) // 以下的三个字段永远不会被同时访问. // 对channel来说，waitlink仅允许g访问. // 对semaphores来说，只有在持有semaRoot锁的时候才能访问这三个字段. acquiretime int64 releasetime int64 ticket uint32 // isSelect 表示 g 是否被选择. // g.selectDone 必须进行 CAS 才能在被唤醒的竞争中胜出. isSelect bool // success 表示 channel c 上的通信是否成功. // 如果goroutine因channel上派发了一个值而被唤醒，success为true， // 如果是因为channel关闭而唤醒，则为false success bool parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot c *hchan // channel } 创建channel 创建channel的函数位于/src/runtime/chan.go:72\ntype chantype struct { typ _type elem *_type dir uintptr } // params: // t: channel的类型源数据 // size: channel的大小， 对应hchan中dataqsiz大小 func makechan(t *chantype, size int) *hchan { elem := t.elem // 编译器检查数据项大小不能超过 64KB if elem.size \u003e= 1\u003c\u003c16 { throw(\"makechan: invalid channel element type\") } // 检查对齐是否正确 if hchanSize%maxAlign != 0 || elem.align \u003e maxAlign { throw(\"makechan: bad alignment\") } // 缓冲区大小检查，判断是否溢出 mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u003e maxAlloc-hchanSize || size \u003c 0 { panic(plainError(\"makechan: size out of range\")) } var c *hchan switch { case mem == 0: // mem为0，则代表队列或者元素大小为zero. c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race 竞争检查利用这个地址来进行同步操作. c.buf = c.raceaddr() case elem.ptrdata == 0: // 元素不包含指针，使用连续的内存空间一次性分配hchan和buf所需的内存 c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // 元素包含指针 c = new(hchan) c.buf = mallocgc(mem, elem, true) } // 设置属性 c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) if debugChan { print(\"makechan: chan=\", c, \"; elemsize=\", elem.size, \"; dataqsiz=\", size, \"\\n\") } return c } 上面这段 makechan() 代码主要目的是生成 *hchan对象。重点关注 switch-case 中的 3 种情况\n当队列或者元素大小为 0 时，调用 mallocgc() 在堆上为 channel 开辟一段大小为 hchanSize 的内存空间。 当元素类型不是指针类型时，调用 mallocgc() 在堆上开辟为 channel 和底层 buf 缓冲区数组开辟一段大小为 hchanSize + mem 连续的内存空间。 默认情况元素类型中有指针类型，调用 mallocgc() 在堆上分别为 channel 和 buf 缓冲区分配内存。 完成第一步的内存分配之后，再就是 hchan 数据结构其他字段的初始化和 lock 的初始化。值得说明的一点是，当存储在 buf 中的元素不包含指针时，Hchan 中也不包含 GC 关心的指针。buf 指向一段相同元素类型的内存，elemtype 固定不变。 SudoG 是从它们自己的线程中引用的，因此垃圾回收的时候无法回收它们。受到垃圾回收器的限制，指针类型的缓冲 buf 需要单独分配内存。官方在这里加了一个 TODO，垃圾回收的时候这段代码逻辑需要重新考虑。\n因为 channel 的创建全部调用的 mallocgc()，在堆上开辟的内存空间，channel 本身会被 GC 自动回收。有了这一性质，所以才有了下文关闭 channel 中优雅关闭的方法。 发送数据 往channel发送数据的代码在/src/runtime/chan.go:159.\n异常检查 // params: // c: chansend所操作的channel // ep: 发送的值 // block: 是否阻塞发送，即同步还是异步 // callerpc: 调用者的pc寄存器地址 func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // 判断channel是否为nil, 朝一个为 nil 的 channel 发送数据会发生阻塞。 // gopark 会引发以 waitReasonChanSendNilChan 为原因的休眠，并抛出 unreachable 的 fatal error。 if c == nil { if !block { return false } gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\"unreachable\") } if debugChan { print(\"chansend: chan=\", c, \"\\n\") } if raceenabled { racereadpc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(chansend)) } // 无锁快速检测失败的非阻塞操作 if !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c) { return false } ... full的代码:\n// full反映在c上的一个send是否会阻塞(即channel是否已满) func full(c *hchan) bool { // c.dataqsiz 是不可变的，所以在channel创建后，该值都是可以安全读取的 if c.dataqsiz == 0 { return c.recvq.first == nil } return c.qcount == c.dataqsiz } 这段检查失败的非阻塞操作并没有上锁，而是在检查之后进行的上锁操作。这个原因在源码中有注释进行了阐述，我进行一下润色解释： !block \u0026\u0026 c.closed == 0 \u0026\u0026 full(c)，在这个判断中，我们第一步先观察channel的未关闭状态，第二步观察channel是否full，这两步中的读取操作都是单字大小的读取(你可以认为这两步单独读取都是原子性的)。\n问题在于不加锁的情况下，第一步和第二步中间，可能发生状态改变，即在观察到channel未关闭后，在观察full的过程中，channel被关闭了。 原本在channel未关闭+full的情况下，应return false快速结束，如果中间channel被关闭了，我们该向下继续执行触发panic，但在这里直接return false也无不妥\n一个已关闭的channel是不会从未满转变成已满的(因为向已经为nil的channel进行send是不允许的)，也就是close后，full的结果不会从false转变为true.\n同步发送 进行完检查，接下来就是发送逻辑\n... lock(\u0026c.lock) // 上锁后检查channel是否关闭，如果已关闭，产生panic. if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"send on closed channel\")) } if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true } ... 先寻找是否存在正在等待的接收者，通过dequeue() 取出recvq队列头部第一个的sudog，如果不为空代表存在，此时直接将值send给该接收者。\nsend:\nfunc (q *waitq) dequeue() *sudog { for { // 链表取头 sgp := q.first if sgp == nil { return nil } y := sgp.next if y == nil { q.first = nil q.last = nil } else { y.prev = nil q.first = y sgp.next = nil // mark as removed (see dequeueSudog) } // 如果这个g是因select而加入的这个channel等待队列，那么它可能同时等待了多个channel， // 所以使用cas操作将selectDone置为1，表示这个g已经被唤醒了。 if sgp.isSelect \u0026\u0026 !atomic.Cas(\u0026sgp.g.selectDone, 0, 1) { continue } return sgp } } func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // 竞态分析代码省略... if sg.elem != nil { sendDirect(c.elemtype, sg, ep) sg.elem = nil } gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 主要关注两件事：\n调用 sendDirect() 将数据ep拷贝到了接受者sudog的elem字段中 调用 goready() 将等待接收的阻塞 goroutine 的状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable。下一轮调度时会唤醒这个接收的 goroutine。 func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) { // src is on our stack, dst is a slot on another stack. // Once we read sg.elem out of sg, it will no longer // be updated if the destination's stack gets copied (shrunk). // So make sure that no preemption points can happen between read \u0026 use. dst := sg.elem typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size) // No need for cgo write barrier checks because dst is always // Go memory. memmove(dst, src, t.size) } 异步发送 如果没有正在等待的接收者，并且channel有缓冲，会进行异步的发送.\nif c.qcount \u003c c.dataqsiz { // channel缓存区还有空间，将要send的元素入队. qp := chanbuf(c, c.sendx) ... typedmemmove(c.elemtype, qp, ep) c.sendx++ if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ unlock(\u0026c.lock) return true } 调用chanbuf可以获取 sendx 索引的元素指针值，再调用typedmemmove将该值拷贝到buf中对应的位置。拷贝完成后，需要维护 sendx 索引下标值和 qcount 个数。这里将 buf 缓冲区设计成环形的，索引值如果到了队尾，下一个位置重新回到队头。 阻塞发送 如果没有成功进行同步或异步的发送，代表该channel此时没有正在等待的接收者，且buf已经满了，如果调用者选择非阻塞式的发送，chansend会立即返回false。 如果选择阻塞式发送：\n... // 如果选择非阻塞式的发送，chansend会立即返回false if !block { unlock(\u0026c.lock) return false } // 获取当前g gp := getg() // 获取一个sudog，可能是新建的，也可能是从缓存中复用的 mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil // 将sudog入队 c.sendq.enqueue(mysg) // 设置原子信号。当栈要 shrink 收缩时，这个标记代表当前 goroutine 还 parking 停在某个 channel 中。 // 在 g 状态变更与设置 activeStackChans 状态这两个时间点之间的时间窗口进行栈 shrink 收缩是不安全的，所以需要设置这个原子信号。 atomic.Store8(\u0026gp.parkingOnChan, 1) // 调用 gopark 方法挂起当前 goroutine，状态为 waitReasonChanSend，阻塞等待 channel。 gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // 最后，KeepAlive() 确保发送的值保持活动状态，直到接收者将其复制出来 KeepAlive(ep) ... sudog的二级缓存设计 func acquireSudog() *sudog { // 获取当前m mp := acquirem() // 获取当前p pp := mp.p.ptr() // 如果p上的本地缓存为空 if len(pp.sudogcache) == 0 { // 上锁后尝试从中心缓存获取一批 lock(\u0026sched.sudoglock) for len(pp.sudogcache) \u003c cap(pp.sudogcache)/2 \u0026\u0026 sched.sudogcache != nil { s := sched.sudogcache sched.sudogcache = s.next s.next = nil pp.sudogcache = append(pp.sudogcache, s) } unlock(\u0026sched.sudoglock) // 如果中心缓存为空，获取失败，直接进行分配 if len(pp.sudogcache) == 0 { pp.sudogcache = append(pp.sudogcache, new(sudog)) } } // 如果本地缓存不为空，直接从本地缓存获取 n := len(pp.sudogcache) s := pp.sudogcache[n-1] pp.sudogcache[n-1] = nil pp.sudogcache = pp.sudogcache[:n-1] if s.elem != nil { throw(\"acquireSudog: found s.elem != nil in cache\") } releasem(mp) return s } sched.sudogcache 是全局中央缓存，可以认为它是“一级缓存”，它会在 GC 垃圾回收执行 clearpools 被清理。p.sudogcache 可以认为它是“二级缓存”，是本地缓存不会被 GC 清理掉。\n发送收尾 chansend 最后的代码逻辑是当 goroutine 唤醒以后，解除阻塞的状态：\n// someone woke us up. if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) if closed { if c.closed == 0 { throw(\"chansend: spurious wakeup\") } panic(plainError(\"send on closed channel\")) } return true sudog 算是对 g 的一种封装，里面包含了 g，要发送的数据以及相关的状态。goroutine 被唤醒后会完成 channel 的阻塞数据发送。发送完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog。\nsudog的释放:\nfunc releaseSudog(s *sudog) { if s.elem != nil { throw(\"runtime: sudog with non-nil elem\") } if s.isSelect { throw(\"runtime: sudog with non-false isSelect\") } if s.next != nil { throw(\"runtime: sudog with non-nil next\") } if s.prev != nil { throw(\"runtime: sudog with non-nil prev\") } if s.waitlink != nil { throw(\"runtime: sudog with non-nil waitlink\") } if s.c != nil { throw(\"runtime: sudog with non-nil c\") } // 获取当前g gp := getg() if gp.param != nil { throw(\"runtime: releaseSudog with non-nil gp.param\") } // 获取当前m mp := acquirem() // avoid rescheduling to another P // 获取当前p pp := mp.p.ptr() if len(pp.sudogcache) == cap(pp.sudogcache) { // 如果本地sudog缓存已满，迁移一半的sudog到全局中心缓存 var first, last *sudog for len(pp.sudogcache) \u003e cap(pp.sudogcache)/2 { n := len(pp.sudogcache) p := pp.sudogcache[n-1] pp.sudogcache[n-1] = nil pp.sudogcache = pp.sudogcache[:n-1] if first == nil { first = p } else { last.next = p } last = p } lock(\u0026sched.sudoglock) last.next = sched.sudogcache sched.sudogcache = first unlock(\u0026sched.sudoglock) } // 直接加到本地sudog缓存 pp.sudogcache = append(pp.sudogcache, s) releasem(mp) } 小结 Channel Status Result Write nil 阻塞 Write open and full 阻塞 Write open and not full success Write colsed panic Write read only compiler error 当接收队列中存在 sudog 可以直接发送数据时，执行 goready()将 g 插入 runnext 插槽中，状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable，等待下次调度便立即运行。 当 channel 阻塞时，执行 gopark() 将 g 阻塞，让出 cpu 的使用权。 需要强调的是，通道并不提供跨 goroutine 的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的是指向数据的指针时，如果读和写是由不同的 goroutine 完成的，那么每个 goroutine 依旧需要额外的同步操作。\n\u003c!DOCTYPE HTML\u003e 接收数据 channel接收数据的代码在/src/runtime/chan.go:455.\n异常检查 和send一样，一开始也是一段检查代码，\n// chanrecv用于在c上接收值并赋值给ep，block决定是否阻塞 func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if debugChan { print(\"chanrecv: chan=\", c, \"\\n\") } if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\"unreachable\") } // 无锁异常检查 // 非阻塞且channel为空 if !block \u0026\u0026 empty(c) { if atomic.Load(\u0026c.closed) == 0 { // 如果channel为空且未关闭，表示没有数据可接收,可直接return return } // 在并发情况下，可能会在第一次观察到为空后，第二次观察之前，新增了数据 if empty(c) { if raceenabled { raceacquire(c.raceaddr()) } // 如果 channel 已经关闭且不存在缓存数据了，则清理 ep 指针中的数据并返回。这里也是从已经关闭的 channel 中读数据，读出来的是该类型零值的原因。 if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } ... } 同步接收 if sg := c.sendq.dequeue(); sg != nil { // 存在等待中的sender。如果缓冲区大小为 0，则直接从sender接收值. // 否则，代表缓冲区已满，从队列头部接收并将sender的值添加到队列尾部. recv(c, sg, ep, func() { unlock(\u0026c.lock) }, 3) return true, true } 📢要注意一点，存在等待中的发送者，如果channel有缓冲区，那缓冲区一定是满的。\nfunc recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) { // channel无缓冲区，将sender的值赋给ep if c.dataqsiz == 0 { if raceenabled { racesync(c, sg) } if ep != nil { // copy data from sender recvDirect(c.elemtype, sg, ep) } } else { // 进入这部分代码代表channel存在缓冲区且已满. // buf中队首位置的那一个值 qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) racenotify(c, c.recvx, sg) } // 将qp值赋给ep if ep != nil { typedmemmove(c.elemtype, ep, qp) } // 将sender的中的值赋给qp typedmemmove(c.elemtype, qp, sg.elem) // 队首指针++，qp对应的位置成了队尾 c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } // 队满的情况下sendx和recvx相等 c.sendx = c.recvx // c.sendx = (c.sendx+1) % c.dataqsiz } // 修改sg状态，唤醒对应g sg.elem = nil gp := sg.g unlockf() gp.param = unsafe.Pointer(sg) sg.success = true if sg.releasetime != 0 { sg.releasetime = cputicks() } goready(gp, skip+1) } 异步接收 如果channel上没有等待中的sender，但是缓冲区上有数据时，那么就接收缓冲区内的数据\nif c.qcount \u003e 0 { qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026c.lock) return true, true } 这里没有什么好特别的。\n阻塞接收 当缓冲区内也没有数据时，如果选择了阻塞接收，此时只能进行等待\n// no sender available: block on this channel. // 获取当前g gp := getg() // 新建或从缓存获取sudog mysg := acquireSudog() // 设置sudog的值 mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // 将sudog加入channel的接收者队列 c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. // 设置原子信号。当栈要 shrink 收缩时，这个标记代表当前 goroutine 还 parking 停在某个 channel 中。 // 在 g 状态变更与设置 activeStackChans 状态这两个时间点之间的时间窗口进行栈 shrink 收缩是不安全的，所以需要设置这个原子信号。 atomic.Store8(\u0026gp.parkingOnChan, 1) // 调用 gopark 方法挂起当前 goroutine，状态为 waitReasonChanReceive，阻塞等待 channel gopark(chanparkcommit, unsafe.Pointer(\u0026c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) 这里和chansend中的阻塞部分几乎一样，但是作为接收方，不用KeepAlive(ep)来确保数据不被回收\n被唤醒后:\n// someone woke us up if mysg != gp.waiting { throw(\"G waiting list is corrupted\") } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u003e 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success goroutine 被唤醒后会完成 channel 的阻塞数据接收。接收完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog。\n小结 channel读取操作各状态:\nChannel status Result Read nil block Read open and not empty read success Read open and empty block Read closed default value,false Read read only Compole Error chanrecv 的返回值有几种情况：\ntmp, ok := \u003c-ch Channel status Selected Received nil false false open and not empty true true open and empty false false closed true false received值对应ok，selected 值不会被外部使用。 channel 接收过程中包含 2 次有关 goroutine 调度过程：\n当 channel 为 nil 时，执行 gopark() 挂起当前的 goroutine。 当发送队列中存在 sudog 可以直接接收数据时，执行 goready()将 g 插入 runnext 插槽中，状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable，等待下次调度便立即运行。 当 channel 缓冲区为空，且没有发送者时，执行 gopark() 将 g 阻塞，让出 cpu 的使用权并等待调度器的调度。 关闭channel 关闭channel的手段:\nclose(ch) 编译器会将其转换为/src/runtime/chan.go:356处的runtime.closechan() 方法。\n异常检查 func closechan(c *hchan) { if c == nil { panic(plainError(\"close of nil channel\")) } lock(\u0026c.lock) if c.closed != 0 { unlock(\u0026c.lock) panic(plainError(\"close of closed channel\")) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, abi.FuncPCABIInternal(closechan)) racerelease(c.raceaddr()) } c.closed = 1 如果channel为nil或者已关闭的话，panic。 否则，标记channel的closed字段为1。\n释放所有接收者和发送者 var glist gList // release all readers // 释放接收者，将等待队列recvq中的sudog清除，并把对应的g都加入到待清除队列 glist 中 for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026c.lock) 执行协程调度 // Ready all Gs now that we've dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } 最后会为所有被阻塞的 goroutine 调用 goready 触发调度。将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度。\n优雅关闭 “Channel 有几种优雅的关闭方法？” 这种问题常常出现在面试题中，究其原因是因为 Channel 创建容易，但是关闭“不易”：\n在不改变 Channel 自身状态的条件下，无法知道它是否已经关闭。“不易”之一，关闭时机未知。 如果一个 Channel 已经关闭，重复关闭 Channel 会导致 panic。“不易”之二，不能无脑关闭。 往一个 close 的 Channel 内写数据，也会导致 panic。“不易”之三，写数据之前也需要关注是否 close 的状态。 Channel status Result close nil panic close open and not empty 关闭 Channel；读取成功，直到 Channel 耗尽数据，然后读取产生值的默认值 close open and empty 关闭 Channel；读到生产者的默认值 close closed panic close read only Compile Error 那究竟什么时候关闭 Channel 呢？由上面三个“不易”，可以浓缩为 2 点：\n不能简单的从消费者侧关闭 Channel。 如果有多个生产者，它们不能关闭 Channel。 解释一下这 2 个问题。第一个问题，消费者不知道 Channel 何时该关闭。如果关闭了已经关闭的 Channel 会导致 panic。而且分布式应用通常有多个消费者，每个消费者的行为一致，这么多消费者都尝试关闭 Channel 必然会导致 panic。第二个问题，如果有多个生产者往 Channel 内写入数据，这些生产者的行为逻辑也都一致，如果其中一个生产者关闭了 Channel，其他的生产者还在往里写，这个时候会 panic。所以为了防止 panic，必须解决上面这 2 个问题。\ncontext 方式 done channel 方式 ","wordCount":"2276","inLanguage":"zh","datePublished":"2022-11-21T09:45:13+08:00","dateModified":"2022-11-21T09:45:13+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/go-channel/"},"publisher":{"@type":"Organization","name":"绝知","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="绝知 (Alt + H)">绝知</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Go channel</h1><div class=post-meta><span title='2022-11-21 09:45:13 +0800 +0800'>2022-11-21</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a></li><li><a href=#%e5%88%9b%e5%bb%bachannel aria-label=创建channel>创建channel</a></li><li><a href=#%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae aria-label=发送数据>发送数据</a><ul><li><a href=#%e5%bc%82%e5%b8%b8%e6%a3%80%e6%9f%a5 aria-label=异常检查>异常检查</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e5%8f%91%e9%80%81 aria-label=同步发送>同步发送</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e5%8f%91%e9%80%81 aria-label=异步发送>异步发送</a></li><li><a href=#%e9%98%bb%e5%a1%9e%e5%8f%91%e9%80%81 aria-label=阻塞发送>阻塞发送</a></li><li><a href=#sudog%e7%9a%84%e4%ba%8c%e7%ba%a7%e7%bc%93%e5%ad%98%e8%ae%be%e8%ae%a1 aria-label=sudog的二级缓存设计>sudog的二级缓存设计</a></li><li><a href=#%e5%8f%91%e9%80%81%e6%94%b6%e5%b0%be aria-label=发送收尾>发送收尾</a></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a></li></ul></li><li><a href=#%e6%8e%a5%e6%94%b6%e6%95%b0%e6%8d%ae aria-label=接收数据>接收数据</a><ul><li><a href=#%e5%bc%82%e5%b8%b8%e6%a3%80%e6%9f%a5-1 aria-label=异常检查>异常检查</a></li><li><a href=#%e5%90%8c%e6%ad%a5%e6%8e%a5%e6%94%b6 aria-label=同步接收>同步接收</a></li><li><a href=#%e5%bc%82%e6%ad%a5%e6%8e%a5%e6%94%b6 aria-label=异步接收>异步接收</a></li><li><a href=#%e9%98%bb%e5%a1%9e%e6%8e%a5%e6%94%b6 aria-label=阻塞接收>阻塞接收</a></li><li><a href=#%e5%b0%8f%e7%bb%93-1 aria-label=小结>小结</a></li></ul></li><li><a href=#%e5%85%b3%e9%97%adchannel aria-label=关闭channel>关闭channel</a><ul><li><a href=#%e5%bc%82%e5%b8%b8%e6%a3%80%e6%9f%a5-2 aria-label=异常检查>异常检查</a></li><li><a href=#%e9%87%8a%e6%94%be%e6%89%80%e6%9c%89%e6%8e%a5%e6%94%b6%e8%80%85%e5%92%8c%e5%8f%91%e9%80%81%e8%80%85 aria-label=释放所有接收者和发送者>释放所有接收者和发送者</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e5%8d%8f%e7%a8%8b%e8%b0%83%e5%ba%a6 aria-label=执行协程调度>执行协程调度</a></li><li><a href=#%e4%bc%98%e9%9b%85%e5%85%b3%e9%97%ad aria-label=优雅关闭>优雅关闭</a></li><li><a href=#context-%e6%96%b9%e5%bc%8f aria-label="context 方式">context 方式</a></li><li><a href=#done-channel-%e6%96%b9%e5%bc%8f aria-label="done channel 方式">done channel 方式</a></li></ul></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h2><p>channel 的底层源码和相关实现在/src/runtime/chan.go中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> hchan <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	qcount   <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 队列中所有数据总数</span>
</span></span><span style=display:flex><span>	dataqsiz <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 环形队列的 size</span>
</span></span><span style=display:flex><span>	buf      unsafe.Pointer <span style=color:#6272a4>// 指向 dataqsiz 长度的数组</span>
</span></span><span style=display:flex><span>	elemsize <span style=color:#8be9fd>uint16</span>         <span style=color:#6272a4>// 元素大小</span>
</span></span><span style=display:flex><span>	closed   <span style=color:#8be9fd>uint32</span>
</span></span><span style=display:flex><span>	elemtype <span style=color:#ff79c6>*</span>_type         <span style=color:#6272a4>// 元素类型</span>
</span></span><span style=display:flex><span>	sendx    <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 已发送的元素在环形队列中的位置</span>
</span></span><span style=display:flex><span>	recvx    <span style=color:#8be9fd>uint</span>           <span style=color:#6272a4>// 已接收的元素在环形队列中的位置</span>
</span></span><span style=display:flex><span>	recvq    waitq          <span style=color:#6272a4>// 接收者的等待队列</span>
</span></span><span style=display:flex><span>	sendq    waitq          <span style=color:#6272a4>// 发送者的等待队列</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// lock 锁保护 hchan 中的所有字段，以及此通道上被阻塞的 sudogs 中的多个字段。</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 持有 lock 的时候，禁止更改另一个 G 的状态（特别是不要使 G 状态变成ready）， </span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// 因为这会因为堆栈 shrinking 而发生死锁。</span>
</span></span><span style=display:flex><span>	lock mutex
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211291714199.png alt=hchan数据结构></p><p>recvq 和 sendq 是等待队列，waitq 类型是一个双向链表：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> waitq <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	first <span style=color:#ff79c6>*</span>sudog
</span></span><span style=display:flex><span>	last  <span style=color:#ff79c6>*</span>sudog
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// sudog 表示一个在等待列表中的g, 例如在一个channel上等待发送/接收.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// sudog 是 Go 中非常重要的数据结构.</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// g 与同步对象关系可以是多对多的，一个 g 能出现在许多等待队列上(例如使用select等待多个channel)，因此一个 g 可能有很多sudog。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// 并且多个 g 可能正在等待同一个同步对象(多个协程等待同一个channel)，因此一个对象可能有许多 sudog。</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// sudog 是从特殊池中分配出来的。使用 acquireSudog 和 releaseSudog 分配和释放它们。</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> sudog <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// The following fields are protected by the hchan.lock of the</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// channel this sudog is blocking on. shrinkstack depends on</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// this for sudogs involved in channel ops.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	g <span style=color:#ff79c6>*</span>g
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	next <span style=color:#ff79c6>*</span>sudog
</span></span><span style=display:flex><span>	prev <span style=color:#ff79c6>*</span>sudog
</span></span><span style=display:flex><span>	elem unsafe.Pointer <span style=color:#6272a4>// data element (may point to stack)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 以下的三个字段永远不会被同时访问.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 对channel来说，waitlink仅允许g访问.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 对semaphores来说，只有在持有semaRoot锁的时候才能访问这三个字段.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	acquiretime <span style=color:#8be9fd>int64</span>
</span></span><span style=display:flex><span>	releasetime <span style=color:#8be9fd>int64</span>
</span></span><span style=display:flex><span>	ticket      <span style=color:#8be9fd>uint32</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// isSelect 表示 g 是否被选择.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// g.selectDone 必须进行 CAS 才能在被唤醒的竞争中胜出.</span>
</span></span><span style=display:flex><span>	isSelect <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// success 表示 channel c 上的通信是否成功.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 如果goroutine因channel上派发了一个值而被唤醒，success为true，</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 如果是因为channel关闭而唤醒，则为false</span>
</span></span><span style=display:flex><span>	success <span style=color:#8be9fd>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	parent   <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// semaRoot binary tree</span>
</span></span><span style=display:flex><span>	waitlink <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// g.waiting list or semaRoot</span>
</span></span><span style=display:flex><span>	waittail <span style=color:#ff79c6>*</span>sudog <span style=color:#6272a4>// semaRoot</span>
</span></span><span style=display:flex><span>	c        <span style=color:#ff79c6>*</span>hchan <span style=color:#6272a4>// channel</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=创建channel>创建channel<a hidden class=anchor aria-hidden=true href=#创建channel>#</a></h2><p>创建channel的函数位于/src/runtime/chan.go:72</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>type</span> chantype <span style=color:#8be9fd;font-style:italic>struct</span> {
</span></span><span style=display:flex><span>	typ  _type
</span></span><span style=display:flex><span>	elem <span style=color:#ff79c6>*</span>_type
</span></span><span style=display:flex><span>	dir  <span style=color:#8be9fd>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// params:</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// t: channel的类型源数据</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// size: channel的大小， 对应hchan中dataqsiz大小</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>makechan</span>(t <span style=color:#ff79c6>*</span>chantype, size <span style=color:#8be9fd>int</span>) <span style=color:#ff79c6>*</span>hchan {
</span></span><span style=display:flex><span>	elem <span style=color:#ff79c6>:=</span> t.elem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 编译器检查数据项大小不能超过 64KB</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> elem.size <span style=color:#ff79c6>&gt;=</span> <span style=color:#bd93f9>1</span><span style=color:#ff79c6>&lt;&lt;</span><span style=color:#bd93f9>16</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;makechan: invalid channel element type&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 检查对齐是否正确</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> hchanSize<span style=color:#ff79c6>%</span>maxAlign <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>||</span> elem.align &gt; maxAlign {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;makechan: bad alignment&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 缓冲区大小检查，判断是否溢出</span>
</span></span><span style=display:flex><span>	mem, overflow <span style=color:#ff79c6>:=</span> math.<span style=color:#50fa7b>MulUintptr</span>(elem.size, <span style=color:#8be9fd;font-style:italic>uintptr</span>(size))
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> overflow <span style=color:#ff79c6>||</span> mem &gt; maxAlloc<span style=color:#ff79c6>-</span>hchanSize <span style=color:#ff79c6>||</span> size &lt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;makechan: size out of range&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> c <span style=color:#ff79c6>*</span>hchan
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>switch</span> {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> mem <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// mem为0，则代表队列或者元素大小为zero.</span>
</span></span><span style=display:flex><span>		c = (<span style=color:#ff79c6>*</span>hchan)(<span style=color:#50fa7b>mallocgc</span>(hchanSize, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>true</span>))
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Race 竞争检查利用这个地址来进行同步操作.</span>
</span></span><span style=display:flex><span>		c.buf = c.<span style=color:#50fa7b>raceaddr</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>case</span> elem.ptrdata <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 元素不包含指针，使用连续的内存空间一次性分配hchan和buf所需的内存</span>
</span></span><span style=display:flex><span>		c = (<span style=color:#ff79c6>*</span>hchan)(<span style=color:#50fa7b>mallocgc</span>(hchanSize<span style=color:#ff79c6>+</span>mem, <span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>true</span>))
</span></span><span style=display:flex><span>		c.buf = <span style=color:#50fa7b>add</span>(unsafe.<span style=color:#50fa7b>Pointer</span>(c), hchanSize)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 元素包含指针</span>
</span></span><span style=display:flex><span>		c = <span style=color:#8be9fd;font-style:italic>new</span>(hchan)
</span></span><span style=display:flex><span>		c.buf = <span style=color:#50fa7b>mallocgc</span>(mem, elem, <span style=color:#ff79c6>true</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置属性</span>
</span></span><span style=display:flex><span>	c.elemsize = <span style=color:#8be9fd;font-style:italic>uint16</span>(elem.size)
</span></span><span style=display:flex><span>	c.elemtype = elem
</span></span><span style=display:flex><span>	c.dataqsiz = <span style=color:#8be9fd;font-style:italic>uint</span>(size)
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>lockInit</span>(<span style=color:#ff79c6>&amp;</span>c.lock, lockRankHchan)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> debugChan {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;makechan: chan=&#34;</span>, c, <span style=color:#f1fa8c>&#34;; elemsize=&#34;</span>, elem.size, <span style=color:#f1fa8c>&#34;; dataqsiz=&#34;</span>, size, <span style=color:#f1fa8c>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面这段 makechan() 代码主要目的是生成 <code>*hchan</code>对象。重点关注 switch-case 中的 3 种情况</p><ul><li>当队列或者元素大小为 0 时，调用 mallocgc() 在堆上为 channel 开辟一段大小为 hchanSize 的内存空间。</li><li>当元素类型不是指针类型时，调用 mallocgc() 在堆上开辟为 channel 和底层 buf 缓冲区数组开辟一段大小为 hchanSize + mem 连续的内存空间。</li><li>默认情况元素类型中有指针类型，调用 mallocgc() 在堆上分别为 channel 和 buf 缓冲区分配内存。</li></ul><p>完成第一步的内存分配之后，再就是 hchan 数据结构其他字段的初始化和 lock 的初始化。值得说明的一点是，当存储在 buf 中的元素不包含指针时，Hchan 中也不包含 GC 关心的指针。buf 指向一段相同元素类型的内存，elemtype 固定不变。
<strong>SudoG 是从它们自己的线程中引用的，因此垃圾回收的时候无法回收它们。受到垃圾回收器的限制，指针类型的缓冲 buf 需要单独分配内存。官方在这里加了一个 TODO，垃圾回收的时候这段代码逻辑需要重新考虑。</strong></p><style type=text/css media=screen>html{--color-alert-info-text:#24292e;--color-alert-info-bg:#dbedff;--color-alert-info-border:rgba(4, 66, 137, 0.2);--color-alert-warn-text:#24292e;--color-alert-warn-bg:#fffbdd;--color-alert-warn-border:rgba(176, 136, 0, 0.2);--color-alert-error-text:#24292e;--color-alert-error-bg:#ffe3e6;--color-alert-error-border:rgba(158, 28, 35, 0.2);--color-alert-success-text:#24292e;--color-alert-success-bg:#dcffe4;--color-alert-success-border:rgba(23, 111, 44, 0.2)}html[data-theme=dark]{--color-alert-info-text:#79c0ff;--color-alert-info-bg:rgba(56, 139, 253, 0.1);--color-alert-info-border:rgba(56, 139, 253, 0.4);--color-alert-warn-text:#e3b341;--color-alert-warn-bg:rgba(187, 128, 9, 0.1);--color-alert-warn-border:rgba(187, 128, 9, 0.4);--color-alert-error-text:#ff7b72;--color-alert-error-bg:rgba(248, 81, 73, 0.1);--color-alert-error-border:rgba(248, 81, 73, 0.4);--color-alert-success-text:#56d364;--color-alert-success-bg:rgba(46, 160, 67, 0.1);--color-alert-success-border:rgba(46, 160, 67, 0.4)}.tips{position:relative;padding:20px 16px;margin-bottom:20px;border-style:solid;border-width:1px;border-radius:6px;border-left-style:solid;border-left-width:6px}.tips.info{color:var(--color-alert-info-text);background-image:linear-gradient(var(--color-alert-info-bg),var(--color-alert-info-bg));border-color:var(--color-alert-info-border)}.tips.warn{color:var(--color-alert-warn-text);background-image:linear-gradient(var(--color-alert-warn-bg),var(--color-alert-warn-bg));border-color:var(--color-alert-warn-border)}.tips.error{color:var(--color-alert-error-text);background-image:linear-gradient(var(--color-alert-error-bg),var(--color-alert-error-bg));border-color:var(--color-alert-error-border)}.tips.success{color:var(--color-alert-success-text);background-image:linear-gradient(var(--color-alert-success-bg),var(--color-alert-success-bg));border-color:var(--color-alert-success-border)}#tips-title{font-size:19px;font-weight:800;margin-bottom:10px}</style><div class="tips info">因为 channel 的创建全部调用的 mallocgc()，在堆上开辟的内存空间，channel 本身会被 GC 自动回收。有了这一性质，所以才有了下文关闭 channel 中优雅关闭的方法。</div><h2 id=发送数据>发送数据<a hidden class=anchor aria-hidden=true href=#发送数据>#</a></h2><p>往channel发送数据的代码在/src/runtime/chan.go:159.</p><h3 id=异常检查>异常检查<a hidden class=anchor aria-hidden=true href=#异常检查>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// params:</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// c: chansend所操作的channel</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// ep: 发送的值</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// block: 是否阻塞发送，即同步还是异步</span>
</span></span><span style=display:flex><span><span style=color:#6272a4>// callerpc: 调用者的pc寄存器地址</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chansend</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>, callerpc <span style=color:#8be9fd>uintptr</span>) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 判断channel是否为nil, 朝一个为 nil 的 channel 发送数据会发生阻塞。</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// gopark 会引发以 waitReasonChanSendNilChan 为原因的休眠，并抛出 unreachable 的 fatal error。</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !block {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>gopark</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> debugChan {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;chansend: chan=&#34;</span>, c, <span style=color:#f1fa8c>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racereadpc</span>(c.<span style=color:#50fa7b>raceaddr</span>(), callerpc, abi.<span style=color:#50fa7b>FuncPCABIInternal</span>(chansend))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 无锁快速检测失败的非阻塞操作</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !block <span style=color:#ff79c6>&amp;&amp;</span> c.closed <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>full</span>(c) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>...</span>
</span></span></code></pre></div><p>full的代码:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// full反映在c上的一个send是否会阻塞(即channel是否已满)</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>full</span>(c <span style=color:#ff79c6>*</span>hchan) <span style=color:#8be9fd>bool</span> {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// c.dataqsiz 是不可变的，所以在channel创建后，该值都是可以安全读取的</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.dataqsiz <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> c.recvq.first <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> c.qcount <span style=color:#ff79c6>==</span> c.dataqsiz
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="tips warn"><p>这段检查<strong>失败的非阻塞操作</strong>并没有上锁，而是在检查之后进行的上锁操作。这个原因在源码中有注释进行了阐述，我进行一下润色解释：
<code>!block && c.closed == 0 && full(c)</code>，在这个判断中，我们第一步先观察channel的未关闭状态，第二步观察channel是否full，这两步中的读取操作都是单字大小的读取(你可以认为这两步单独读取都是原子性的)。</p><p>问题在于不加锁的情况下，第一步和第二步中间，可能发生状态改变，即在观察到channel未关闭后，在观察full的过程中，channel被关闭了。
原本在channel未关闭+full的情况下，应return false快速结束，如果中间channel被关闭了，我们该向下继续执行触发panic，但在这里直接return false也无不妥</p><p>一个已关闭的channel是不会从<strong>未满</strong>转变成<strong>已满</strong>的(因为向已经为nil的channel进行send是不允许的)，也就是close后，full的结果不会从false转变为true.</p></div><h3 id=同步发送>同步发送<a hidden class=anchor aria-hidden=true href=#同步发送>#</a></h3><p>进行完检查，接下来就是发送逻辑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 上锁后检查channel是否关闭，如果已关闭，产生panic.</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>:=</span> c.recvq.<span style=color:#50fa7b>dequeue</span>(); sg <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// Found a waiting receiver. We pass the value we want to send</span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// directly to the receiver, bypassing the channel buffer (if any).</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>send</span>(c, sg, ep, <span style=color:#8be9fd;font-style:italic>func</span>() { <span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock) }, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>
</span></span></code></pre></div><p>先寻找是否存在正在等待的接收者，通过dequeue() 取出recvq队列头部第一个的sudog，如果不为空代表存在，此时直接将值send给该接收者。</p><p>send:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> (q <span style=color:#ff79c6>*</span>waitq) <span style=color:#50fa7b>dequeue</span>() <span style=color:#ff79c6>*</span>sudog {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 链表取头</span>
</span></span><span style=display:flex><span>		sgp <span style=color:#ff79c6>:=</span> q.first
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sgp <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		y <span style=color:#ff79c6>:=</span> sgp.next
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> y <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			q.first = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>			q.last = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>			y.prev = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>			q.first = y
</span></span><span style=display:flex><span>			sgp.next = <span style=color:#ff79c6>nil</span> <span style=color:#6272a4>// mark as removed (see dequeueSudog)</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 如果这个g是因select而加入的这个channel等待队列，那么它可能同时等待了多个channel，</span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 所以使用cas操作将selectDone置为1，表示这个g已经被唤醒了。</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sgp.isSelect <span style=color:#ff79c6>&amp;&amp;</span> !atomic.<span style=color:#50fa7b>Cas</span>(<span style=color:#ff79c6>&amp;</span>sgp.g.selectDone, <span style=color:#bd93f9>0</span>, <span style=color:#bd93f9>1</span>) {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>continue</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> sgp
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>send</span>(c <span style=color:#ff79c6>*</span>hchan, sg <span style=color:#ff79c6>*</span>sudog, ep unsafe.Pointer, unlockf <span style=color:#8be9fd;font-style:italic>func</span>(), skip <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 竞态分析代码省略...</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>sendDirect</span>(c.elemtype, sg, ep)
</span></span><span style=display:flex><span>		sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlockf</span>()
</span></span><span style=display:flex><span>	gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>	sg.success = <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>goready</span>(gp, skip<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>主要关注两件事：</p><ul><li><ol><li>调用 sendDirect() 将数据ep拷贝到了接受者sudog的elem字段中</li></ol></li><li><ol start=2><li>调用 goready() 将等待接收的阻塞 goroutine 的状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable。下一轮调度时会唤醒这个接收的 goroutine。</li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>sendDirect</span>(t <span style=color:#ff79c6>*</span>_type, sg <span style=color:#ff79c6>*</span>sudog, src unsafe.Pointer) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// src is on our stack, dst is a slot on another stack.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Once we read sg.elem out of sg, it will no longer</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// be updated if the destination&#39;s stack gets copied (shrunk).</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// So make sure that no preemption points can happen between read &amp; use.</span>
</span></span><span style=display:flex><span>	dst <span style=color:#ff79c6>:=</span> sg.elem
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>typeBitsBulkBarrier</span>(t, <span style=color:#8be9fd;font-style:italic>uintptr</span>(dst), <span style=color:#8be9fd;font-style:italic>uintptr</span>(src), t.size)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// No need for cgo write barrier checks because dst is always</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Go memory.</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>memmove</span>(dst, src, t.size)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异步发送>异步发送<a hidden class=anchor aria-hidden=true href=#异步发送>#</a></h3><p>如果没有正在等待的接收者，并且channel有缓冲，会进行异步的发送.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.qcount &lt; c.dataqsiz {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// channel缓存区还有空间，将要send的元素入队.</span>
</span></span><span style=display:flex><span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.sendx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, qp, ep)
</span></span><span style=display:flex><span>		c.sendx<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.sendx <span style=color:#ff79c6>==</span> c.dataqsiz {
</span></span><span style=display:flex><span>			c.sendx = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.qcount<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>调用chanbuf可以获取 sendx 索引的元素指针值，再调用typedmemmove将该值拷贝到buf中对应的位置。拷贝完成后，需要维护 sendx 索引下标值和 qcount 个数。这里将 buf 缓冲区设计成环形的，索引值如果到了队尾，下一个位置重新回到队头。
<img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211301721328.png alt></p><h3 id=阻塞发送>阻塞发送<a hidden class=anchor aria-hidden=true href=#阻塞发送>#</a></h3><p>如果没有成功进行同步或异步的发送，代表该channel此时没有正在等待的接收者，且buf已经满了，如果调用者选择非阻塞式的发送，chansend会立即返回false。
如果选择阻塞式发送：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 如果选择非阻塞式的发送，chansend会立即返回false</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !block {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前g</span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取一个sudog，可能是新建的，也可能是从缓存中复用的</span>
</span></span><span style=display:flex><span>	mysg <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquireSudog</span>()
</span></span><span style=display:flex><span>	mysg.releasetime = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> t0 <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		mysg.releasetime = <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// No stack splits between assigning elem and enqueuing mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// on gp.waiting where copystack can find it.</span>
</span></span><span style=display:flex><span>	mysg.elem = ep
</span></span><span style=display:flex><span>	mysg.waitlink = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	mysg.g = gp
</span></span><span style=display:flex><span>	mysg.isSelect = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	mysg.c = c
</span></span><span style=display:flex><span>	gp.waiting = mysg
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 将sudog入队</span>
</span></span><span style=display:flex><span>	c.sendq.<span style=color:#50fa7b>enqueue</span>(mysg)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置原子信号。当栈要 shrink 收缩时，这个标记代表当前 goroutine 还 parking 停在某个 channel 中。</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 在 g 状态变更与设置 activeStackChans 状态这两个时间点之间的时间窗口进行栈 shrink 收缩是不安全的，所以需要设置这个原子信号。</span>
</span></span><span style=display:flex><span>	atomic.<span style=color:#50fa7b>Store8</span>(<span style=color:#ff79c6>&amp;</span>gp.parkingOnChan, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 调用 gopark 方法挂起当前 goroutine，状态为 waitReasonChanSend，阻塞等待 channel。</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>gopark</span>(chanparkcommit, unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>c.lock), waitReasonChanSend, traceEvGoBlockSend, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 最后，KeepAlive() 确保发送的值保持活动状态，直到接收者将其复制出来</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>KeepAlive</span>(ep)
</span></span><span style=display:flex><span><span style=color:#ff79c6>...</span>
</span></span></code></pre></div><h3 id=sudog的二级缓存设计>sudog的二级缓存设计<a hidden class=anchor aria-hidden=true href=#sudog的二级缓存设计>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>acquireSudog</span>() <span style=color:#ff79c6>*</span>sudog {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前m</span>
</span></span><span style=display:flex><span>	mp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquirem</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前p</span>
</span></span><span style=display:flex><span>	pp <span style=color:#ff79c6>:=</span> mp.p.<span style=color:#50fa7b>ptr</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 如果p上的本地缓存为空</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 上锁后尝试从中心缓存获取一批</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>sched.sudoglock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>for</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache) &lt; <span style=color:#8be9fd;font-style:italic>cap</span>(pp.sudogcache)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>2</span> <span style=color:#ff79c6>&amp;&amp;</span> sched.sudogcache <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			s <span style=color:#ff79c6>:=</span> sched.sudogcache
</span></span><span style=display:flex><span>			sched.sudogcache = s.next
</span></span><span style=display:flex><span>			s.next = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>			pp.sudogcache = <span style=color:#8be9fd;font-style:italic>append</span>(pp.sudogcache, s)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>sched.sudoglock)
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 如果中心缓存为空，获取失败，直接进行分配</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			pp.sudogcache = <span style=color:#8be9fd;font-style:italic>append</span>(pp.sudogcache, <span style=color:#8be9fd;font-style:italic>new</span>(sudog))
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 如果本地缓存不为空，直接从本地缓存获取</span>
</span></span><span style=display:flex><span>	n <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache)
</span></span><span style=display:flex><span>	s <span style=color:#ff79c6>:=</span> pp.sudogcache[n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>	pp.sudogcache[n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>] = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	pp.sudogcache = pp.sudogcache[:n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;acquireSudog: found s.elem != nil in cache&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releasem</span>(mp)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> s
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>sched.sudogcache 是全局中央缓存，可以认为它是“一级缓存”，它会在 GC 垃圾回收执行 clearpools 被清理。p.sudogcache 可以认为它是“二级缓存”，是本地缓存不会被 GC 清理掉。</p><h3 id=发送收尾>发送收尾<a hidden class=anchor aria-hidden=true href=#发送收尾>#</a></h3><p>chansend 最后的代码逻辑是当 goroutine 唤醒以后，解除阻塞的状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#6272a4>// someone woke us up.</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg <span style=color:#ff79c6>!=</span> gp.waiting {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.waiting = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp.activeStackChans = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	closed <span style=color:#ff79c6>:=</span> !mysg.success
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg.releasetime &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>blockevent</span>(mysg.releasetime<span style=color:#ff79c6>-</span>t0, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	mysg.c = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releaseSudog</span>(mysg)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> closed {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;chansend: spurious wakeup&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;send on closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>
</span></span></code></pre></div><p>sudog 算是对 g 的一种封装，里面包含了 g，要发送的数据以及相关的状态。goroutine 被唤醒后会完成 channel 的阻塞数据发送。发送完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog。</p><p>sudog的释放:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>releaseSudog</span>(s <span style=color:#ff79c6>*</span>sudog) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-nil elem&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.isSelect {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-false isSelect&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.next <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-nil next&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.prev <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-nil prev&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.waitlink <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-nil waitlink&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> s.c <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: sudog with non-nil c&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前g</span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> gp.param <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;runtime: releaseSudog with non-nil gp.param&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前m</span>
</span></span><span style=display:flex><span>	mp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquirem</span>() <span style=color:#6272a4>// avoid rescheduling to another P</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前p</span>
</span></span><span style=display:flex><span>	pp <span style=color:#ff79c6>:=</span> mp.p.<span style=color:#50fa7b>ptr</span>()
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache) <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>cap</span>(pp.sudogcache) {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 如果本地sudog缓存已满，迁移一半的sudog到全局中心缓存</span>
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>var</span> first, last <span style=color:#ff79c6>*</span>sudog
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>for</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache) &gt; <span style=color:#8be9fd;font-style:italic>cap</span>(pp.sudogcache)<span style=color:#ff79c6>/</span><span style=color:#bd93f9>2</span> {
</span></span><span style=display:flex><span>			n <span style=color:#ff79c6>:=</span> <span style=color:#8be9fd;font-style:italic>len</span>(pp.sudogcache)
</span></span><span style=display:flex><span>			p <span style=color:#ff79c6>:=</span> pp.sudogcache[n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>			pp.sudogcache[n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>] = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>			pp.sudogcache = pp.sudogcache[:n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>]
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> first <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>				first = p
</span></span><span style=display:flex><span>			} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>				last.next = p
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			last = p
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>sched.sudoglock)
</span></span><span style=display:flex><span>		last.next = sched.sudogcache
</span></span><span style=display:flex><span>		sched.sudogcache = first
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>sched.sudoglock)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 直接加到本地sudog缓存</span>
</span></span><span style=display:flex><span>	pp.sudogcache = <span style=color:#8be9fd;font-style:italic>append</span>(pp.sudogcache, s)
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releasem</span>(mp)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><table><thead><tr><th style=text-align:center></th><th style=text-align:center>Channel Status</th><th style=text-align:center>Result</th></tr></thead><tbody><tr><td style=text-align:center>Write</td><td style=text-align:center>nil</td><td style=text-align:center>阻塞</td></tr><tr><td style=text-align:center>Write</td><td style=text-align:center>open and full</td><td style=text-align:center>阻塞</td></tr><tr><td style=text-align:center>Write</td><td style=text-align:center>open and not full</td><td style=text-align:center>success</td></tr><tr><td style=text-align:center>Write</td><td style=text-align:center>colsed</td><td style=text-align:center>panic</td></tr><tr><td style=text-align:center>Write</td><td style=text-align:center>read only</td><td style=text-align:center>compiler error</td></tr></tbody></table><ul><li><ol><li>当接收队列中存在 sudog 可以直接发送数据时，执行 <code>goready()</code>将 g 插入 runnext 插槽中，状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable，等待下次调度便立即运行。</li></ol></li><li><ol start=2><li>当 channel 阻塞时，执行 <code>gopark()</code> 将 g 阻塞，让出 cpu 的使用权。</li></ol></li></ul><p>需要强调的是，通道并不提供跨 goroutine 的数据访问保护机制。如果通过通道传输数据的一份副本，那么每个 goroutine 都持有一份副本，各自对自己的副本做修改是安全的。当传输的是指向数据的指针时，如果读和写是由不同的 goroutine 完成的，那么每个 goroutine 依旧需要额外的同步操作。</p><!doctype html><html lang=en><head><style type=text/css>#chart{padding-bottom:66%;position:relative;display:block;width:100%;border-bottom:5px solid}#chart iframe{position:absolute;top:0;left:0}</style><title></title></head><body><div id=chart><iframe id=embed_dom width=100% height=100% name=embed_dom frameborder=0 src=https://www.processon.com/embed/63ec9f50344ada74c267c81f></iframe></div></body></html><h2 id=接收数据>接收数据<a hidden class=anchor aria-hidden=true href=#接收数据>#</a></h2><p>channel接收数据的代码在/src/runtime/chan.go:455.</p><h3 id=异常检查-1>异常检查<a hidden class=anchor aria-hidden=true href=#异常检查-1>#</a></h3><p>和send一样，一开始也是一段检查代码，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// chanrecv用于在c上接收值并赋值给ep，block决定是否阻塞</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>chanrecv</span>(c <span style=color:#ff79c6>*</span>hchan, ep unsafe.Pointer, block <span style=color:#8be9fd>bool</span>) (selected, received <span style=color:#8be9fd>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> debugChan {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>print</span>(<span style=color:#f1fa8c>&#34;chanrecv: chan=&#34;</span>, c, <span style=color:#f1fa8c>&#34;\n&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> !block {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>gopark</span>(<span style=color:#ff79c6>nil</span>, <span style=color:#ff79c6>nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;unreachable&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 无锁异常检查</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 非阻塞且channel为空</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> !block <span style=color:#ff79c6>&amp;&amp;</span> <span style=color:#50fa7b>empty</span>(c) {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> atomic.<span style=color:#50fa7b>Load</span>(<span style=color:#ff79c6>&amp;</span>c.closed) <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// 如果channel为空且未关闭，表示没有数据可接收,可直接return</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 在并发情况下，可能会在第一次观察到为空后，第二次观察之前，新增了数据</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> <span style=color:#50fa7b>empty</span>(c) {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>				<span style=color:#50fa7b>raceacquire</span>(c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// 如果 channel 已经关闭且不存在缓存数据了，则清理 ep 指针中的数据并返回。这里也是从已经关闭的 channel 中读数据，读出来的是该类型零值的原因。</span>
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>				<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, ep)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=同步接收>同步接收<a hidden class=anchor aria-hidden=true href=#同步接收>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>:=</span> c.sendq.<span style=color:#50fa7b>dequeue</span>(); sg <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 存在等待中的sender。如果缓冲区大小为 0，则直接从sender接收值.</span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 否则，代表缓冲区已满，从队列头部接收并将sender的值添加到队列尾部.</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>recv</span>(c, sg, ep, <span style=color:#8be9fd;font-style:italic>func</span>() { <span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock) }, <span style=color:#bd93f9>3</span>)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>📢要注意一点，存在等待中的发送者，如果channel有缓冲区，那缓冲区一定是满的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>recv</span>(c <span style=color:#ff79c6>*</span>hchan, sg <span style=color:#ff79c6>*</span>sudog, ep unsafe.Pointer, unlockf <span style=color:#8be9fd;font-style:italic>func</span>(), skip <span style=color:#8be9fd>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// channel无缓冲区，将sender的值赋给ep</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.dataqsiz <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racesync</span>(c, sg)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#6272a4>// copy data from sender</span>
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>recvDirect</span>(c.elemtype, sg, ep)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 进入这部分代码代表channel存在缓冲区且已满.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// buf中队首位置的那一个值</span>
</span></span><span style=display:flex><span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.recvx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, sg)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 将qp值赋给ep</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, ep, qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 将sender的中的值赋给qp</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, qp, sg.elem)
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 队首指针++，qp对应的位置成了队尾</span>
</span></span><span style=display:flex><span>		c.recvx<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.recvx <span style=color:#ff79c6>==</span> c.dataqsiz {
</span></span><span style=display:flex><span>			c.recvx = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#6272a4>// 队满的情况下sendx和recvx相等</span>
</span></span><span style=display:flex><span>		c.sendx = c.recvx <span style=color:#6272a4>// c.sendx = (c.sendx+1) % c.dataqsiz</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 修改sg状态，唤醒对应g</span>
</span></span><span style=display:flex><span>	sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlockf</span>()
</span></span><span style=display:flex><span>	gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>	sg.success = <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>goready</span>(gp, skip<span style=color:#ff79c6>+</span><span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异步接收>异步接收<a hidden class=anchor aria-hidden=true href=#异步接收>#</a></h3><p>如果channel上没有等待中的sender，但是缓冲区上有数据时，那么就接收缓冲区内的数据</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.qcount &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		qp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>chanbuf</span>(c, c.recvx)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>racenotify</span>(c, c.recvx, <span style=color:#ff79c6>nil</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> ep <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemmove</span>(c.elemtype, ep, qp)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, qp)
</span></span><span style=display:flex><span>		c.recvx<span style=color:#ff79c6>++</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> c.recvx <span style=color:#ff79c6>==</span> c.dataqsiz {
</span></span><span style=display:flex><span>			c.recvx = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		c.qcount<span style=color:#ff79c6>--</span>
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, <span style=color:#ff79c6>true</span>
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>这里没有什么好特别的。</p><h3 id=阻塞接收>阻塞接收<a hidden class=anchor aria-hidden=true href=#阻塞接收>#</a></h3><p>当缓冲区内也没有数据时，如果选择了阻塞接收，此时只能进行等待</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#6272a4>// no sender available: block on this channel.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 获取当前g</span>
</span></span><span style=display:flex><span>	gp <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 新建或从缓存获取sudog</span>
</span></span><span style=display:flex><span>	mysg <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>acquireSudog</span>()
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置sudog的值</span>
</span></span><span style=display:flex><span>	mysg.releasetime = <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> t0 <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		mysg.releasetime = <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// No stack splits between assigning elem and enqueuing mysg</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// on gp.waiting where copystack can find it.</span>
</span></span><span style=display:flex><span>	mysg.elem = ep
</span></span><span style=display:flex><span>	mysg.waitlink = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp.waiting = mysg
</span></span><span style=display:flex><span>	mysg.g = gp
</span></span><span style=display:flex><span>	mysg.isSelect = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	mysg.c = c
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 将sudog加入channel的接收者队列</span>
</span></span><span style=display:flex><span>	c.recvq.<span style=color:#50fa7b>enqueue</span>(mysg)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// Signal to anyone trying to shrink our stack that we&#39;re about</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// to park on a channel. The window between when this G&#39;s status</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// changes and when we set gp.activeStackChans is not safe for</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// stack shrinking.</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 设置原子信号。当栈要 shrink 收缩时，这个标记代表当前 goroutine 还 parking 停在某个 channel 中。</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 在 g 状态变更与设置 activeStackChans 状态这两个时间点之间的时间窗口进行栈 shrink 收缩是不安全的，所以需要设置这个原子信号。</span>
</span></span><span style=display:flex><span>	atomic.<span style=color:#50fa7b>Store8</span>(<span style=color:#ff79c6>&amp;</span>gp.parkingOnChan, <span style=color:#bd93f9>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 调用 gopark 方法挂起当前 goroutine，状态为 waitReasonChanReceive，阻塞等待 channel</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>gopark</span>(chanparkcommit, unsafe.<span style=color:#50fa7b>Pointer</span>(<span style=color:#ff79c6>&amp;</span>c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span style=color:#bd93f9>2</span>)
</span></span></code></pre></div><p>这里和chansend中的阻塞部分几乎一样，但是作为接收方，不用<code>KeepAlive(ep)</code>来确保数据不被回收</p><p>被唤醒后:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#6272a4>// someone woke us up</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg <span style=color:#ff79c6>!=</span> gp.waiting {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>throw</span>(<span style=color:#f1fa8c>&#34;G waiting list is corrupted&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	gp.waiting = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	gp.activeStackChans = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> mysg.releasetime &gt; <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>blockevent</span>(mysg.releasetime<span style=color:#ff79c6>-</span>t0, <span style=color:#bd93f9>2</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	success <span style=color:#ff79c6>:=</span> mysg.success
</span></span><span style=display:flex><span>	gp.param = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	mysg.c = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>releaseSudog</span>(mysg)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>return</span> <span style=color:#ff79c6>true</span>, success
</span></span></code></pre></div><p>goroutine 被唤醒后会完成 channel 的阻塞数据接收。接收完最后进行基本的参数检查，解除 channel 的绑定并释放 sudog。</p><h3 id=小结-1>小结<a hidden class=anchor aria-hidden=true href=#小结-1>#</a></h3><p>channel读取操作各状态:</p><table><thead><tr><th></th><th>Channel status</th><th>Result</th></tr></thead><tbody><tr><td>Read</td><td>nil</td><td>block</td></tr><tr><td>Read</td><td>open and not empty</td><td>read success</td></tr><tr><td>Read</td><td>open and empty</td><td>block</td></tr><tr><td>Read</td><td>closed</td><td>default value,false</td></tr><tr><td>Read</td><td>read only</td><td>Compole Error</td></tr></tbody></table><p>chanrecv 的返回值有几种情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>tmp, ok <span style=color:#ff79c6>:=</span> <span style=color:#ff79c6>&lt;-</span>ch
</span></span></code></pre></div><table><thead><tr><th>Channel status</th><th>Selected</th><th>Received</th></tr></thead><tbody><tr><td>nil</td><td>false</td><td>false</td></tr><tr><td>open and not empty</td><td>true</td><td>true</td></tr><tr><td>open and empty</td><td>false</td><td>false</td></tr><tr><td>closed</td><td>true</td><td>false</td></tr><tr><td>received值对应ok，selected 值不会被外部使用。</td><td></td><td></td></tr></tbody></table><p>channel 接收过程中包含 2 次有关 goroutine 调度过程：</p><ol><li>当 channel 为 nil 时，执行 gopark() 挂起当前的 goroutine。</li><li>当发送队列中存在 sudog 可以直接接收数据时，执行 goready()将 g 插入 runnext 插槽中，状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable，等待下次调度便立即运行。</li><li>当 channel 缓冲区为空，且没有发送者时，执行 gopark() 将 g 阻塞，让出 cpu 的使用权并等待调度器的调度。</li></ol><h2 id=关闭channel>关闭channel<a hidden class=anchor aria-hidden=true href=#关闭channel>#</a></h2><p>关闭channel的手段:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>close</span>(ch)
</span></span></code></pre></div><p>编译器会将其转换为/src/runtime/chan.go:356处的runtime.closechan() 方法。</p><h3 id=异常检查-2>异常检查<a hidden class=anchor aria-hidden=true href=#异常检查-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>func</span> <span style=color:#50fa7b>closechan</span>(c <span style=color:#ff79c6>*</span>hchan) {
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;close of nil channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>lock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> c.closed <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span><span style=display:flex><span>		<span style=color:#8be9fd;font-style:italic>panic</span>(<span style=color:#50fa7b>plainError</span>(<span style=color:#f1fa8c>&#34;close of closed channel&#34;</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>		callerpc <span style=color:#ff79c6>:=</span> <span style=color:#50fa7b>getcallerpc</span>()
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racewritepc</span>(c.<span style=color:#50fa7b>raceaddr</span>(), callerpc, abi.<span style=color:#50fa7b>FuncPCABIInternal</span>(closechan))
</span></span><span style=display:flex><span>		<span style=color:#50fa7b>racerelease</span>(c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	c.closed = <span style=color:#bd93f9>1</span>
</span></span></code></pre></div><p>如果channel为nil或者已关闭的话，panic。
否则，标记channel的closed字段为1。</p><h3 id=释放所有接收者和发送者>释放所有接收者和发送者<a hidden class=anchor aria-hidden=true href=#释放所有接收者和发送者>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>	<span style=color:#8be9fd;font-style:italic>var</span> glist gList
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// release all readers</span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// 释放接收者，将等待队列recvq中的sudog清除，并把对应的g都加入到待清除队列 glist 中</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		sg <span style=color:#ff79c6>:=</span> c.recvq.<span style=color:#50fa7b>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.elem <span style=color:#ff79c6>!=</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>typedmemclr</span>(c.elemtype, sg.elem)
</span></span><span style=display:flex><span>			sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>		gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>		sg.success = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>raceacquireg</span>(gp, c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		glist.<span style=color:#50fa7b>push</span>(gp)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#6272a4>// release all writers (they will panic)</span>
</span></span><span style=display:flex><span>	<span style=color:#ff79c6>for</span> {
</span></span><span style=display:flex><span>		sg <span style=color:#ff79c6>:=</span> c.sendq.<span style=color:#50fa7b>dequeue</span>()
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg <span style=color:#ff79c6>==</span> <span style=color:#ff79c6>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#ff79c6>break</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		sg.elem = <span style=color:#ff79c6>nil</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> sg.releasetime <span style=color:#ff79c6>!=</span> <span style=color:#bd93f9>0</span> {
</span></span><span style=display:flex><span>			sg.releasetime = <span style=color:#50fa7b>cputicks</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		gp <span style=color:#ff79c6>:=</span> sg.g
</span></span><span style=display:flex><span>		gp.param = unsafe.<span style=color:#50fa7b>Pointer</span>(sg)
</span></span><span style=display:flex><span>		sg.success = <span style=color:#ff79c6>false</span>
</span></span><span style=display:flex><span>		<span style=color:#ff79c6>if</span> raceenabled {
</span></span><span style=display:flex><span>			<span style=color:#50fa7b>raceacquireg</span>(gp, c.<span style=color:#50fa7b>raceaddr</span>())
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		glist.<span style=color:#50fa7b>push</span>(gp)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#50fa7b>unlock</span>(<span style=color:#ff79c6>&amp;</span>c.lock)
</span></span></code></pre></div><h3 id=执行协程调度>执行协程调度<a hidden class=anchor aria-hidden=true href=#执行协程调度>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#6272a4>// Ready all Gs now that we&#39;ve dropped the channel lock.  </span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>for</span> !glist.<span style=color:#50fa7b>empty</span>() {  
</span></span><span style=display:flex><span>   gp <span style=color:#ff79c6>:=</span> glist.<span style=color:#50fa7b>pop</span>()  
</span></span><span style=display:flex><span>   gp.schedlink = <span style=color:#bd93f9>0</span>  
</span></span><span style=display:flex><span>   <span style=color:#50fa7b>goready</span>(gp, <span style=color:#bd93f9>3</span>)  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>最后会为所有被阻塞的 goroutine 调用 goready 触发调度。将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度。</p><h3 id=优雅关闭>优雅关闭<a hidden class=anchor aria-hidden=true href=#优雅关闭>#</a></h3><p>“Channel 有几种优雅的关闭方法？” 这种问题常常出现在面试题中，究其原因是因为 Channel 创建容易，但是关闭“不易”：</p><ul><li>在不改变 Channel 自身状态的条件下，无法知道它是否已经关闭。“不易”之一，关闭时机未知。</li><li>如果一个 Channel 已经关闭，重复关闭 Channel 会导致 panic。“不易”之二，不能无脑关闭。</li><li>往一个 close 的 Channel 内写数据，也会导致 panic。“不易”之三，写数据之前也需要关注是否 close 的状态。</li></ul><table><thead><tr><th></th><th>Channel status</th><th>Result</th></tr></thead><tbody><tr><td>close</td><td>nil</td><td>panic</td></tr><tr><td>close</td><td>open and not empty</td><td>关闭 Channel；读取成功，直到 Channel 耗尽数据，然后读取产生值的默认值</td></tr><tr><td>close</td><td>open and empty</td><td>关闭 Channel；读到生产者的默认值</td></tr><tr><td>close</td><td>closed</td><td>panic</td></tr><tr><td>close</td><td>read only</td><td>Compile Error</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>那究竟什么时候关闭 Channel 呢？由上面三个“不易”，可以浓缩为 2 点：</p><ul><li>不能简单的从消费者侧关闭 Channel。</li><li>如果有多个生产者，它们不能关闭 Channel。</li></ul><p>解释一下这 2 个问题。第一个问题，消费者不知道 Channel 何时该关闭。如果关闭了已经关闭的 Channel 会导致 panic。而且分布式应用通常有多个消费者，每个消费者的行为一致，这么多消费者都尝试关闭 Channel 必然会导致 panic。第二个问题，如果有多个生产者往 Channel 内写入数据，这些生产者的行为逻辑也都一致，如果其中一个生产者关闭了 Channel，其他的生产者还在往里写，这个时候会 panic。所以为了防止 panic，必须解决上面这 2 个问题。</p><h3 id=context-方式>context 方式<a hidden class=anchor aria-hidden=true href=#context-方式>#</a></h3><h3 id=done-channel-方式>done channel 方式<a hidden class=anchor aria-hidden=true href=#done-channel-方式>#</a></h3></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/channel/>Channel</a></li><li><a href=https://www.yici.xin/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/go-sync-pool/><span class=title>« 上一页</span><br><span>Go Sync Pool</span>
</a><a class=next href=https://www.yici.xin/post/tech/short_code/><span class=title>下一页 »</span><br><span>Short_code</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>绝知</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
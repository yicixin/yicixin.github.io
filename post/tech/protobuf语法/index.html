<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Protobuf语法 | 绝知</title>
<meta name=keywords content="protobuf"><meta name=description content='什么是protobuf？
一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。
V3语法介绍
举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_num = 2;
  int32 page_size = 3;
}

.proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。

SearchRequest定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。
在单个.proto文件中能定义多个message类型:
syntax = "proto3";

message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

message SearchResponse {
    repeated string data = 1;
    int32 total = 2;
}
repeated表示该字段是一个可重复值，可以理解为数组。
注释的写法:
syntax = "proto3";

/* 请求结构 */
message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

/* 响应结构 */
message SearchResponse {
    repeated string data = 1;
    int32 total = 2; // 总数
}
如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用reserved关键字，可以保留编号或者字段名。
message Foo {
    reserved 2, 15, 9 to 11;
    reserved "foo", "bar";
    int32 foo = 2; // 会报错
}
枚举:'><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/tech/protobuf%E8%AF%AD%E6%B3%95/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.09ec7b2639f9095779b73636ae4b3857a1b98d87bcdb44b187c9a7c6a5c1cfb9.css integrity="sha256-Cex7Jjn5CVd5tzY2rks4V6G5jYe820Sxh8mnxqXBz7k=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/js/extended.js></script><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://www.yici.xin/post/tech/protobuf%E8%AF%AD%E6%B3%95/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><meta property="og:title" content="Protobuf语法"><meta property="og:description" content='什么是protobuf？
一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。
V3语法介绍
举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_num = 2;
  int32 page_size = 3;
}

.proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。

SearchRequest定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。
在单个.proto文件中能定义多个message类型:
syntax = "proto3";

message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

message SearchResponse {
    repeated string data = 1;
    int32 total = 2;
}
repeated表示该字段是一个可重复值，可以理解为数组。
注释的写法:
syntax = "proto3";

/* 请求结构 */
message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

/* 响应结构 */
message SearchResponse {
    repeated string data = 1;
    int32 total = 2; // 总数
}
如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用reserved关键字，可以保留编号或者字段名。
message Foo {
    reserved 2, 15, 9 to 11;
    reserved "foo", "bar";
    int32 foo = 2; // 会报错
}
枚举:'><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/tech/protobuf%E8%AF%AD%E6%B3%95/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-27T18:02:40+08:00"><meta property="article:modified_time" content="2022-12-27T18:02:40+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Protobuf语法"><meta name=twitter:description content='什么是protobuf？
一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。
V3语法介绍
举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:
syntax = "proto3";

message SearchRequest {
  string query = 1;
  int32 page_num = 2;
  int32 page_size = 3;
}

.proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。

SearchRequest定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。
在单个.proto文件中能定义多个message类型:
syntax = "proto3";

message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

message SearchResponse {
    repeated string data = 1;
    int32 total = 2;
}
repeated表示该字段是一个可重复值，可以理解为数组。
注释的写法:
syntax = "proto3";

/* 请求结构 */
message SearchRequest {
    string query = 1;
    int32 page_num = 2;
    int32 page_size = 3;
}

/* 响应结构 */
message SearchResponse {
    repeated string data = 1;
    int32 total = 2; // 总数
}
如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用reserved关键字，可以保留编号或者字段名。
message Foo {
    reserved 2, 15, 9 to 11;
    reserved "foo", "bar";
    int32 foo = 2; // 会报错
}
枚举:'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"👨🏻‍💻技术","item":"https://www.yici.xin/post/tech/"},{"@type":"ListItem","position":3,"name":"Protobuf语法","item":"https://www.yici.xin/post/tech/protobuf%E8%AF%AD%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Protobuf语法","name":"Protobuf语法","description":"什么是protobuf？ 一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。\nV3语法介绍 举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:\nsyntax = \u0026#34;proto3\u0026#34;; message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } .proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。\nSearchRequest定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。\n在单个.proto文件中能定义多个message类型:\nsyntax = \u0026#34;proto3\u0026#34;; message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } message SearchResponse { repeated string data = 1; int32 total = 2; } repeated表示该字段是一个可重复值，可以理解为数组。\n注释的写法:\nsyntax = \u0026#34;proto3\u0026#34;; /* 请求结构 */ message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } /* 响应结构 */ message SearchResponse { repeated string data = 1; int32 total = 2; // 总数 } 如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用reserved关键字，可以保留编号或者字段名。\nmessage Foo { reserved 2, 15, 9 to 11; reserved \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;; int32 foo = 2; // 会报错 } 枚举:\n","keywords":["protobuf"],"articleBody":"什么是protobuf？ 一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。\nV3语法介绍 举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:\nsyntax = \"proto3\"; message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } .proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。\nSearchRequest定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。\n在单个.proto文件中能定义多个message类型:\nsyntax = \"proto3\"; message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } message SearchResponse { repeated string data = 1; int32 total = 2; } repeated表示该字段是一个可重复值，可以理解为数组。\n注释的写法:\nsyntax = \"proto3\"; /* 请求结构 */ message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; } /* 响应结构 */ message SearchResponse { repeated string data = 1; int32 total = 2; // 总数 } 如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用reserved关键字，可以保留编号或者字段名。\nmessage Foo { reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\"; int32 foo = 2; // 会报错 } 枚举:\n/* 请求结构 */ message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4; } 有一点需要注意，枚举的第一个字段值必须为0，因为这样我们就能用0作为数字编号的默认值，并且为了兼容proto2，枚举的第一个字段即为默认值。\n枚举的别名，如果某时候希望多个枚举字段代表同一个值，可以使用别名机制，需要设置option allow_alias为true:\nsyntax = \"proto3\"; /* 请求结构 */ message SearchRequest { string query = 1; int32 page_num = 2; int32 page_size = 3; enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } Corpus corpus = 4; } enum Corpus { UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; } message MyMessage1 { enum EnumAllowingAlias { option allow_alias = true; // 允许别名 UNKNOWN = 0; STARTED = 1; RUNNING = 1; } EnumAllowingAlias enum = 1; SearchRequest.Corpus corpus = 2; Corpus corpus2 = 3; } 如上，枚举的声明可以不在message的声明中，在一个message中也可以引用其他message中声明的枚举。\n枚举值的范围是一个32位的int，因为枚举在传输过程中使用的是变长编码，所以负数是很低效的，不推荐。\n导入其他.proto文件，先在goland中配置proto寻找路径，添加本地项目地址。 之后在.proto文件中使用import关键字进行导入:\nimport \"pb/route_guide.proto\"; 此时根路径为项目根目录\nproto中的map:\nmessage M { map\u003cstring, SearchRequest\u003e req_map = 1; } or message MapFieldEntry { key_type key = 1; value_type value = 2; } repeated MapFieldEntry map_field = N; 注意:\nMap fields cannot be repeated. Map中的数据顺序不是固定的 生成代码-以go为例 要生成go代码，我们要在proto文件里添加option go_package的定义， The option defines the import path of the package which will contain all the generated code for this file, the Go package name will be the last path component of the import path.\nsyntax = \"proto3\"; package tutorial; // 该package声明是proto文件的命名空间，在message重名时能够通过命名空间进行区分 option go_package = \"github.com/yicixin/mysite/pb\"; 为了生成代码，还需要安装一些proto插件（proto二进制文件已提前安装好）:\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@latest 接下来使用proto命令进行生成， 因为生成的是go代码，所以使用的是–go_out，其他语言也有类似的选项，$SRC_DIR (where your application’s source code lives – the current directory is used if you don’t provide a value), the $DST_DIR (where you want the generated code to go; often the same as $SRC_DIR), and the path to your .proto.\nprotoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto 高级选项:\n详见:https://developers.google.com/protocol-buffers/docs/reference/go-generated\nThe protocol buffer compiler produces Go output when invoked with the go_out flag. The argument to the go_out flag is the directory where you want the compiler to write your Go output.\nprotobuf的编译器将生成go代码，当调用时带上了go_out标志，go_out标志的参数是你想存放go文件的位置。\nprotoc --proto_path=. \\ --go_out=. --go_opt=paths=source_relative pb/address.proto Where in the output directory the generated .pb.go file is placed depends on the compiler flags. There are several output modes:\nIf the paths=import flag is specified, the output file is placed in a directory named after the Go package’s import path. For example, an input file protos/buzz.proto with a Go import path of example.com/project/protos/fizz results in an output file at example.com/project/protos/fizz/buzz.pb.go. This is the default output mode if a paths flag is not specified. If the module=$PREFIX flag is specified, the output file is placed in a directory named after the Go package’s import path, but with the specified directory prefix removed from the output filename. For example, an input file protos/buzz.proto with a Go import path of example.com/project/protos/fizz and example.com/project specified as the module prefix results in an output file at protos/fizz/buzz.pb.go. Generating any Go packages outside the module path results in an error. This mode is useful for outputting generated files directly into a Go module. If the paths=source_relative flag is specified, the output file is placed in the same relative directory as the input file. For example, an input file protos/buzz.proto results in an output file at protos/buzz.pb.go. 引用 Language Guide (proto3) | Protocol Buffers | Google Developers\n","wordCount":"665","inLanguage":"zh","datePublished":"2022-12-27T18:02:40+08:00","dateModified":"2022-12-27T18:02:40+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/tech/protobuf%E8%AF%AD%E6%B3%95/"},"publisher":{"@type":"Organization","name":"绝知","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="绝知 (Alt + H)">绝知</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li></li></ul></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/tech/>👨🏻‍💻技术</a></div><h1 class=post-title>Protobuf语法</h1><div class=post-meta><span title='2022-12-27 18:02:40 +0800 +0800'>2022-12-27</span>&nbsp;·&nbsp;壹次心</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%afprotobuf aria-label=什么是protobuf？>什么是protobuf？</a></li><li><a href=#v3%e8%af%ad%e6%b3%95%e4%bb%8b%e7%bb%8d aria-label=V3语法介绍>V3语法介绍</a></li><li><a href=#%e7%94%9f%e6%88%90%e4%bb%a3%e7%a0%81-%e4%bb%a5go%e4%b8%ba%e4%be%8b aria-label=生成代码-以go为例>生成代码-以go为例</a></li><li><a href=#%e5%bc%95%e7%94%a8 aria-label=引用>引用</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=什么是protobuf>什么是protobuf？<a hidden class=anchor aria-hidden=true href=#什么是protobuf>#</a></h2><p>一种序列化结构数据的方式，与语言无关，与平台无关，可扩展。和json一样，但是更小更快。</p><h2 id=v3语法介绍>V3语法介绍<a hidden class=anchor aria-hidden=true href=#v3语法介绍>#</a></h2><p>举一个简单的例子，一个分页查询的请求参数，新建一个.proto文件并写入:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchRequest</span> {
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>string</span> query <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int32</span> page_num <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>  <span style=color:#8be9fd>int32</span> page_size <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>.proto文件的第一行指定了当前正在使用proto3语法，如果未写，proto的编译器会默认使用proto2的语法进行解析。</p></blockquote><p><code>SearchRequest</code>定义了三个字段，它们都有类型和名称，并且在最后给了一个唯一编号，编号的作用是在序列化后的二进制序列中标识字段。当编号为1-15的范围内时，在编码时只需要一个字节，而16-2047就需要两个字节，具体原因可以了解一下protobuf的编码原理。所以，1-15的编号最好要保留给那些最经常出现的字段。你能使用的最小编号是1，最大是$2^{29}$-1，不过你不能使用19000-19999，这些编号为protobuf的实现而预保留了，如果你使用了，是过不了编译的。</p><p>在单个.proto文件中能定义多个message类型:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchRequest</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>string</span> query <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_num <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_size <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchResponse</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>repeated</span> <span style=color:#8be9fd>string</span> data <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> total <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>repeated</code>表示该字段是一个可重复值，可以理解为数组。</p><p>注释的写法:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* 请求结构 */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchRequest</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>string</span> query <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_num <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_size <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* 响应结构 */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchResponse</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>repeated</span> <span style=color:#8be9fd>string</span> data <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> total <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>; <span style=color:#6272a4>// 总数
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>如果我们在更新message type时，是直接删除或者注释了字段，在之后其他人来更新时可能会复用被删除或注释的字段编号，如果这时加载了相同proto的旧版本，那么就会导致一些错误。所以protobuf提供了保留字段的机制，使用<code>reserved</code>关键字，可以保留编号或者字段名。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>Foo</span> {
</span></span><span style=display:flex><span>    reserved <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>15</span>, <span style=color:#bd93f9>9</span> <span style=color:#ff79c6>to</span> <span style=color:#bd93f9>11</span>;
</span></span><span style=display:flex><span>    reserved <span style=color:#f1fa8c>&#34;foo&#34;</span>, <span style=color:#f1fa8c>&#34;bar&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> foo <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>; <span style=color:#6272a4>// 会报错
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><p>枚举:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#6272a4>/* 请求结构 */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchRequest</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>string</span> query <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_num <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_size <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>enum</span> Corpus {
</span></span><span style=display:flex><span>        UNIVERSAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        WEB <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>        IMAGES <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>        LOCAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>        NEWS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>;
</span></span><span style=display:flex><span>        PRODUCTS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>        VIDEO <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>6</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Corpus corpus <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有一点需要注意，枚举的第一个字段值必须为0，因为这样我们就能用0作为数字编号的默认值，并且为了兼容proto2，枚举的第一个字段即为默认值。</p><p>枚举的别名，如果某时候希望多个枚举字段代表同一个值，可以使用别名机制，需要设置<code>option allow_alias</code>为<code>true</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>/* 请求结构 */</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>SearchRequest</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>string</span> query <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_num <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int32</span> page_size <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>enum</span> Corpus {
</span></span><span style=display:flex><span>        UNIVERSAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>        WEB <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>        IMAGES <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>        LOCAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>        NEWS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>;
</span></span><span style=display:flex><span>        PRODUCTS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>        VIDEO <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>6</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Corpus corpus <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>enum</span> Corpus {
</span></span><span style=display:flex><span>    UNIVERSAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    WEB <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    IMAGES <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    LOCAL <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>    NEWS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>4</span>;
</span></span><span style=display:flex><span>    PRODUCTS <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>5</span>;
</span></span><span style=display:flex><span>    VIDEO <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>6</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>MyMessage1</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>enum</span> EnumAllowingAlias {
</span></span><span style=display:flex><span>      <span style=color:#ff79c6>option</span> allow_alias <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>true</span>; <span style=color:#6272a4>// 允许别名
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>      UNKNOWN <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>      STARTED <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>      RUNNING <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    EnumAllowingAlias <span style=color:#8be9fd;font-style:italic>enum</span> <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    SearchRequest.Corpus corpus <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>    Corpus corpus2 <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>3</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上，枚举的声明可以不在message的声明中，在一个message中也可以引用其他message中声明的枚举。</p><p>枚举值的范围是一个32位的int，因为枚举在传输过程中使用的是变长编码，所以负数是很低效的，不推荐。</p><p>导入其他.proto文件，先在goland中配置proto寻找路径，添加本地项目地址。
<img loading=lazy src=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202212271805382.png alt></p><p>之后在.proto文件中使用import关键字进行导入:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#ff79c6>import</span> <span style=color:#f1fa8c>&#34;pb/route_guide.proto&#34;</span>;
</span></span></code></pre></div><p>此时根路径为项目根目录</p><p>proto中的map:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>M</span> {
</span></span><span style=display:flex><span>    map&lt;<span style=color:#8be9fd>string</span>, SearchRequest&gt; req_map <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>or
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>message</span> <span style=color:#50fa7b>MapFieldEntry</span> {
</span></span><span style=display:flex><span>  key_type key <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>  value_type value <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>repeated</span> MapFieldEntry map_field <span style=color:#ff79c6>=</span> N;
</span></span></code></pre></div><p>注意:</p><ol><li>Map fields cannot be <code>repeated</code>.</li><li>Map中的数据顺序不是固定的</li></ol><h2 id=生成代码-以go为例>生成代码-以go为例<a hidden class=anchor aria-hidden=true href=#生成代码-以go为例>#</a></h2><p>要生成go代码，我们要在proto文件里添加<code>option go_package</code>的定义， The option defines the import path of the package which will contain all the generated code for this file, the Go package name will be the last path component of the import path.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;proto3&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>package</span> tutorial; <span style=color:#6272a4>// 该package声明是proto文件的命名空间，在message重名时能够通过命名空间进行区分
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>option</span> go_package <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;github.com/yicixin/mysite/pb&#34;</span>;
</span></span></code></pre></div><p>为了生成代码，还需要安装一些proto插件（proto二进制文件已提前安装好）:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
</span></span></code></pre></div><p>接下来使用proto命令进行生成， 因为生成的是go代码，所以使用的是&ndash;go_out，其他语言也有类似的选项，<code>$SRC_DIR</code> (where your application&rsquo;s source code lives – the current directory is used if you don&rsquo;t provide a value), the <code>$DST_DIR</code> (where you want the generated code to go; often the same as <code>$SRC_DIR</code>), and the path to your <code>.proto</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>protoc -I<span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>$SRC_DIR</span> --go_out<span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>$DST_DIR</span> <span style=color:#8be9fd;font-style:italic>$SRC_DIR</span>/addressbook.proto
</span></span></code></pre></div><p>高级选项:</p><blockquote><p>详见:<a href=https://developers.google.com/protocol-buffers/docs/reference/go-generated>https://developers.google.com/protocol-buffers/docs/reference/go-generated</a></p></blockquote><p>The protocol buffer compiler produces Go output when invoked with the <code>go_out</code> flag. The argument to the <code>go_out</code> flag is the directory where you want the compiler to write your Go output.</p><p>protobuf的编译器将生成go代码，当调用时带上了<code>go_out</code>标志，go_out标志的参数是你想存放go文件的位置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>protoc --proto_path<span style=color:#ff79c6>=</span>. <span style=color:#f1fa8c>\
</span></span></span><span style=display:flex><span><span style=color:#f1fa8c></span>--go_out<span style=color:#ff79c6>=</span>. --go_opt<span style=color:#ff79c6>=</span><span style=color:#8be9fd;font-style:italic>paths</span><span style=color:#ff79c6>=</span>source_relative pb/address.proto
</span></span></code></pre></div><p>Where in the output directory the generated <code>.pb.go</code> file is placed depends on the compiler flags. There are several output modes:</p><ul><li>If the <code>paths=import</code> flag is specified, the output file is placed in a directory named after the Go package&rsquo;s import path. For example, an input file <code>protos/buzz.proto</code> with a Go import path of <code>example.com/project/protos/fizz</code> results in an output file at <code>example.com/project/protos/fizz/buzz.pb.go</code>. This is the default output mode if a <code>paths</code> flag is not specified.</li><li>If the <code>module=$PREFIX</code> flag is specified, the output file is placed in a directory named after the Go package&rsquo;s import path, but with the specified directory prefix removed from the output filename. For example, an input file <code>protos/buzz.proto</code> with a Go import path of <code>example.com/project/protos/fizz</code> and <code>example.com/project</code> specified as the <code>module</code> prefix results in an output file at <code>protos/fizz/buzz.pb.go</code>. Generating any Go packages outside the module path results in an error. This mode is useful for outputting generated files directly into a Go module.</li><li>If the <code>paths=source_relative</code> flag is specified, the output file is placed in the same relative directory as the input file. For example, an input file <code>protos/buzz.proto</code> results in an output file at <code>protos/buzz.pb.go</code>.</li></ul><h2 id=引用>引用<a hidden class=anchor aria-hidden=true href=#引用>#</a></h2><p><a href=https://developers.google.com/protocol-buffers/docs/proto3>Language Guide (proto3) | Protocol Buffers | Google Developers</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/protobuf/>Protobuf</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/wire-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/><span class=title>« 上一页</span><br><span>Wire 依赖注入</span>
</a><a class=next href=https://www.yici.xin/post/tech/protobuf%E5%8E%9F%E7%90%86/><span class=title>下一页 »</span><br><span>Protobuf原理</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="light"?"light":"dark_dimmed",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";console.log(e);function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script></article></main><footer class=footer><span>&copy; 2025 <a href=https://www.yici.xin/>绝知</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script><script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/katex.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0-rc.1/contrib/auto-render.min.js></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></body></html>
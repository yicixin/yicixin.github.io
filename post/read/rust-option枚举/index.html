<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Rust Option枚举 | Do not panic!</title><meta name=keywords content="rust,翻译"><meta name=description content="原文链接🔗
The Option Enum and Its Advantages Over Null Values 比null更优的选择——Option枚举
This section explores a case study of Option, which is another enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.
这一节探讨Option的一个学习案例，Option是另一个由标准库定义的枚举。Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Rust Option枚举"><meta property="og:description" content="原文链接🔗
The Option Enum and Its Advantages Over Null Values 比null更优的选择——Option枚举
This section explores a case study of Option, which is another enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.
这一节探讨Option的一个学习案例，Option是另一个由标准库定义的枚举。Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-29T15:41:07+08:00"><meta property="article:modified_time" content="2022-12-29T15:41:07+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust Option枚举"><meta name=twitter:description content="原文链接🔗
The Option Enum and Its Advantages Over Null Values 比null更优的选择——Option枚举
This section explores a case study of Option, which is another enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.
这一节探讨Option的一个学习案例，Option是另一个由标准库定义的枚举。Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"📖阅读","item":"https://www.yici.xin/post/read/"},{"@type":"ListItem","position":3,"name":"Rust Option枚举","item":"https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Option枚举","name":"Rust Option枚举","description":"原文链接🔗\nThe Option Enum and Its Advantages Over Null Values 比null更优的选择——Option枚举\nThis section explores a case study of Option, which is another enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.\n这一节探讨Option的一个学习案例，Option是另一个由标准库定义的枚举。\u0008Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。\nFor example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing.","keywords":["rust","翻译"],"articleBody":" 原文链接🔗\nThe Option Enum and Its Advantages Over Null Values 比null更优的选择——Option枚举\nThis section explores a case study of Option, which is another enum defined by the standard library. The Option type encodes the very common scenario in which a value could be something or it could be nothing.\n这一节探讨Option的一个学习案例，Option是另一个由标准库定义的枚举。\u0008Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。\nFor example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.\n例如，如果你尝试请求一个非空list的第一个元素，你将得到一个值。如果你尝试请求一个空list的第一个元素，你什么都得不到。用类型系统来表达这个概念意味着编译器可以检查你是否处理了所有你应该处理的情况；这个功能能够避免在其他编程语言中及其常见的bug。\nProgramming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. Null is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.\n设计编程语言经常需要考虑的是包含哪些特性，但是考虑排除哪些特性一样重要。Rust不存在很多语言有的null特性。Null代表一个什么都没有的值，在有null的语言里，变量总是两个状态之一：null或非null。\nThe problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.\nnull的问题在于，如果你尝试像使用非null值一样使用null值，你将得到一个某种错误，因为null和非null属性是无处不在的，犯这种错是及其简单的。\nHowever, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.\n然而，null尝试表达的概念仍然是有意义的：null是一个因为某种原因目前无效或缺失的值。\nThe problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is Option, and it is defined by the standard library as follows:\nenum Option\u003cT\u003e { None, Some(T), } 问题不在于概念，而在于具体实现。为此，Rust中不存在null，但是它提供了一个枚举，它编码了一个值存在与否的概念。这个枚举就是Option，而且它定义于标准库中，如下:\nThe Option enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: you can use Some and None directly without the Option:: prefix. The Option enum is still just a regular enum, and Some(T) and None are still variants of type Option.\nOption枚举是如此有用以至于它被包含在了prelude中；你不需要显式地引入。它的成员也包被含在了prelude中，你可以直接使用Some 和 None 而不需要添加前缀 Option:: 。即便如此 Option 也仍是常规的枚举，Some(T) 和 None 仍是 Option 的成员。\nThe syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to know is that means the Some variant of the Option enum can hold one piece of data of any type, and that each concrete type that gets used in place of T makes the overall Option type a different type. Here are some examples of using Option values to hold number types and string types:\nlet some_number = Some(5); let some_char = Some('e'); let absent_number: Option\u003ci32\u003e = None; 语法是Rust的一个特性，我们还没有提到过。它是一个泛型参数，我们将在第十章谈论泛型的细节。目前你只需要知道，意味着Option的成员Some可以保存任意类型的数据，每个被用来替代T的具体类型使得Option成为一个不同的类型(可以理解为赋予泛型一个具体的类型)。这是一些使用Option值来保存数字类型和字符串类型的例子：\nThe type of some_number is Option. The type of some_char is Option, which is a different type. Rust can infer these types because we’ve specified a value inside the Some variant. For absent_number, Rust requires us to annotate the overall Option type: the compiler can’t infer the type that the corresponding Some variant will hold by looking only at a None value. Here, we tell Rust that we mean for absent_number to be of type Option.\nsome_number的类型是Option，some_char的类型是Option。Rust能够推断出这些类型是因为我们指定了Some所保存的值。对于 absent_number，Rust要求我们提供Option的完整注解，因为只提供了一个None值编译器无法推断类型。这里的注解告诉Rustabsent_number的类型是Option。\nWhen we have a Some value, we know that a value is present and the value is held within the Some. When we have a None value, in some sense, it means the same thing as null: we don’t have a valid value. So why is having Option any better than having null?\n当有一个 Some 值时，我们就知道存在一个值，这个值保存在 Some 中。当有个 None 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，Option 为什么就比空值要好呢？(为什么Option = None 比 null 好？)\nIn short, because Option and T (where T can be any type) are different types, the compiler won’t let us use an Option value as if it were definitely a valid value. For example, this code won’t compile because it’s trying to add an i8 to an Option:\nlet x: i8 = 5; let y: Option\u003ci8\u003e = Some(5); let sum = x + y; 简而言之，因为 Option 和T是不同的类型，编译器不允许你像使用一个确定有效的值一样使用Option 。例如，下面的代码无法通过编译，因为i8 和Option无法相加。\nIf we run this code, we get an error message like this:\n$ cargo run Compiling enums v0.1.0 (file:///projects/enums) error[E0277]: cannot add `Option\u003ci8\u003e` to `i8` --\u003e src/main.rs:5:17 | 5 | let sum = x + y; | ^ no implementation for `i8 + Option\u003ci8\u003e` | = help: the trait `Add\u003cOption\u003ci8\u003e\u003e` is not implemented for `i8` = help: the following other types implement trait `Add\u003cRhs\u003e`: \u003c\u0026'a f32 as Add\u003e \u003c\u0026'a f64 as Add\u003cf64\u003e\u003e \u003c\u0026'a i128 as Add\u003e \u003c\u0026'a i16 as Add\u003ci16\u003e\u003e \u003c\u0026'a i32 as Add\u003e \u003c\u0026'a i64 as Add\u003ci64\u003e\u003e \u003c\u0026'a i8 as Add\u003e \u003c\u0026'a isize as Add\u003cisize\u003e\u003e and 48 others For more information about this error, try `rustc --explain E0277`. error: could not compile `enums` due to previous error 如果我们运行该代码，会得到这样的错误：\nIntense! In effect, this error message means that Rust doesn’t understand how to add an i8 and an Option, because they’re different types. When we have a value of a type like i8 in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an Option (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.\n很好！事实上，错误信息意味着 Rust 不知道该如何将 Option 与 i8 相加，因为它们的类型不同。当在 Rust 中拥有一个像 i8 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 Option（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。\nIn other words, you have to convert an Option to a T before you can perform T operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.\n换句话说，在对 Option 进行 T 的运算之前必须将其转换为 T。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。\nEliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value Option. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an Option, you can safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.\n不再担心会错误地假设一个非空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式地将其放入对应类型的 Option 中。接着，当使用这个值时，必须明确地处理值为空的情况。只要一个值不是 Option 类型，你就 可以 安全地认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。\nSo, how do you get the T value out of a Some variant when you have a value of type Option so you can use that value? The Option enum has a large number of methods that are useful in a variety of situations; you can check them out in its documentation. Becoming familiar with the methods on Option will be extremely useful in your journey with Rust.\n那么当有一个 Option 的值时，如何从 Some 成员中取出 T 的值来使用它呢？Option 枚举拥有大量用于各种情况的方法：你可以查看它的文档。熟悉 Option 的方法将对你的 Rust 之旅非常有用。\nIn general, in order to use an Option value, you want to have code that will handle each variant. You want some code that will run only when you have a Some(T) value, and this code is allowed to use the inner T. You want some other code to run if you have a None value, and that code doesn’t have a T value available. The match expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.\n总的来说，为了使用 Option 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 Some(T) 值时运行，允许这些代码使用其中的 T。也希望一些代码在值为 None 时运行，这些代码并没有一个可用的 T 值。match 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。\n","wordCount":"1285","inLanguage":"zh","datePublished":"2022-12-29T15:41:07+08:00","dateModified":"2022-12-29T15:41:07+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"},"publisher":{"@type":"Organization","name":"Do not panic!","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="Yicixin's blog (Alt + H)">Yicixin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li><li><a href=https://www.yici.xin/archives/ title=归档🕰️><span>归档🕰️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/read/>📖阅读</a></div><h1 class=post-title>Rust Option枚举</h1><div class=post-meta><span title='2022-12-29 15:41:07 +0800 +0800'>2022-12-29</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;1285 字&nbsp;·&nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/read/rust-Option%e6%9e%9a%e4%b8%be.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><blockquote><p><a href=https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values>原文链接🔗</a></p></blockquote><h2 id=the-option-enum-and-its-advantages-over-null-values>The Option Enum and Its Advantages Over Null Values<a hidden class=anchor aria-hidden=true href=#the-option-enum-and-its-advantages-over-null-values>#</a></h2><p>比null更优的选择——Option枚举</p><p>This section explores a case study of <code>Option</code>, which is another enum defined by the standard library. The <code>Option</code> type encodes the very common scenario in which a value could be something or it could be nothing.</p><p>这一节探讨<code>Option</code>的一个学习案例，<code>Option</code>是另一个由标准库定义的枚举。Opiton类型编码了一个非常常见场景，值可以是某值，也可以是空。</p><p>For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</p><p>例如，如果你尝试请求一个非空list的第一个元素，你将得到一个值。如果你尝试请求一个空list的第一个元素，你什么都得不到。用类型系统来表达这个概念意味着编译器可以检查你是否处理了所有你应该处理的情况；这个功能能够避免在其他编程语言中及其常见的bug。</p><p>Programming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. <em>Null</em> is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.</p><p>设计编程语言经常需要考虑的是包含哪些特性，但是考虑排除哪些特性一样重要。Rust不存在很多语言有的null特性。Null代表一个什么都没有的值，在有null的语言里，变量总是两个状态之一：null或非null。</p><p>The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.</p><p>null的问题在于，如果你尝试像使用非null值一样使用null值，你将得到一个某种错误，因为null和非null属性是无处不在的，犯这种错是及其简单的。</p><p>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</p><p>然而，null尝试表达的概念仍然是有意义的：null是一个因为某种原因目前无效或缺失的值。</p><p>The problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is <code>Option&lt;T></code>, and it is <a href=https://doc.rust-lang.org/stable/std/option/enum.Option.html>defined by the standard library</a> as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>    Some(T),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题不在于概念，而在于具体实现。为此，Rust中不存在null，但是它提供了一个枚举，它编码了一个值存在与否的概念。这个枚举就是<code>Option&lt;T></code>，而且它<a href=https://rustwiki.org/zh-CN/std/option/enum.Option.html>定义于标准库中</a>，如下:</p><p>The <code>Option&lt;T></code> enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The <code>Option&lt;T></code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are still variants of type <code>Option&lt;T></code>.</p><p><code>Option&lt;T></code>枚举是如此有用以至于它被包含在了<code>prelude</code>中；你不需要显式地引入。它的成员也包被含在了<code>prelude</code>中，你可以直接使用<code>Some</code> 和  <code>None</code> 而不需要添加前缀 <code>Option::</code> 。即便如此 <code>Option&lt;T></code> 也仍是常规的枚举，<code>Some(T)</code> 和 <code>None</code> 仍是 <code>Option&lt;T></code> 的成员。</p><p>The <code>&lt;T></code> syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to know is that <code>&lt;T></code> means the <code>Some</code> variant of the <code>Option</code> enum can hold one piece of data of any type, and that each concrete type that gets used in place of <code>T</code> makes the overall <code>Option&lt;T></code> type a different type. Here are some examples of using <code>Option</code> values to hold number types and string types:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_number <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_char <span style=color:#f92672>=</span> Some(<span style=color:#e6db74>&#39;e&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> absent_number: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> None;
</span></span></code></pre></div><p><code>&lt;T></code>语法是Rust的一个特性，我们还没有提到过。它是一个泛型参数，我们将在第十章谈论泛型的细节。目前你只需要知道，<code>&lt;T></code>意味着<code>Option</code>的成员<code>Some</code>可以保存任意类型的数据，每个被用来替代<code>T</code>的具体类型使得<code>Option&lt;T></code>成为一个不同的类型(可以理解为赋予泛型一个具体的类型)。这是一些使用<code>Option</code>值来保存数字类型和字符串类型的例子：</p><p>The type of <code>some_number</code> is <code>Option&lt;i32></code>. The type of <code>some_char</code> is <code>Option&lt;char></code>, which is a different type. Rust can infer these types because we’ve specified a value inside the <code>Some</code> variant. For <code>absent_number</code>, Rust requires us to annotate the overall <code>Option</code> type: the compiler can’t infer the type that the corresponding <code>Some</code> variant will hold by looking only at a <code>None</code> value. Here, we tell Rust that we mean for <code>absent_number</code> to be of type <code>Option&lt;i32></code>.</p><p><code>some_number</code>的类型是<code>Option&lt;i32></code>，<code>some_char</code>的类型是<code>Option&lt;char></code>。Rust能够推断出这些类型是因为我们指定了<code>Some</code>所保存的值。对于 <code>absent_number</code>，Rust要求我们提供<code>Option</code>的完整注解，因为只提供了一个None值编译器无法推断类型。这里的注解告诉Rust<code>absent_number</code>的类型是<code>Option&lt;i32></code>。</p><p>When we have a <code>Some</code> value, we know that a value is present and the value is held within the <code>Some</code>. When we have a <code>None</code> value, in some sense, it means the same thing as null: we don’t have a valid value. So why is having <code>Option&lt;T></code> any better than having null?</p><p>当有一个 <code>Some</code> 值时，我们就知道存在一个值，这个值保存在 <code>Some</code> 中。当有个 <code>None</code> 值时，在某种意义上，它跟空值具有相同的意义：并没有一个有效的值。那么，<code>Option&lt;T></code> 为什么就比空值要好呢？(为什么<code>Option&lt;T> = None</code> 比 null 好？)</p><p>In short, because <code>Option&lt;T></code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won’t let us use an <code>Option&lt;T></code> value as if it were definitely a valid value. For example, this code won’t compile because it’s trying to add an <code>i8</code> to an <code>Option&lt;i8></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y;
</span></span></code></pre></div><p>简而言之，因为 <code>Option&lt;T></code> 和<code>T</code>是不同的类型，编译器不允许你像使用一个确定有效的值一样使用<code>Option&lt;T></code> 。例如，下面的代码无法通过编译，因为<code>i8</code> 和<code>Option&lt;i8></code>无法相加。</p><p>If we run this code, we get an error message like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> cargo run
</span></span><span style=display:flex><span>   Compiling enums v0.<span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>0</span> (file:<span style=color:#f92672>///</span>projects<span style=color:#f92672>/</span>enums)
</span></span><span style=display:flex><span>error[E0277]: cannot <span style=color:#66d9ef>add</span> <span style=color:#f92672>`</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;`</span> <span style=color:#66d9ef>to</span> <span style=color:#f92672>`</span>i8<span style=color:#f92672>`</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>--&gt;</span> src<span style=color:#f92672>/</span>main.rs:<span style=color:#ae81ff>5</span>:<span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> <span style=color:#f92672>|</span>     let sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>                 <span style=color:#f92672>^</span> no implementation <span style=color:#66d9ef>for</span> <span style=color:#f92672>`</span>i8 <span style=color:#f92672>+</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;`</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: the trait <span style=color:#f92672>`</span><span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;&gt;`</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>not</span> implemented <span style=color:#66d9ef>for</span> <span style=color:#f92672>`</span>i8<span style=color:#f92672>`</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: the following other types implement trait <span style=color:#f92672>`</span><span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>Rhs<span style=color:#f92672>&gt;`</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a f32 as Add&lt;f32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a f64 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>f64<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i128 as Add&lt;i128&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a i16 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>i16<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i32 as Add&lt;i32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a i64 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>i64<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i8 as Add&lt;i8&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a isize <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>isize<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>and</span> <span style=color:#ae81ff>48</span> others
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, try <span style=color:#f92672>`</span>rustc <span style=color:#f92672>--</span><span style=color:#66d9ef>explain</span> E0277<span style=color:#f92672>`</span>.
</span></span><span style=display:flex><span>error: could <span style=color:#66d9ef>not</span> compile <span style=color:#f92672>`</span>enums<span style=color:#f92672>`</span> due <span style=color:#66d9ef>to</span> previous error
</span></span></code></pre></div><p>如果我们运行该代码，会得到这样的错误：</p><p>Intense! In effect, this error message means that Rust doesn’t understand how to add an <code>i8</code> and an <code>Option&lt;i8></code>, because they’re different types. When we have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an <code>Option&lt;i8></code> (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</p><p>很好！事实上，错误信息意味着 Rust 不知道该如何将 <code>Option&lt;i8></code> 与 <code>i8</code> 相加，因为它们的类型不同。当在 Rust 中拥有一个像 <code>i8</code> 这样类型的值时，编译器确保它总是有一个有效的值。我们可以自信使用而无需做空值检查。只有当使用 <code>Option&lt;i8></code>（或者任何用到的类型）的时候需要担心可能没有值，而编译器会确保我们在使用值之前处理了为空的情况。</p><p>In other words, you have to convert an <code>Option&lt;T></code> to a <code>T</code> before you can perform <code>T</code> operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.</p><p>换句话说，在对 <code>Option&lt;T></code> 进行 <code>T</code> 的运算之前必须将其转换为 <code>T</code>。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p><p>Eliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value <code>Option&lt;T></code>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an <code>Option&lt;T></code>, you <em>can</em> safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s <strong>pervasiveness</strong> and increase the safety of Rust code.</p><p>不再担心会错误地假设一个非空值，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式地将其放入对应类型的 <code>Option&lt;T></code> 中。接着，当使用这个值时，必须明确地处理值为空的情况。只要一个值不是 <code>Option&lt;T></code> 类型，你就 <strong>可以</strong> 安全地认定它的值不为空。这是 Rust 的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加 Rust 代码的安全性。</p><p>So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value of type <code>Option&lt;T></code> so you can use that value? The <code>Option&lt;T></code> enum has a large number of methods that are useful in a variety of situations; you can check them out in <a href=https://doc.rust-lang.org/stable/std/option/enum.Option.html>its documentation</a>. Becoming familiar with the methods on <code>Option&lt;T></code> will be extremely useful in your journey with Rust.</p><p>那么当有一个 <code>Option&lt;T></code> 的值时，如何从 <code>Some</code> 成员中取出 <code>T</code> 的值来使用它呢？<code>Option&lt;T></code> 枚举拥有大量用于各种情况的方法：你可以查看<a href=https://rustwiki.org/zh-CN/std/option/enum.Option.html>它的文档</a>。熟悉 <code>Option&lt;T></code> 的方法将对你的 Rust 之旅非常有用。</p><p>In general, in order to use an <code>Option&lt;T></code> value, you want to have code that will handle each variant. You want some code that will run only when you have a <code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some other code to run if you have a <code>None</code> value, and that code doesn’t have a <code>T</code> value available. The <code>match</code> expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p><p>总的来说，为了使用 <code>Option&lt;T></code> 值，需要编写处理每个成员的代码。你想要一些代码只当拥有 <code>Some(T)</code> 值时运行，允许这些代码使用其中的 <code>T</code>。也希望一些代码在值为 <code>None</code> 时运行，这些代码并没有一个可用的 <code>T</code> 值。<code>match</code> 表达式就是这么一个处理枚举的控制流结构：它会根据枚举的成员运行不同的代码，这些代码可以使用匹配到的值中的数据。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/rust/>rust</a></li><li><a href=https://www.yici.xin/tags/%E7%BF%BB%E8%AF%91/>翻译</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><span class=title>« 上一页</span><br><span>Golang-map的操作</span></a>
<a class=next href=https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/><span class=title>下一页 »</span><br><span>Rust程序设计——枚举</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.yici.xin/>Do not panic!</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
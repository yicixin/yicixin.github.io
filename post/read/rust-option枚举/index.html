<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Rust Optionæšä¸¾ | Do not panic!</title><meta name=keywords content="rust,ç¿»è¯‘"><meta name=description content="åŸæ–‡é“¾æ¥ğŸ”—
The Option Enum and Its Advantages Over Null Values æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾
This section explores a case study ofÂ Option, which is another enum defined by the standard library. TheÂ OptionÂ type encodes the very common scenario in which a value could be something or it could be nothing.
è¿™ä¸€èŠ‚æ¢è®¨Optionçš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼ŒOptionæ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><meta name=author content="å£¹æ¬¡å¿ƒ"><link rel=canonical href=https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Rust Optionæšä¸¾"><meta property="og:description" content="åŸæ–‡é“¾æ¥ğŸ”—
The Option Enum and Its Advantages Over Null Values æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾
This section explores a case study ofÂ Option, which is another enum defined by the standard library. TheÂ OptionÂ type encodes the very common scenario in which a value could be something or it could be nothing.
è¿™ä¸€èŠ‚æ¢è®¨Optionçš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼ŒOptionæ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-29T15:41:07+08:00"><meta property="article:modified_time" content="2022-12-29T15:41:07+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust Optionæšä¸¾"><meta name=twitter:description content="åŸæ–‡é“¾æ¥ğŸ”—
The Option Enum and Its Advantages Over Null Values æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾
This section explores a case study ofÂ Option, which is another enum defined by the standard library. TheÂ OptionÂ type encodes the very common scenario in which a value could be something or it could be nothing.
è¿™ä¸€èŠ‚æ¢è®¨Optionçš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼ŒOptionæ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚
For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"ğŸ“–é˜…è¯»","item":"https://www.yici.xin/post/read/"},{"@type":"ListItem","position":3,"name":"Rust Optionæšä¸¾","item":"https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust Optionæšä¸¾","name":"Rust Optionæšä¸¾","description":"åŸæ–‡é“¾æ¥ğŸ”—\nThe Option Enum and Its Advantages Over Null Values æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾\nThis section explores a case study ofÂ Option, which is another enum defined by the standard library. TheÂ OptionÂ type encodes the very common scenario in which a value could be something or it could be nothing.\nè¿™ä¸€èŠ‚æ¢è®¨Optionçš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼ŒOptionæ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚\u0008Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚\nFor example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing.","keywords":["rust","ç¿»è¯‘"],"articleBody":" åŸæ–‡é“¾æ¥ğŸ”—\nThe Option Enum and Its Advantages Over Null Values æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾\nThis section explores a case study ofÂ Option, which is another enum defined by the standard library. TheÂ OptionÂ type encodes the very common scenario in which a value could be something or it could be nothing.\nè¿™ä¸€èŠ‚æ¢è®¨Optionçš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼ŒOptionæ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚\u0008Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚\nFor example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether youâ€™ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.\nä¾‹å¦‚ï¼Œå¦‚æœä½ å°è¯•è¯·æ±‚ä¸€ä¸ªéç©ºlistçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ªå€¼ã€‚å¦‚æœä½ å°è¯•è¯·æ±‚ä¸€ä¸ªç©ºlistçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½ ä»€ä¹ˆéƒ½å¾—ä¸åˆ°ã€‚ç”¨ç±»å‹ç³»ç»Ÿæ¥è¡¨è¾¾è¿™ä¸ªæ¦‚å¿µæ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥æ£€æŸ¥ä½ æ˜¯å¦å¤„ç†äº†æ‰€æœ‰ä½ åº”è¯¥å¤„ç†çš„æƒ…å†µï¼›è¿™ä¸ªåŠŸèƒ½èƒ½å¤Ÿé¿å…åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­åŠå…¶å¸¸è§çš„bugã€‚\nProgramming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesnâ€™t have the null feature that many other languages have.Â NullÂ is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.\nè®¾è®¡ç¼–ç¨‹è¯­è¨€ç»å¸¸éœ€è¦è€ƒè™‘çš„æ˜¯åŒ…å«å“ªäº›ç‰¹æ€§ï¼Œä½†æ˜¯è€ƒè™‘æ’é™¤å“ªäº›ç‰¹æ€§ä¸€æ ·é‡è¦ã€‚Rustä¸å­˜åœ¨å¾ˆå¤šè¯­è¨€æœ‰çš„nullç‰¹æ€§ã€‚Nullä»£è¡¨ä¸€ä¸ªä»€ä¹ˆéƒ½æ²¡æœ‰çš„å€¼ï¼Œåœ¨æœ‰nullçš„è¯­è¨€é‡Œï¼Œå˜é‡æ€»æ˜¯ä¸¤ä¸ªçŠ¶æ€ä¹‹ä¸€ï¼šnullæˆ–énullã€‚\nThe problem with null values is that if you try to use a null value as a not-null value, youâ€™ll get an error of some kind. Because this null or not-null property is pervasive, itâ€™s extremely easy to make this kind of error.\nnullçš„é—®é¢˜åœ¨äºï¼Œå¦‚æœä½ å°è¯•åƒä½¿ç”¨énullå€¼ä¸€æ ·ä½¿ç”¨nullå€¼ï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ªæŸç§é”™è¯¯ï¼Œå› ä¸ºnullå’Œénullå±æ€§æ˜¯æ— å¤„ä¸åœ¨çš„ï¼ŒçŠ¯è¿™ç§é”™æ˜¯åŠå…¶ç®€å•çš„ã€‚\nHowever, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.\nç„¶è€Œï¼Œnullå°è¯•è¡¨è¾¾çš„æ¦‚å¿µä»ç„¶æ˜¯æœ‰æ„ä¹‰çš„ï¼šnullæ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚\nThe problem isnâ€™t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum isÂ Option, and it isÂ defined by the standard libraryÂ as follows:\nenum Option\u003cT\u003e { None, Some(T), } é—®é¢˜ä¸åœ¨äºæ¦‚å¿µï¼Œè€Œåœ¨äºå…·ä½“å®ç°ã€‚ä¸ºæ­¤ï¼ŒRustä¸­ä¸å­˜åœ¨nullï¼Œä½†æ˜¯å®ƒæä¾›äº†ä¸€ä¸ªæšä¸¾ï¼Œå®ƒç¼–ç äº†ä¸€ä¸ªå€¼å­˜åœ¨ä¸å¦çš„æ¦‚å¿µã€‚è¿™ä¸ªæšä¸¾å°±æ˜¯Optionï¼Œè€Œä¸”å®ƒå®šä¹‰äºæ ‡å‡†åº“ä¸­ï¼Œå¦‚ä¸‹:\nTheÂ OptionÂ enum is so useful that itâ€™s even included in the prelude; you donâ€™t need to bring it into scope explicitly. Its variants are also included in the prelude: you can useÂ SomeÂ andÂ NoneÂ directly without theÂ Option::Â prefix. TheÂ OptionÂ enum is still just a regular enum, andÂ Some(T)Â andÂ NoneÂ are still variants of typeÂ Option.\nOptionæšä¸¾æ˜¯å¦‚æ­¤æœ‰ç”¨ä»¥è‡³äºå®ƒè¢«åŒ…å«åœ¨äº†preludeä¸­ï¼›ä½ ä¸éœ€è¦æ˜¾å¼åœ°å¼•å…¥ã€‚å®ƒçš„æˆå‘˜ä¹ŸåŒ…è¢«å«åœ¨äº†preludeä¸­ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨SomeÂ å’Œ NoneÂ è€Œä¸éœ€è¦æ·»åŠ å‰ç¼€Â Option::Â ã€‚å³ä¾¿å¦‚æ­¤Â OptionÂ ä¹Ÿä»æ˜¯å¸¸è§„çš„æšä¸¾ï¼ŒSome(T)Â å’ŒÂ NoneÂ ä»æ˜¯Â OptionÂ çš„æˆå‘˜ã€‚\nTheÂ syntax is a feature of Rust we havenâ€™t talked about yet. Itâ€™s a generic type parameter, and weâ€™ll cover generics in more detail in Chapter 10. For now, all you need to know is thatÂ means theÂ SomeÂ variant of theÂ OptionÂ enum can hold one piece of data of any type, and that each concrete type that gets used in place ofÂ TÂ makes the overallÂ OptionÂ type a different type. Here are some examples of usingÂ OptionÂ values to hold number types and string types:\nlet some_number = Some(5); let some_char = Some('e'); let absent_number: Option\u003ci32\u003e = None; è¯­æ³•æ˜¯Rustçš„ä¸€ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰æåˆ°è¿‡ã€‚å®ƒæ˜¯ä¸€ä¸ªæ³›å‹å‚æ•°ï¼Œæˆ‘ä»¬å°†åœ¨ç¬¬åç« è°ˆè®ºæ³›å‹çš„ç»†èŠ‚ã€‚ç›®å‰ä½ åªéœ€è¦çŸ¥é“ï¼Œæ„å‘³ç€Optionçš„æˆå‘˜Someå¯ä»¥ä¿å­˜ä»»æ„ç±»å‹çš„æ•°æ®ï¼Œæ¯ä¸ªè¢«ç”¨æ¥æ›¿ä»£Tçš„å…·ä½“ç±»å‹ä½¿å¾—Optionæˆä¸ºä¸€ä¸ªä¸åŒçš„ç±»å‹(å¯ä»¥ç†è§£ä¸ºèµ‹äºˆæ³›å‹ä¸€ä¸ªå…·ä½“çš„ç±»å‹)ã€‚è¿™æ˜¯ä¸€äº›ä½¿ç”¨Optionå€¼æ¥ä¿å­˜æ•°å­—ç±»å‹å’Œå­—ç¬¦ä¸²ç±»å‹çš„ä¾‹å­ï¼š\nThe type ofÂ some_numberÂ isÂ Option. The type ofÂ some_charÂ isÂ Option, which is a different type. Rust can infer these types because weâ€™ve specified a value inside theÂ SomeÂ variant. ForÂ absent_number, Rust requires us to annotate the overallÂ OptionÂ type: the compiler canâ€™t infer the type that the correspondingÂ SomeÂ variant will hold by looking only at aÂ NoneÂ value. Here, we tell Rust that we mean forÂ absent_numberÂ to be of typeÂ Option.\nsome_numberçš„ç±»å‹æ˜¯Optionï¼Œsome_charçš„ç±»å‹æ˜¯Optionã€‚Rustèƒ½å¤Ÿæ¨æ–­å‡ºè¿™äº›ç±»å‹æ˜¯å› ä¸ºæˆ‘ä»¬æŒ‡å®šäº†Someæ‰€ä¿å­˜çš„å€¼ã€‚å¯¹äºÂ absent_numberï¼ŒRustè¦æ±‚æˆ‘ä»¬æä¾›Optionçš„å®Œæ•´æ³¨è§£ï¼Œå› ä¸ºåªæä¾›äº†ä¸€ä¸ªNoneå€¼ç¼–è¯‘å™¨æ— æ³•æ¨æ–­ç±»å‹ã€‚è¿™é‡Œçš„æ³¨è§£å‘Šè¯‰Rustabsent_numberçš„ç±»å‹æ˜¯Optionã€‚\nWhen we have aÂ SomeÂ value, we know that a value is present and the value is held within theÂ Some. When we have aÂ NoneÂ value, in some sense, it means the same thing as null: we donâ€™t have a valid value. So why is havingÂ OptionÂ any better than having null?\nå½“æœ‰ä¸€ä¸ªÂ SomeÂ å€¼æ—¶ï¼Œæˆ‘ä»¬å°±çŸ¥é“å­˜åœ¨ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼ä¿å­˜åœ¨Â SomeÂ ä¸­ã€‚å½“æœ‰ä¸ªÂ NoneÂ å€¼æ—¶ï¼Œåœ¨æŸç§æ„ä¹‰ä¸Šï¼Œå®ƒè·Ÿç©ºå€¼å…·æœ‰ç›¸åŒçš„æ„ä¹‰ï¼šå¹¶æ²¡æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚é‚£ä¹ˆï¼ŒOptionÂ ä¸ºä»€ä¹ˆå°±æ¯”ç©ºå€¼è¦å¥½å‘¢ï¼Ÿ(ä¸ºä»€ä¹ˆOption = None æ¯” null å¥½ï¼Ÿ)\nIn short, becauseÂ OptionÂ andÂ TÂ (whereÂ TÂ can be any type) are different types, the compiler wonâ€™t let us use anÂ OptionÂ value as if it were definitely a valid value. For example, this code wonâ€™t compile because itâ€™s trying to add anÂ i8Â to anÂ Option:\nlet x: i8 = 5; let y: Option\u003ci8\u003e = Some(5); let sum = x + y; ç®€è€Œè¨€ä¹‹ï¼Œå› ä¸ºÂ OptionÂ å’ŒTæ˜¯ä¸åŒçš„ç±»å‹ï¼Œç¼–è¯‘å™¨ä¸å…è®¸ä½ åƒä½¿ç”¨ä¸€ä¸ªç¡®å®šæœ‰æ•ˆçš„å€¼ä¸€æ ·ä½¿ç”¨OptionÂ ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸ºi8Â å’ŒOptionæ— æ³•ç›¸åŠ ã€‚\nIf we run this code, we get an error message like this:\n$ cargo run Compiling enums v0.1.0 (file:///projects/enums) error[E0277]: cannot add `Option\u003ci8\u003e` to `i8` --\u003e src/main.rs:5:17 | 5 | let sum = x + y; | ^ no implementation for `i8 + Option\u003ci8\u003e` | = help: the trait `Add\u003cOption\u003ci8\u003e\u003e` is not implemented for `i8` = help: the following other types implement trait `Add\u003cRhs\u003e`: \u003c\u0026'a f32 as Add\u003e \u003c\u0026'a f64 as Add\u003cf64\u003e\u003e \u003c\u0026'a i128 as Add\u003e \u003c\u0026'a i16 as Add\u003ci16\u003e\u003e \u003c\u0026'a i32 as Add\u003e \u003c\u0026'a i64 as Add\u003ci64\u003e\u003e \u003c\u0026'a i8 as Add\u003e \u003c\u0026'a isize as Add\u003cisize\u003e\u003e and 48 others For more information about this error, try `rustc --explain E0277`. error: could not compile `enums` due to previous error å¦‚æœæˆ‘ä»¬è¿è¡Œè¯¥ä»£ç ï¼Œä¼šå¾—åˆ°è¿™æ ·çš„é”™è¯¯ï¼š\nIntense! In effect, this error message means that Rust doesnâ€™t understand how to add anÂ i8Â and anÂ Option, because theyâ€™re different types. When we have a value of a type likeÂ i8Â in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have anÂ OptionÂ (or whatever type of value weâ€™re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.\nå¾ˆå¥½ï¼äº‹å®ä¸Šï¼Œé”™è¯¯ä¿¡æ¯æ„å‘³ç€ Rust ä¸çŸ¥é“è¯¥å¦‚ä½•å°†Â OptionÂ ä¸Â i8Â ç›¸åŠ ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚å½“åœ¨ Rust ä¸­æ‹¥æœ‰ä¸€ä¸ªåƒÂ i8Â è¿™æ ·ç±»å‹çš„å€¼æ—¶ï¼Œç¼–è¯‘å™¨ç¡®ä¿å®ƒæ€»æ˜¯æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥è‡ªä¿¡ä½¿ç”¨è€Œæ— éœ€åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨Â Optionï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚\nIn other words, you have to convert anÂ OptionÂ to aÂ TÂ before you can performÂ TÂ operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isnâ€™t null when it actually is.\næ¢å¥è¯è¯´ï¼Œåœ¨å¯¹Â OptionÂ è¿›è¡ŒÂ TÂ çš„è¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸ºÂ Tã€‚é€šå¸¸è¿™èƒ½å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„æƒ…å†µã€‚\nEliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that valueÂ Option. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isnâ€™t anÂ Option, youÂ canÂ safely assume that the value isnâ€™t null. This was a deliberate design decision for Rust to limit nullâ€™s pervasiveness and increase the safety of Rust code.\nä¸å†æ‹…å¿ƒä¼šé”™è¯¯åœ°å‡è®¾ä¸€ä¸ªéç©ºå€¼ï¼Œä¼šè®©ä½ å¯¹ä»£ç æ›´åŠ æœ‰ä¿¡å¿ƒã€‚ä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œä½ å¿…é¡»è¦æ˜¾å¼åœ°å°†å…¶æ”¾å…¥å¯¹åº”ç±»å‹çš„Â OptionÂ ä¸­ã€‚æ¥ç€ï¼Œå½“ä½¿ç”¨è¿™ä¸ªå€¼æ—¶ï¼Œå¿…é¡»æ˜ç¡®åœ°å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯Â OptionÂ ç±»å‹ï¼Œä½ å°±Â å¯ä»¥Â å®‰å…¨åœ°è®¤å®šå®ƒçš„å€¼ä¸ä¸ºç©ºã€‚è¿™æ˜¯ Rust çš„ä¸€ä¸ªç»è¿‡æ·±æ€ç†Ÿè™‘çš„è®¾è®¡å†³ç­–ï¼Œæ¥é™åˆ¶ç©ºå€¼çš„æ³›æ»¥ä»¥å¢åŠ  Rust ä»£ç çš„å®‰å…¨æ€§ã€‚\nSo, how do you get theÂ TÂ value out of aÂ SomeÂ variant when you have a value of typeÂ OptionÂ so you can use that value? TheÂ OptionÂ enum has a large number of methods that are useful in a variety of situations; you can check them out inÂ its documentation. Becoming familiar with the methods onÂ OptionÂ will be extremely useful in your journey with Rust.\né‚£ä¹ˆå½“æœ‰ä¸€ä¸ªÂ OptionÂ çš„å€¼æ—¶ï¼Œå¦‚ä½•ä»Â SomeÂ æˆå‘˜ä¸­å–å‡ºÂ TÂ çš„å€¼æ¥ä½¿ç”¨å®ƒå‘¢ï¼ŸOptionÂ æšä¸¾æ‹¥æœ‰å¤§é‡ç”¨äºå„ç§æƒ…å†µçš„æ–¹æ³•ï¼šä½ å¯ä»¥æŸ¥çœ‹å®ƒçš„æ–‡æ¡£ã€‚ç†Ÿæ‚‰Â OptionÂ çš„æ–¹æ³•å°†å¯¹ä½ çš„ Rust ä¹‹æ—…éå¸¸æœ‰ç”¨ã€‚\nIn general, in order to use anÂ OptionÂ value, you want to have code that will handle each variant. You want some code that will run only when you have aÂ Some(T)Â value, and this code is allowed to use the innerÂ T. You want some other code to run if you have aÂ NoneÂ value, and that code doesnâ€™t have aÂ TÂ value available. TheÂ matchÂ expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.\næ€»çš„æ¥è¯´ï¼Œä¸ºäº†ä½¿ç”¨Â OptionÂ å€¼ï¼Œéœ€è¦ç¼–å†™å¤„ç†æ¯ä¸ªæˆå‘˜çš„ä»£ç ã€‚ä½ æƒ³è¦ä¸€äº›ä»£ç åªå½“æ‹¥æœ‰Â Some(T)Â å€¼æ—¶è¿è¡Œï¼Œå…è®¸è¿™äº›ä»£ç ä½¿ç”¨å…¶ä¸­çš„Â Tã€‚ä¹Ÿå¸Œæœ›ä¸€äº›ä»£ç åœ¨å€¼ä¸ºÂ NoneÂ æ—¶è¿è¡Œï¼Œè¿™äº›ä»£ç å¹¶æ²¡æœ‰ä¸€ä¸ªå¯ç”¨çš„Â TÂ å€¼ã€‚matchÂ è¡¨è¾¾å¼å°±æ˜¯è¿™ä¹ˆä¸€ä¸ªå¤„ç†æšä¸¾çš„æ§åˆ¶æµç»“æ„ï¼šå®ƒä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°çš„å€¼ä¸­çš„æ•°æ®ã€‚\n","wordCount":"1285","inLanguage":"zh","datePublished":"2022-12-29T15:41:07+08:00","dateModified":"2022-12-29T15:41:07+08:00","author":[{"@type":"Person","name":"å£¹æ¬¡å¿ƒ"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/"},"publisher":{"@type":"Organization","name":"Do not panic!","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="Yicixin's blog (Alt + H)">Yicixin's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=æ ‡ç­¾ğŸ·ï¸><span>æ ‡ç­¾ğŸ·ï¸</span></a></li><li><a href=https://www.yici.xin/archives/ title=å½’æ¡£ğŸ•°ï¸><span>å½’æ¡£ğŸ•°ï¸</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>ä¸»é¡µ</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;Â»&nbsp;<a href=https://www.yici.xin/post/read/>ğŸ“–é˜…è¯»</a></div><h1 class=post-title>Rust Optionæšä¸¾</h1><div class=post-meta><span title='2022-12-29 15:41:07 +0800 +0800'>2022-12-29</span>&nbsp;Â·&nbsp;7 åˆ†é’Ÿ&nbsp;Â·&nbsp;1285 å­—&nbsp;Â·&nbsp;å£¹æ¬¡å¿ƒ&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/read/rust-Option%e6%9e%9a%e4%b8%be.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><blockquote><p><a href=https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values>åŸæ–‡é“¾æ¥ğŸ”—</a></p></blockquote><h2 id=the-option-enum-and-its-advantages-over-null-values>The Option Enum and Its Advantages Over Null Values<a hidden class=anchor aria-hidden=true href=#the-option-enum-and-its-advantages-over-null-values>#</a></h2><p>æ¯”nullæ›´ä¼˜çš„é€‰æ‹©â€”â€”Optionæšä¸¾</p><p>This section explores a case study ofÂ <code>Option</code>, which is another enum defined by the standard library. TheÂ <code>Option</code>Â type encodes the very common scenario in which a value could be something or it could be nothing.</p><p>è¿™ä¸€èŠ‚æ¢è®¨<code>Option</code>çš„ä¸€ä¸ªå­¦ä¹ æ¡ˆä¾‹ï¼Œ<code>Option</code>æ˜¯å¦ä¸€ä¸ªç”±æ ‡å‡†åº“å®šä¹‰çš„æšä¸¾ã€‚Opitonç±»å‹ç¼–ç äº†ä¸€ä¸ªéå¸¸å¸¸è§åœºæ™¯ï¼Œå€¼å¯ä»¥æ˜¯æŸå€¼ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºã€‚</p><p>For example, if you request the first of a list containing items, you would get a value. If you request the first item of an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether youâ€™ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.</p><p>ä¾‹å¦‚ï¼Œå¦‚æœä½ å°è¯•è¯·æ±‚ä¸€ä¸ªéç©ºlistçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ªå€¼ã€‚å¦‚æœä½ å°è¯•è¯·æ±‚ä¸€ä¸ªç©ºlistçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä½ ä»€ä¹ˆéƒ½å¾—ä¸åˆ°ã€‚ç”¨ç±»å‹ç³»ç»Ÿæ¥è¡¨è¾¾è¿™ä¸ªæ¦‚å¿µæ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥æ£€æŸ¥ä½ æ˜¯å¦å¤„ç†äº†æ‰€æœ‰ä½ åº”è¯¥å¤„ç†çš„æƒ…å†µï¼›è¿™ä¸ªåŠŸèƒ½èƒ½å¤Ÿé¿å…åœ¨å…¶ä»–ç¼–ç¨‹è¯­è¨€ä¸­åŠå…¶å¸¸è§çš„bugã€‚</p><p>Programming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesnâ€™t have the null feature that many other languages have.Â <em>Null</em>Â is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.</p><p>è®¾è®¡ç¼–ç¨‹è¯­è¨€ç»å¸¸éœ€è¦è€ƒè™‘çš„æ˜¯åŒ…å«å“ªäº›ç‰¹æ€§ï¼Œä½†æ˜¯è€ƒè™‘æ’é™¤å“ªäº›ç‰¹æ€§ä¸€æ ·é‡è¦ã€‚Rustä¸å­˜åœ¨å¾ˆå¤šè¯­è¨€æœ‰çš„nullç‰¹æ€§ã€‚Nullä»£è¡¨ä¸€ä¸ªä»€ä¹ˆéƒ½æ²¡æœ‰çš„å€¼ï¼Œåœ¨æœ‰nullçš„è¯­è¨€é‡Œï¼Œå˜é‡æ€»æ˜¯ä¸¤ä¸ªçŠ¶æ€ä¹‹ä¸€ï¼šnullæˆ–énullã€‚</p><p>The problem with null values is that if you try to use a null value as a not-null value, youâ€™ll get an error of some kind. Because this null or not-null property is pervasive, itâ€™s extremely easy to make this kind of error.</p><p>nullçš„é—®é¢˜åœ¨äºï¼Œå¦‚æœä½ å°è¯•åƒä½¿ç”¨énullå€¼ä¸€æ ·ä½¿ç”¨nullå€¼ï¼Œä½ å°†å¾—åˆ°ä¸€ä¸ªæŸç§é”™è¯¯ï¼Œå› ä¸ºnullå’Œénullå±æ€§æ˜¯æ— å¤„ä¸åœ¨çš„ï¼ŒçŠ¯è¿™ç§é”™æ˜¯åŠå…¶ç®€å•çš„ã€‚</p><p>However, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.</p><p>ç„¶è€Œï¼Œnullå°è¯•è¡¨è¾¾çš„æ¦‚å¿µä»ç„¶æ˜¯æœ‰æ„ä¹‰çš„ï¼šnullæ˜¯ä¸€ä¸ªå› ä¸ºæŸç§åŸå› ç›®å‰æ— æ•ˆæˆ–ç¼ºå¤±çš„å€¼ã€‚</p><p>The problem isnâ€™t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum isÂ <code>Option&lt;T></code>, and it isÂ <a href=https://doc.rust-lang.org/stable/std/option/enum.Option.html>defined by the standard library</a>Â as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> Option<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    None,
</span></span><span style=display:flex><span>    Some(T),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>é—®é¢˜ä¸åœ¨äºæ¦‚å¿µï¼Œè€Œåœ¨äºå…·ä½“å®ç°ã€‚ä¸ºæ­¤ï¼ŒRustä¸­ä¸å­˜åœ¨nullï¼Œä½†æ˜¯å®ƒæä¾›äº†ä¸€ä¸ªæšä¸¾ï¼Œå®ƒç¼–ç äº†ä¸€ä¸ªå€¼å­˜åœ¨ä¸å¦çš„æ¦‚å¿µã€‚è¿™ä¸ªæšä¸¾å°±æ˜¯<code>Option&lt;T></code>ï¼Œè€Œä¸”å®ƒ<a href=https://rustwiki.org/zh-CN/std/option/enum.Option.html>å®šä¹‰äºæ ‡å‡†åº“ä¸­</a>ï¼Œå¦‚ä¸‹:</p><p>TheÂ <code>Option&lt;T></code>Â enum is so useful that itâ€™s even included in the prelude; you donâ€™t need to bring it into scope explicitly. Its variants are also included in the prelude: you can useÂ <code>Some</code>Â andÂ <code>None</code>Â directly without theÂ <code>Option::</code>Â prefix. TheÂ <code>Option&lt;T></code>Â enum is still just a regular enum, andÂ <code>Some(T)</code>Â andÂ <code>None</code>Â are still variants of typeÂ <code>Option&lt;T></code>.</p><p><code>Option&lt;T></code>æšä¸¾æ˜¯å¦‚æ­¤æœ‰ç”¨ä»¥è‡³äºå®ƒè¢«åŒ…å«åœ¨äº†<code>prelude</code>ä¸­ï¼›ä½ ä¸éœ€è¦æ˜¾å¼åœ°å¼•å…¥ã€‚å®ƒçš„æˆå‘˜ä¹ŸåŒ…è¢«å«åœ¨äº†<code>prelude</code>ä¸­ï¼Œä½ å¯ä»¥ç›´æ¥ä½¿ç”¨<code>Some</code>Â å’Œ Â <code>None</code>Â è€Œä¸éœ€è¦æ·»åŠ å‰ç¼€Â <code>Option::</code>Â ã€‚å³ä¾¿å¦‚æ­¤Â <code>Option&lt;T></code>Â ä¹Ÿä»æ˜¯å¸¸è§„çš„æšä¸¾ï¼Œ<code>Some(T)</code>Â å’ŒÂ <code>None</code>Â ä»æ˜¯Â <code>Option&lt;T></code>Â çš„æˆå‘˜ã€‚</p><p>TheÂ <code>&lt;T></code>Â syntax is a feature of Rust we havenâ€™t talked about yet. Itâ€™s a generic type parameter, and weâ€™ll cover generics in more detail in Chapter 10. For now, all you need to know is thatÂ <code>&lt;T></code>Â means theÂ <code>Some</code>Â variant of theÂ <code>Option</code>Â enum can hold one piece of data of any type, and that each concrete type that gets used in place ofÂ <code>T</code>Â makes the overallÂ <code>Option&lt;T></code>Â type a different type. Here are some examples of usingÂ <code>Option</code>Â values to hold number types and string types:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_number <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> some_char <span style=color:#f92672>=</span> Some(<span style=color:#e6db74>&#39;e&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> absent_number: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> None;
</span></span></code></pre></div><p><code>&lt;T></code>è¯­æ³•æ˜¯Rustçš„ä¸€ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰æåˆ°è¿‡ã€‚å®ƒæ˜¯ä¸€ä¸ªæ³›å‹å‚æ•°ï¼Œæˆ‘ä»¬å°†åœ¨ç¬¬åç« è°ˆè®ºæ³›å‹çš„ç»†èŠ‚ã€‚ç›®å‰ä½ åªéœ€è¦çŸ¥é“ï¼Œ<code>&lt;T></code>æ„å‘³ç€<code>Option</code>çš„æˆå‘˜<code>Some</code>å¯ä»¥ä¿å­˜ä»»æ„ç±»å‹çš„æ•°æ®ï¼Œæ¯ä¸ªè¢«ç”¨æ¥æ›¿ä»£<code>T</code>çš„å…·ä½“ç±»å‹ä½¿å¾—<code>Option&lt;T></code>æˆä¸ºä¸€ä¸ªä¸åŒçš„ç±»å‹(å¯ä»¥ç†è§£ä¸ºèµ‹äºˆæ³›å‹ä¸€ä¸ªå…·ä½“çš„ç±»å‹)ã€‚è¿™æ˜¯ä¸€äº›ä½¿ç”¨<code>Option</code>å€¼æ¥ä¿å­˜æ•°å­—ç±»å‹å’Œå­—ç¬¦ä¸²ç±»å‹çš„ä¾‹å­ï¼š</p><p>The type ofÂ <code>some_number</code>Â isÂ <code>Option&lt;i32></code>. The type ofÂ <code>some_char</code>Â isÂ <code>Option&lt;char></code>, which is a different type. Rust can infer these types because weâ€™ve specified a value inside theÂ <code>Some</code>Â variant. ForÂ <code>absent_number</code>, Rust requires us to annotate the overallÂ <code>Option</code>Â type: the compiler canâ€™t infer the type that the correspondingÂ <code>Some</code>Â variant will hold by looking only at aÂ <code>None</code>Â value. Here, we tell Rust that we mean forÂ <code>absent_number</code>Â to be of typeÂ <code>Option&lt;i32></code>.</p><p><code>some_number</code>çš„ç±»å‹æ˜¯<code>Option&lt;i32></code>ï¼Œ<code>some_char</code>çš„ç±»å‹æ˜¯<code>Option&lt;char></code>ã€‚Rustèƒ½å¤Ÿæ¨æ–­å‡ºè¿™äº›ç±»å‹æ˜¯å› ä¸ºæˆ‘ä»¬æŒ‡å®šäº†<code>Some</code>æ‰€ä¿å­˜çš„å€¼ã€‚å¯¹äºÂ <code>absent_number</code>ï¼ŒRustè¦æ±‚æˆ‘ä»¬æä¾›<code>Option</code>çš„å®Œæ•´æ³¨è§£ï¼Œå› ä¸ºåªæä¾›äº†ä¸€ä¸ªNoneå€¼ç¼–è¯‘å™¨æ— æ³•æ¨æ–­ç±»å‹ã€‚è¿™é‡Œçš„æ³¨è§£å‘Šè¯‰Rust<code>absent_number</code>çš„ç±»å‹æ˜¯<code>Option&lt;i32></code>ã€‚</p><p>When we have aÂ <code>Some</code>Â value, we know that a value is present and the value is held within theÂ <code>Some</code>. When we have aÂ <code>None</code>Â value, in some sense, it means the same thing as null: we donâ€™t have a valid value. So why is havingÂ <code>Option&lt;T></code>Â any better than having null?</p><p>å½“æœ‰ä¸€ä¸ªÂ <code>Some</code>Â å€¼æ—¶ï¼Œæˆ‘ä»¬å°±çŸ¥é“å­˜åœ¨ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼ä¿å­˜åœ¨Â <code>Some</code>Â ä¸­ã€‚å½“æœ‰ä¸ªÂ <code>None</code>Â å€¼æ—¶ï¼Œåœ¨æŸç§æ„ä¹‰ä¸Šï¼Œå®ƒè·Ÿç©ºå€¼å…·æœ‰ç›¸åŒçš„æ„ä¹‰ï¼šå¹¶æ²¡æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚é‚£ä¹ˆï¼Œ<code>Option&lt;T></code>Â ä¸ºä»€ä¹ˆå°±æ¯”ç©ºå€¼è¦å¥½å‘¢ï¼Ÿ(ä¸ºä»€ä¹ˆ<code>Option&lt;T> = None</code> æ¯” null å¥½ï¼Ÿ)</p><p>In short, becauseÂ <code>Option&lt;T></code>Â andÂ <code>T</code>Â (whereÂ <code>T</code>Â can be any type) are different types, the compiler wonâ€™t let us use anÂ <code>Option&lt;T></code>Â value as if it were definitely a valid value. For example, this code wonâ€™t compile because itâ€™s trying to add anÂ <code>i8</code>Â to anÂ <code>Option&lt;i8></code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> x: <span style=color:#66d9ef>i8</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> y: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> Some(<span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y;
</span></span></code></pre></div><p>ç®€è€Œè¨€ä¹‹ï¼Œå› ä¸ºÂ <code>Option&lt;T></code>Â å’Œ<code>T</code>æ˜¯ä¸åŒçš„ç±»å‹ï¼Œç¼–è¯‘å™¨ä¸å…è®¸ä½ åƒä½¿ç”¨ä¸€ä¸ªç¡®å®šæœ‰æ•ˆçš„å€¼ä¸€æ ·ä½¿ç”¨<code>Option&lt;T></code>Â ã€‚ä¾‹å¦‚ï¼Œä¸‹é¢çš„ä»£ç æ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œå› ä¸º<code>i8</code>Â å’Œ<code>Option&lt;i8></code>æ— æ³•ç›¸åŠ ã€‚</p><p>If we run this code, we get an error message like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> cargo run
</span></span><span style=display:flex><span>   Compiling enums v0.<span style=color:#ae81ff>1</span>.<span style=color:#ae81ff>0</span> (file:<span style=color:#f92672>///</span>projects<span style=color:#f92672>/</span>enums)
</span></span><span style=display:flex><span>error[E0277]: cannot <span style=color:#66d9ef>add</span> <span style=color:#f92672>`</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;`</span> <span style=color:#66d9ef>to</span> <span style=color:#f92672>`</span>i8<span style=color:#f92672>`</span>
</span></span><span style=display:flex><span> <span style=color:#f92672>--&gt;</span> src<span style=color:#f92672>/</span>main.rs:<span style=color:#ae81ff>5</span>:<span style=color:#ae81ff>17</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>5</span> <span style=color:#f92672>|</span>     let sum <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> y;
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>                 <span style=color:#f92672>^</span> no implementation <span style=color:#66d9ef>for</span> <span style=color:#f92672>`</span>i8 <span style=color:#f92672>+</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;`</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: the trait <span style=color:#f92672>`</span><span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>&lt;</span>i8<span style=color:#f92672>&gt;&gt;`</span> <span style=color:#66d9ef>is</span> <span style=color:#66d9ef>not</span> implemented <span style=color:#66d9ef>for</span> <span style=color:#f92672>`</span>i8<span style=color:#f92672>`</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>=</span> help: the following other types implement trait <span style=color:#f92672>`</span><span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>Rhs<span style=color:#f92672>&gt;`</span>:
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a f32 as Add&lt;f32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a f64 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>f64<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i128 as Add&lt;i128&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a i16 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>i16<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i32 as Add&lt;i32&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a i64 <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>i64<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>&lt;&amp;</span><span style=color:#e6db74>&#39;a i8 as Add&lt;i8&gt;&gt;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>            &lt;&amp;&#39;</span>a isize <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>Add</span><span style=color:#f92672>&lt;</span>isize<span style=color:#f92672>&gt;&gt;</span>
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>and</span> <span style=color:#ae81ff>48</span> others
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>For</span> more information about this error, try <span style=color:#f92672>`</span>rustc <span style=color:#f92672>--</span><span style=color:#66d9ef>explain</span> E0277<span style=color:#f92672>`</span>.
</span></span><span style=display:flex><span>error: could <span style=color:#66d9ef>not</span> compile <span style=color:#f92672>`</span>enums<span style=color:#f92672>`</span> due <span style=color:#66d9ef>to</span> previous error
</span></span></code></pre></div><p>å¦‚æœæˆ‘ä»¬è¿è¡Œè¯¥ä»£ç ï¼Œä¼šå¾—åˆ°è¿™æ ·çš„é”™è¯¯ï¼š</p><p>Intense! In effect, this error message means that Rust doesnâ€™t understand how to add anÂ <code>i8</code>Â and anÂ <code>Option&lt;i8></code>, because theyâ€™re different types. When we have a value of a type likeÂ <code>i8</code>Â in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have anÂ <code>Option&lt;i8></code>Â (or whatever type of value weâ€™re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.</p><p>å¾ˆå¥½ï¼äº‹å®ä¸Šï¼Œé”™è¯¯ä¿¡æ¯æ„å‘³ç€ Rust ä¸çŸ¥é“è¯¥å¦‚ä½•å°†Â <code>Option&lt;i8></code>Â ä¸Â <code>i8</code>Â ç›¸åŠ ï¼Œå› ä¸ºå®ƒä»¬çš„ç±»å‹ä¸åŒã€‚å½“åœ¨ Rust ä¸­æ‹¥æœ‰ä¸€ä¸ªåƒÂ <code>i8</code>Â è¿™æ ·ç±»å‹çš„å€¼æ—¶ï¼Œç¼–è¯‘å™¨ç¡®ä¿å®ƒæ€»æ˜¯æœ‰ä¸€ä¸ªæœ‰æ•ˆçš„å€¼ã€‚æˆ‘ä»¬å¯ä»¥è‡ªä¿¡ä½¿ç”¨è€Œæ— éœ€åšç©ºå€¼æ£€æŸ¥ã€‚åªæœ‰å½“ä½¿ç”¨Â <code>Option&lt;i8></code>ï¼ˆæˆ–è€…ä»»ä½•ç”¨åˆ°çš„ç±»å‹ï¼‰çš„æ—¶å€™éœ€è¦æ‹…å¿ƒå¯èƒ½æ²¡æœ‰å€¼ï¼Œè€Œç¼–è¯‘å™¨ä¼šç¡®ä¿æˆ‘ä»¬åœ¨ä½¿ç”¨å€¼ä¹‹å‰å¤„ç†äº†ä¸ºç©ºçš„æƒ…å†µã€‚</p><p>In other words, you have to convert anÂ <code>Option&lt;T></code>Â to aÂ <code>T</code>Â before you can performÂ <code>T</code>Â operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isnâ€™t null when it actually is.</p><p>æ¢å¥è¯è¯´ï¼Œåœ¨å¯¹Â <code>Option&lt;T></code>Â è¿›è¡ŒÂ <code>T</code>Â çš„è¿ç®—ä¹‹å‰å¿…é¡»å°†å…¶è½¬æ¢ä¸ºÂ <code>T</code>ã€‚é€šå¸¸è¿™èƒ½å¸®åŠ©æˆ‘ä»¬æ•è·åˆ°ç©ºå€¼æœ€å¸¸è§çš„é—®é¢˜ä¹‹ä¸€ï¼šå‡è®¾æŸå€¼ä¸ä¸ºç©ºä½†å®é™…ä¸Šä¸ºç©ºçš„æƒ…å†µã€‚</p><p>Eliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that valueÂ <code>Option&lt;T></code>. Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isnâ€™t anÂ <code>Option&lt;T></code>, youÂ <em>can</em>Â safely assume that the value isnâ€™t null. This was a deliberate design decision for Rust to limit nullâ€™s <strong>pervasiveness</strong> and increase the safety of Rust code.</p><p>ä¸å†æ‹…å¿ƒä¼šé”™è¯¯åœ°å‡è®¾ä¸€ä¸ªéç©ºå€¼ï¼Œä¼šè®©ä½ å¯¹ä»£ç æ›´åŠ æœ‰ä¿¡å¿ƒã€‚ä¸ºäº†æ‹¥æœ‰ä¸€ä¸ªå¯èƒ½ä¸ºç©ºçš„å€¼ï¼Œä½ å¿…é¡»è¦æ˜¾å¼åœ°å°†å…¶æ”¾å…¥å¯¹åº”ç±»å‹çš„Â <code>Option&lt;T></code>Â ä¸­ã€‚æ¥ç€ï¼Œå½“ä½¿ç”¨è¿™ä¸ªå€¼æ—¶ï¼Œå¿…é¡»æ˜ç¡®åœ°å¤„ç†å€¼ä¸ºç©ºçš„æƒ…å†µã€‚åªè¦ä¸€ä¸ªå€¼ä¸æ˜¯Â <code>Option&lt;T></code>Â ç±»å‹ï¼Œä½ å°±Â <strong>å¯ä»¥</strong>Â å®‰å…¨åœ°è®¤å®šå®ƒçš„å€¼ä¸ä¸ºç©ºã€‚è¿™æ˜¯ Rust çš„ä¸€ä¸ªç»è¿‡æ·±æ€ç†Ÿè™‘çš„è®¾è®¡å†³ç­–ï¼Œæ¥é™åˆ¶ç©ºå€¼çš„æ³›æ»¥ä»¥å¢åŠ  Rust ä»£ç çš„å®‰å…¨æ€§ã€‚</p><p>So, how do you get theÂ <code>T</code>Â value out of aÂ <code>Some</code>Â variant when you have a value of typeÂ <code>Option&lt;T></code>Â so you can use that value? TheÂ <code>Option&lt;T></code>Â enum has a large number of methods that are useful in a variety of situations; you can check them out inÂ <a href=https://doc.rust-lang.org/stable/std/option/enum.Option.html>its documentation</a>. Becoming familiar with the methods onÂ <code>Option&lt;T></code>Â will be extremely useful in your journey with Rust.</p><p>é‚£ä¹ˆå½“æœ‰ä¸€ä¸ªÂ <code>Option&lt;T></code>Â çš„å€¼æ—¶ï¼Œå¦‚ä½•ä»Â <code>Some</code>Â æˆå‘˜ä¸­å–å‡ºÂ <code>T</code>Â çš„å€¼æ¥ä½¿ç”¨å®ƒå‘¢ï¼Ÿ<code>Option&lt;T></code>Â æšä¸¾æ‹¥æœ‰å¤§é‡ç”¨äºå„ç§æƒ…å†µçš„æ–¹æ³•ï¼šä½ å¯ä»¥æŸ¥çœ‹<a href=https://rustwiki.org/zh-CN/std/option/enum.Option.html>å®ƒçš„æ–‡æ¡£</a>ã€‚ç†Ÿæ‚‰Â <code>Option&lt;T></code>Â çš„æ–¹æ³•å°†å¯¹ä½ çš„ Rust ä¹‹æ—…éå¸¸æœ‰ç”¨ã€‚</p><p>In general, in order to use anÂ <code>Option&lt;T></code>Â value, you want to have code that will handle each variant. You want some code that will run only when you have aÂ <code>Some(T)</code>Â value, and this code is allowed to use the innerÂ <code>T</code>. You want some other code to run if you have aÂ <code>None</code>Â value, and that code doesnâ€™t have aÂ <code>T</code>Â value available. TheÂ <code>match</code>Â expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.</p><p>æ€»çš„æ¥è¯´ï¼Œä¸ºäº†ä½¿ç”¨Â <code>Option&lt;T></code>Â å€¼ï¼Œéœ€è¦ç¼–å†™å¤„ç†æ¯ä¸ªæˆå‘˜çš„ä»£ç ã€‚ä½ æƒ³è¦ä¸€äº›ä»£ç åªå½“æ‹¥æœ‰Â <code>Some(T)</code>Â å€¼æ—¶è¿è¡Œï¼Œå…è®¸è¿™äº›ä»£ç ä½¿ç”¨å…¶ä¸­çš„Â <code>T</code>ã€‚ä¹Ÿå¸Œæœ›ä¸€äº›ä»£ç åœ¨å€¼ä¸ºÂ <code>None</code>Â æ—¶è¿è¡Œï¼Œè¿™äº›ä»£ç å¹¶æ²¡æœ‰ä¸€ä¸ªå¯ç”¨çš„Â <code>T</code>Â å€¼ã€‚<code>match</code>Â è¡¨è¾¾å¼å°±æ˜¯è¿™ä¹ˆä¸€ä¸ªå¤„ç†æšä¸¾çš„æ§åˆ¶æµç»“æ„ï¼šå®ƒä¼šæ ¹æ®æšä¸¾çš„æˆå‘˜è¿è¡Œä¸åŒçš„ä»£ç ï¼Œè¿™äº›ä»£ç å¯ä»¥ä½¿ç”¨åŒ¹é…åˆ°çš„å€¼ä¸­çš„æ•°æ®ã€‚</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/rust/>rust</a></li><li><a href=https://www.yici.xin/tags/%E7%BF%BB%E8%AF%91/>ç¿»è¯‘</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/tech/golang-map%E7%9A%84%E6%93%8D%E4%BD%9C/><span class=title>Â« ä¸Šä¸€é¡µ</span><br><span>Golang-mapçš„æ“ä½œ</span></a>
<a class=next href=https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/><span class=title>ä¸‹ä¸€é¡µ Â»</span><br><span>Rustç¨‹åºè®¾è®¡â€”â€”æšä¸¾</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://www.yici.xin/>Do not panic!</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="å·²å¤åˆ¶ï¼",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>
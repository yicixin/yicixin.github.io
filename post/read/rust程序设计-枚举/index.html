<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css integrity=sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm crossorigin=anonymous><script src=https://code.jquery.com/jquery-3.2.1.slim.min.js integrity=sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js integrity=sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q crossorigin=anonymous></script>
<script src=https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js integrity=sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl crossorigin=anonymous></script><title>Rust程序设计——枚举 | yicixin's blog</title><meta name=keywords content="rust,翻译"><meta name=description content="原文链接🔗
Defining an Enum 定义枚举
Where structs give you a way of grouping together related fields and data, like a Rectangle with its width and height, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that Rectangle is one of a set of possible shapes that also includes Circle and Triangle. To do this, Rust allows us to encode these possibilities as an enum."><meta name=author content="壹次心"><link rel=canonical href=https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.00d594ac5404702263b7df2f247aae4053818963176b093f9b95a1fc7e4e0b42.css integrity="sha256-ANWUrFQEcCJjt98vJHquQFOBiWMXawk/m5Wh/H5OC0I=" rel="preload stylesheet" as=style><link rel=icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=16x16 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=icon type=image/png sizes=32x32 href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=apple-touch-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><link rel=mask-icon href=https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Rust程序设计——枚举"><meta property="og:description" content="原文链接🔗
Defining an Enum 定义枚举
Where structs give you a way of grouping together related fields and data, like a Rectangle with its width and height, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that Rectangle is one of a set of possible shapes that also includes Circle and Triangle. To do this, Rust allows us to encode these possibilities as an enum."><meta property="og:type" content="article"><meta property="og:url" content="https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/"><meta property="og:image" content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-12-28T23:09:59+08:00"><meta property="article:modified_time" content="2022-12-28T23:09:59+08:00"><meta property="og:site_name" content="yicixin's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.yici.xin/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Rust程序设计——枚举"><meta name=twitter:description content="原文链接🔗
Defining an Enum 定义枚举
Where structs give you a way of grouping together related fields and data, like a Rectangle with its width and height, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that Rectangle is one of a set of possible shapes that also includes Circle and Triangle. To do this, Rust allows us to encode these possibilities as an enum."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.yici.xin/post/"},{"@type":"ListItem","position":2,"name":"📖阅读","item":"https://www.yici.xin/post/read/"},{"@type":"ListItem","position":3,"name":"Rust程序设计——枚举","item":"https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust程序设计——枚举","name":"Rust程序设计——枚举","description":"原文链接🔗\nDefining an Enum 定义枚举\nWhere structs give you a way of grouping together related fields and data, like a Rectangle with its width and height, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that Rectangle is one of a set of possible shapes that also includes Circle and Triangle. To do this, Rust allows us to encode these possibilities as an enum.","keywords":["rust","翻译"],"articleBody":" 原文链接🔗\nDefining an Enum 定义枚举\nWhere structs give you a way of grouping together related fields and data, like a Rectangle with its width and height, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that Rectangle is one of a set of possible shapes that also includes Circle and Triangle. To do this, Rust allows us to encode these possibilities as an enum.\n结构体提供给我们将相联系的字段和数据聚合在一起的手段，像是有width和height两个字段的Rectangle结构，枚举所提供的能力是，表示一个值是一组可能值中的一个。例如，我们表示Rectangle是一组形状中的一个，这组形状可能还包括了圆形、三角形。在Rust中，我们可以将这些可能的值编码成一个枚举。\nLet’s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. Because these are the only possibilities for an IP address that our program will come across, we can enumerate all possible variants, which is where enumeration gets its name.\n让我们看一种我们想要在代码中表达的情况并且来解释为什么枚举是有用的，且在这种情况下比结构体是更适合的。假设我们需要使用IP地址。目前，IP地址有两种主流标准，V4和V6.在我们的程序中，这些是唯一可能遇到的IP地址形式，所以我们可以枚举所有的可能，这就是枚举名称的来源。\nAny IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because an enum value can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.\n任何IP地址都可以是V4或者V6，但是不能同时是两者。IP地址的这个属性使得枚举是合适的，因为枚举成员只能是它所有可能中的一个。V4和V6地址都是IP地址，所以当代码处理适用于任何IP地址的情况时，它们应该被当做同一种类型。\nWe can express this concept in code by defining an IpAddrKind enumeration and listing the possible kinds an IP address can be, V4 and V6. These are the variants of the enum:\nenum IpAddrKind { V4, V6, } IpAddrKind is now a custom data type that we can use elsewhere in our code. 我们可以在代码中表示这个概念，通过定义一个IpAddrKind枚举，并且列出IP地址所有的类型。\nIpAddrKind 现在是一个自定义数据类型，我们可以在代码中任何地方使用它。\nEnum Values We can create instances of each of the two variants of IpAddrKind like this:\nlet four = IpAddrKind::V4; let six = IpAddrKind::V6; 我们可以像这样创建这两个枚举成员的每个实例。\nNote that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. This is useful because now both values IpAddrKind::V4 and IpAddrKind::V6 are of the same type: IpAddrKind. We can then, for instance, define a function that takes any IpAddrKind:\nfn route(ip_kind: IpAddrKind) {} And we can call this function with either variant:\nroute(IpAddrKind::V4); route(IpAddrKind::V6); 注意，枚举的成员位于其枚举标识符的命名空间下，使用两个冒号分隔，这么设计的益处是现在 IpAddrKind::V4 和 IpAddrKind::V6 都是 IpAddrKind 类型的。例如，接着可以定义一个函数来获取任何 IpAddrKind：\n我们可以使用任一该枚举的成员来调用这个函数：\nUsing enums has even more advantages. Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address data; we only know what kind it is. Given that you just learned about structs in Chapter 5, you might be tempted to tackle this problem with structs as shown in Listing 6-1.\n使用枚举还有更多优点，进一步考虑一下我们的 IP 地址类型，目前没有一个存储实际 IP 地址 数据 的方法；只知道它是什么 类型 的。考虑到已经在第 5 章学习过结构体了，你可能会像示例 6-1 那样处理这个问题：\nfn main() { enum IpAddrKind { V4, V6, } struct IpAddr { kind: IpAddrKind, address: String, } let home = IpAddr { kind: IpAddrKind::V4, address: String::from(\"127.0.0.1\"), }; let loopback = IpAddr { kind: IpAddrKind::V6, address: String::from(\"::1\"), }; } Listing 6-1: Storing the data and IpAddrKind variant of an IP address using a struct 示例 6-1：将 IP 地址的数据和 IpAddrKind 成员存储在一个 struct 中\nHere, we’ve defined a struct IpAddr that has two fields: a kind field that is of type IpAddrKind (the enum we defined previously) and an address field of type String. We have two instances of this struct. The first is home, and it has the value IpAddrKind::V4 as its kind with associated address data of 127.0.0.1. The second instance is loopback. It has the other variant of IpAddrKind as its kind value, V6, and has address ::1 associated with it. We’ve used a struct to bundle the kind and address values together, so now the variant is associated with the value.\n这里我们定义了一个有两个字段的结构体， IpAddrKind（之前定义的枚举）类型的 kind 字段和 String 类型 address 字段。我们有这个结构体的两个实例。第一个，home，它的 kind 的值是 IpAddrKind::V4 ，与之相关联的地址数据是 127.0.0.1。第二个实例，loopback，kind 的值是 IpAddrKind 的另一个成员，V6，关联的地址是 ::1。我们使用了一个结构体来将 kind 和 address 打包在一起，现在枚举成员就与值相关联了。\nHowever, representing the same concept using just an enum is more concise: rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the IpAddr enum says that both V4 and V6 variants will have associated String values:\nenum IpAddr { V4(String), V6(String), } let home = IpAddr::V4(String::from(\"127.0.0.1\")); let loopback = IpAddr::V6(String::from(\"::1\")); 然而，我们可以使用枚举来更简洁地表达相同的概念，不是将枚举作为结构体的一部分，而是将数据直接放进每一个枚举成员。这里IpAddr 枚举的新定义， V4 和 V6 成员都关联了 String值：\nWe attach data to each variant of the enum directly, so there is no need for an extra struct. Here it’s also easier to see another detail of how enums work: the name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, IpAddr::V4() is a function call that takes a String argument and returns an instance of the IpAddr type. We automatically get this constructor function defined as a result of defining the enum.\n我们将数据直接放进每一个枚举成员，所以不需要额外的结构体。这里也能够看到枚举用法的另一个细节，我们所定义的每一枚举成员的名称同时也是一个枚举实例的构造函数。也就是说，IpAddr::V4()是一个以 String 作为参数，且返回一个IpAddr类型实例的函数调用。这个构造函数是我们在定义枚举时就自动得到的一个结果。\nThere’s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store V4 addresses as four u8 values but still express V6 addresses as one String value, we wouldn’t be able to with a struct. Enums handle this case with ease:\nfn main() { enum IpAddr { V4(u8, u8, u8, u8), V6(String), } let home = IpAddr::V4(127, 0, 0, 1); let loopback = IpAddr::V6(String::from(\"::1\")); } 还有另一个枚举比结构体更合适的例子，每个枚举成员可以有不同的类型和数据数量，IPV4地址的格式总是由四个0-255之间的数字组成。如果我们想要把V4地址以四个u8类型值进行存储但同时仍用String类型表示V6地址，使用结构体是做不到的。枚举可以很简单地处理这个情况:\nWe’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that the standard library has a definition we can use! Let’s look at how the standard library defines IpAddr: it has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:\nstruct Ipv4Addr { // --snip-- } struct Ipv6Addr { // --snip-- } enum IpAddr { V4(Ipv4Addr), V6(Ipv6Addr), } 我们已经列举了好几种不同的方式来定义用于存储V4和V6IP地址的数据结构，然而，事实证明，存储IP地址和编码它们的种类实在是太常见了，以至于标准库已经包含了我们能用的定义。让我们看看标准库如何定义IpAddr: 它的枚举和成员和我们所定义及使用的是一样的，不过它用两个不同的结构的形式将地址数据嵌入到枚举成员中，每个成员的结构体定义是不同的：\nThis code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.\n这些代码说明你可以放任何类型的数据到枚举成员中，例如字符串、数字类型和结构体，甚至你可以放另一个枚举！并且，标准库的类型通常不会比你能碰到的复杂多少。\nNote that even though the standard library contains a definition for IpAddr, we can still create and use our own definition without conflict because we haven’t brought the standard library’s definition into our scope. We’ll talk more about bringing types into scope in Chapter 7.\n注意，即使标准库已经包含了对IpAddr的定义，但是我们仍可以创建和使用我们自己的定义，不会有冲突，因为我们还没有把标准库定义引入我们的作用域来。我们将在第七章谈论如何做到这个。\nLet’s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.\n让我们来看6-2的例子中的另一个枚举：这个枚举的成员嵌入了各种各样的类型。\nenum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } Listing 6-2: A Message enum whose variants each store different amounts and types of values Listing 6-2: 一个名为Message的枚举，其每个成员都存储了不同数量和类型的值\nThis enum has four variants with different types:\nQuit has no data associated with it at all. Move has named fields like a struct does. Write includes a single String. ChangeColor includes three i32 values. 这个枚举有四个不同类型的成员：\nQuit，没有关联数据 Move，有和结构体一样的命名字段 Write，包含了单独的一个String ChangeColor，包含了三个i32值 Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the struct keyword and all the variants are grouped together under the Message type. The following structs could hold the same data that the preceding enum variants hold:\nstruct QuitMessage; // 类单元结构体 struct MoveMessage { x: i32, y: i32, } struct WriteMessage(String); // 元组结构体 struct ChangeColorMessage(i32, i32, i32); // 元组结构体 定义一个如示例 6-2 中所示那样的有关联值的枚举的方式和定义多个不同类型的结构体的方式很相像，除了枚举不使用 struct 关键字以及其所有成员都被组合在一起位于 Message 类型下。如下这些结构体可以包含与之前枚举成员中相同的数据：\nBut if we used the different structs, which each have their own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the Message enum defined in Listing 6-2, which is a single type.\n不过，如果我们使用不同的结构体，由于它们都有不同的类型，我们将不能像使用示例 6-2 中定义的 Message 枚举那样，轻易的定义一个能够处理这些不同类型的结构体的函数，因为枚举是单独一个类型。\nThere is one more similarity between enums and structs: just as we’re able to define methods on structs using impl, we’re also able to define methods on enums. Here’s a method named call that we could define on our Message enum:\nfn main() { #[derive(Debug)] enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } impl Message { fn call(\u0026self) { println!(\"{:?}\", self); // Write(\"hello\") } } let m = Message::Write(String::from(\"hello\")); m.call(); } 枚举和结构体还有另一个相似点：就像可以使用 impl 来为结构体定义方法那样，也可以在枚举上定义方法。这是我们在 Message 枚举上定义了一个叫做 call 的方法：\nThe body of the method would use self to get the value that we called the method on. In this example, we’ve created a variable m that has the value Message::Write(String::from(\"hello\")), and that is what self will be in the body of the call method when m.call() runs.\n在方法体中使用了 self 来获取方法的调用者。这个例子中，创建了一个值为 Message::Write(String::from(\"hello\")) 的变量 m，m就是当 m.call() 运行时 call 方法中的 self 的值。\n","wordCount":"1483","inLanguage":"zh","datePublished":"2022-12-28T23:09:59+08:00","dateModified":"2022-12-28T23:09:59+08:00","author":[{"@type":"Person","name":"壹次心"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://www.yici.xin/post/read/rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%9E%9A%E4%B8%BE/"},"publisher":{"@type":"Organization","name":"yicixin's blog","logo":{"@type":"ImageObject","url":"https://yicixin-blog-image.oss-accelerate.aliyuncs.com/img/202211171234877.jpg"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://www.yici.xin/ accesskey=h title="👀 (Alt + H)">👀</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://www.yici.xin/tags/ title=标签🏷️><span>标签🏷️</span></a></li><li><a href=https://www.yici.xin/archives/ title=归档🕰️><span>归档🕰️</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.yici.xin/>主页</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/>Posts</a>&nbsp;»&nbsp;<a href=https://www.yici.xin/post/read/>📖阅读</a></div><h1 class=post-title>Rust程序设计——枚举</h1><div class=post-meta><span title='2022-12-28 23:09:59 +0800 +0800'>2022-12-28</span>&nbsp;·&nbsp;7 分钟&nbsp;·&nbsp;1483 字&nbsp;·&nbsp;壹次心&nbsp;|&nbsp;<a href=https://github.com/yicixin/blog/blob/main/content/post/read/rust%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1-%e6%9e%9a%e4%b8%be.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><blockquote><p><a href=https://doc.rust-lang.org/stable/book/ch06-01-defining-an-enum.html>原文链接🔗</a></p></blockquote><h2 id=defining-an-enum>Defining an Enum<a hidden class=anchor aria-hidden=true href=#defining-an-enum>#</a></h2><p>定义枚举</p><p>Where structs give you a way of grouping together related fields and data, like a <code>Rectangle</code> with its <code>width</code> and <code>height</code>, enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that <code>Rectangle</code> is one of a set of possible shapes that also includes <code>Circle</code> and <code>Triangle</code>. To do this, Rust allows us to encode these possibilities as an enum.</p><p>结构体提供给我们将相联系的字段和数据聚合在一起的手段，像是有<code>width</code>和<code>height</code>两个字段的<code>Rectangle</code>结构，枚举所提供的能力是，表示一个值是一组可能值中的一个。例如，我们表示<code>Rectangle</code>是一组形状中的一个，这组形状可能还包括了圆形、三角形。在Rust中，我们可以将这些可能的值编码成一个枚举。</p><p>Let’s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. Because these are the only possibilities for an IP address that our program will come across, we can <em>enumerate</em> all possible variants, which is where enumeration gets its name.</p><p>让我们看一种我们想要在代码中表达的情况并且来解释为什么枚举是有用的，且在这种情况下比结构体是更适合的。假设我们需要使用IP地址。目前，IP地址有两种主流标准，<code>V4</code>和<code>V6</code>.在我们的程序中，这些是唯一可能遇到的IP地址形式，所以我们可以枚举所有的可能，这就是枚举名称的来源。</p><p>Any IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate, because an enum value can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.</p><p>任何IP地址都可以是<code>V4</code>或者<code>V6</code>，但是不能同时是两者。IP地址的这个属性使得枚举是合适的，因为枚举成员只能是它所有可能中的一个。<code>V4</code>和<code>V6</code>地址都是IP地址，所以当代码处理适用于任何IP地址的情况时，它们应该被当做同一种类型。</p><p>We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are the variants of the enum:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddrKind</span> {
</span></span><span style=display:flex><span>    V4,
</span></span><span style=display:flex><span>    V6,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.
我们可以在代码中表示这个概念，通过定义一个<code>IpAddrKind</code>枚举，并且列出IP地址所有的类型。</p><p><code>IpAddrKind</code> 现在是一个自定义数据类型，我们可以在代码中任何地方使用它。</p><h3 id=enum-values>Enum Values<a hidden class=anchor aria-hidden=true href=#enum-values>#</a></h3><p>We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>	<span style=color:#66d9ef>let</span> four <span style=color:#f92672>=</span> IpAddrKind::V4;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>let</span> six <span style=color:#f92672>=</span> IpAddrKind::V6;
</span></span></code></pre></div><p>我们可以像这样创建这两个枚举成员的每个实例。</p><p>Note that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. This is useful because now both values <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type: <code>IpAddrKind</code>. We can then, for instance, define a function that takes any <code>IpAddrKind</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>route</span>(ip_kind: <span style=color:#a6e22e>IpAddrKind</span>) {}
</span></span></code></pre></div><p>And we can call this function with either variant:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>	route(IpAddrKind::V4);
</span></span><span style=display:flex><span>	route(IpAddrKind::V6);
</span></span></code></pre></div><p>注意，枚举的成员位于其枚举标识符的命名空间下，使用两个冒号分隔，这么设计的益处是现在 <code>IpAddrKind::V4</code> 和 <code>IpAddrKind::V6</code> 都是 <code>IpAddrKind</code> 类型的。例如，接着可以定义一个函数来获取任何 <code>IpAddrKind</code>：</p><p>我们可以使用任一该枚举的成员来调用这个函数：</p><p>Using enums has even more advantages. Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address <em>data</em>; we only know what <em>kind</em> it is. Given that you just learned about structs in Chapter 5, you might be tempted to tackle this problem with structs as shown in Listing 6-1.</p><p>使用枚举还有更多优点，进一步考虑一下我们的 IP 地址类型，目前没有一个存储实际 IP 地址 <strong>数据</strong> 的方法；只知道它是什么 <strong>类型</strong> 的。考虑到已经在第 5 章学习过结构体了，你可能会像示例 6-1 那样处理这个问题：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddrKind</span> {
</span></span><span style=display:flex><span>        V4,
</span></span><span style=display:flex><span>        V6,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>        kind: <span style=color:#a6e22e>IpAddrKind</span>,
</span></span><span style=display:flex><span>        address: String,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> home <span style=color:#f92672>=</span> IpAddr {
</span></span><span style=display:flex><span>        kind: <span style=color:#a6e22e>IpAddrKind</span>::V4,
</span></span><span style=display:flex><span>        address: String::from(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> loopback <span style=color:#f92672>=</span> IpAddr {
</span></span><span style=display:flex><span>        kind: <span style=color:#a6e22e>IpAddrKind</span>::V6,
</span></span><span style=display:flex><span>        address: String::from(<span style=color:#e6db74>&#34;::1&#34;</span>),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of an IP address using a <code>struct</code>
示例 6-1：将 IP 地址的数据和 <code>IpAddrKind</code> 成员存储在一个 <code>struct</code> 中</p><p>Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field of type <code>String</code>. We have two instances of this struct. The first is <code>home</code>, and it has the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address data of <code>127.0.0.1</code>. The second instance is <code>loopback</code>. It has the other variant of <code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code> associated with it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code> values together, so now the variant is associated with the value.</p><p>这里我们定义了一个有两个字段的结构体， <code>IpAddrKind</code>（之前定义的枚举）类型的 <code>kind</code> 字段和 <code>String</code> 类型 <code>address</code> 字段。我们有这个结构体的两个实例。第一个，<code>home</code>，它的 <code>kind</code> 的值是 <code>IpAddrKind::V4</code> ，与之相关联的地址数据是 <code>127.0.0.1</code>。第二个实例，<code>loopback</code>，<code>kind</code> 的值是 <code>IpAddrKind</code> 的另一个成员，<code>V6</code>，关联的地址是 <code>::1</code>。我们使用了一个结构体来将 <code>kind</code> 和 <code>address</code> 打包在一起，现在枚举成员就与值相关联了。</p><p>However, representing the same concept using just an enum is more concise: rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code> variants will have associated <code>String</code> values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>    V4(String),
</span></span><span style=display:flex><span>    V6(String),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> home <span style=color:#f92672>=</span> IpAddr::V4(String::from(<span style=color:#e6db74>&#34;127.0.0.1&#34;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> loopback <span style=color:#f92672>=</span> IpAddr::V6(String::from(<span style=color:#e6db74>&#34;::1&#34;</span>));
</span></span></code></pre></div><p>然而，我们可以使用枚举来更简洁地表达相同的概念，不是将枚举作为结构体的一部分，而是将数据直接放进每一个枚举成员。这里<code>IpAddr</code> 枚举的新定义， <code>V4</code> 和 <code>V6</code> 成员都关联了 <code>String</code>值：</p><p>We attach data to each variant of the enum directly, so there is no need for an extra struct. Here it’s also easier to see another detail of how enums work: the name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, <code>IpAddr::V4()</code> is a function call that takes a <code>String</code> argument and returns an instance of the <code>IpAddr</code> type. We automatically get this constructor function defined as a result of defining the enum.</p><p>我们将数据直接放进每一个枚举成员，所以不需要额外的结构体。这里也能够看到枚举用法的另一个细节，我们所定义的每一枚举成员的名称同时也是一个枚举实例的构造函数。也就是说，<code>IpAddr::V4()</code>是一个以 <code>String</code> 作为参数，且返回一个<code>IpAddr</code>类型实例的函数调用。这个构造函数是我们在定义枚举时就自动得到的一个结果。</p><p>There’s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four type IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with a struct. Enums handle this case with ease:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>        V4(<span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>, <span style=color:#66d9ef>u8</span>),
</span></span><span style=display:flex><span>        V6(String),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> home <span style=color:#f92672>=</span> IpAddr::V4(<span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> loopback <span style=color:#f92672>=</span> IpAddr::V6(String::from(<span style=color:#e6db74>&#34;::1&#34;</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>还有另一个枚举比结构体更合适的例子，每个枚举成员可以有不同的类型和数据数量，<code>IPV4</code>地址的格式总是由四个0-255之间的数字组成。如果我们想要把<code>V4</code>地址以四个<code>u8</code>类型值进行存储但同时仍用<code>String</code>类型表示<code>V6</code>地址，使用结构体是做不到的。枚举可以很简单地处理这个情况:</p><p>We’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that <a href=https://doc.rust-lang.org/stable/std/net/enum.IpAddr.html>the standard library has a definition we can use!</a> Let’s look at how the standard library defines <code>IpAddr</code>: it has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ipv4Addr</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --snip--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Ipv6Addr</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// --snip--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>IpAddr</span> {
</span></span><span style=display:flex><span>    V4(Ipv4Addr),
</span></span><span style=display:flex><span>    V6(Ipv6Addr),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们已经列举了好几种不同的方式来定义用于存储<code>V4</code>和<code>V6</code>IP地址的数据结构，然而，事实证明，存储IP地址和编码它们的种类实在是太常见了，以至于标准库已经包含了我们能用的定义。让我们看看标准库如何定义<code>IpAddr</code>:
它的枚举和成员和我们所定义及使用的是一样的，不过它用两个不同的结构的形式将地址数据嵌入到枚举成员中，每个成员的结构体定义是不同的：</p><p>This code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.</p><p>这些代码说明你可以放任何类型的数据到枚举成员中，例如字符串、数字类型和结构体，甚至你可以放另一个枚举！并且，标准库的类型通常不会比你能碰到的复杂多少。</p><p>Note that even though the standard library contains a definition for <code>IpAddr</code>, we can still create and use our own definition without conflict because we haven’t brought the standard library’s definition into our scope. We’ll talk more about bringing types into scope in Chapter 7.</p><p>注意，即使标准库已经包含了对<code>IpAddr</code>的定义，但是我们仍可以创建和使用我们自己的定义，不会有冲突，因为我们还没有把标准库定义引入我们的作用域来。我们将在第七章谈论如何做到这个。</p><p>Let’s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.</p><p>让我们来看6-2的例子中的另一个枚举：这个枚举的成员嵌入了各种各样的类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Message</span> {
</span></span><span style=display:flex><span>    Quit,
</span></span><span style=display:flex><span>    Move { x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span> },
</span></span><span style=display:flex><span>    Write(String),
</span></span><span style=display:flex><span>    ChangeColor(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>),
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Listing 6-2: A <code>Message</code> enum whose variants each store different amounts and types of values
Listing 6-2: 一个名为<code>Message</code>的枚举，其每个成员都存储了不同数量和类型的值</p><p>This enum has four variants with different types:</p><ul><li><code>Quit</code> has no data associated with it at all.</li><li><code>Move</code> has named fields like a struct does.</li><li><code>Write</code> includes a single <code>String</code>.</li><li><code>ChangeColor</code> includes three <code>i32</code> values.</li></ul><p>这个枚举有四个不同类型的成员：</p><ul><li><code>Quit</code>，没有关联数据</li><li><code>Move</code>，有和结构体一样的命名字段</li><li><code>Write</code>，包含了单独的一个<code>String</code></li><li><code>ChangeColor</code>，包含了三个<code>i32</code>值</li></ul><p>Defining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the <code>struct</code> keyword and all the variants are grouped together under the <code>Message</code> type. The following structs could hold the same data that the preceding enum variants hold:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>QuitMessage</span>; <span style=color:#75715e>// 类单元结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MoveMessage</span> {
</span></span><span style=display:flex><span>    x: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>    y: <span style=color:#66d9ef>i32</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>WriteMessage</span>(String); <span style=color:#75715e>// 元组结构体
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ChangeColorMessage</span>(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>); <span style=color:#75715e>// 元组结构体
</span></span></span></code></pre></div><p>定义一个如示例 6-2 中所示那样的有关联值的枚举的方式和定义多个不同类型的结构体的方式很相像，除了枚举不使用 <code>struct</code> 关键字以及其所有成员都被组合在一起位于 <code>Message</code> 类型下。如下这些结构体可以包含与之前枚举成员中相同的数据：</p><p>But if we used the different structs, which each have their own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</p><p>不过，如果我们使用不同的结构体，由于它们都有不同的类型，我们将不能像使用示例 6-2 中定义的 <code>Message</code> 枚举那样，轻易的定义一个能够处理这些不同类型的结构体的函数，因为枚举是单独一个类型。</p><p>There is one more similarity between enums and structs: just as we’re able to define methods on structs using <code>impl</code>, we’re also able to define methods on enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {  
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[derive(Debug)]</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Message</span> {  
</span></span><span style=display:flex><span>        Quit,  
</span></span><span style=display:flex><span>        Move { x: <span style=color:#66d9ef>i32</span>, y: <span style=color:#66d9ef>i32</span> },  
</span></span><span style=display:flex><span>        Write(String),  
</span></span><span style=display:flex><span>        ChangeColor(<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>),  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>impl</span> Message {  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>call</span>(<span style=color:#f92672>&amp;</span>self) {  
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;{:?}&#34;</span>, self);  <span style=color:#75715e>// Write(&#34;hello&#34;)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> m <span style=color:#f92672>=</span> Message::Write(String::from(<span style=color:#e6db74>&#34;hello&#34;</span>));  
</span></span><span style=display:flex><span>    m.call();  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>枚举和结构体还有另一个相似点：就像可以使用 <code>impl</code> 来为结构体定义方法那样，也可以在枚举上定义方法。这是我们在 <code>Message</code> 枚举上定义了一个叫做 <code>call</code> 的方法：</p><p>The body of the method would use <code>self</code> to get the value that we called the method on. In this example, we’ve created a variable <code>m</code> that has the value <code>Message::Write(String::from("hello"))</code>, and that is what <code>self</code> will be in the body of the <code>call</code> method when <code>m.call()</code> runs.</p><p>在方法体中使用了 <code>self</code> 来获取方法的调用者。这个例子中，创建了一个值为 <code>Message::Write(String::from("hello"))</code> 的变量 <code>m</code>，m就是当 <code>m.call()</code> 运行时 <code>call</code> 方法中的 <code>self</code> 的值。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.yici.xin/tags/rust/>rust</a></li><li><a href=https://www.yici.xin/tags/%E7%BF%BB%E8%AF%91/>翻译</a></li></ul><nav class=paginav><a class=prev href=https://www.yici.xin/post/read/rust-option%E6%9E%9A%E4%B8%BE/><span class=title>« 上一页</span><br><span>Rust Option枚举</span></a>
<a class=next href=https://www.yici.xin/post/tech/go%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/><span class=title>下一页 »</span><br><span>Go程序的启动过程</span></a></nav></footer><script type=text/javascript>let giscusTheme=localStorage.getItem("pref-theme")==="dark"?"dark_dimmed":"light",giscusAttributes={src:"https://giscus.app/client.js","data-repo":"yicixin/blog_comment","data-repo-id":"R_kgDOIr6QyQ","data-category":"Announcements","data-category-id":"DIC_kwDOIr6Qyc4CTSs3","data-mapping":"title","data-reactions-enabled":"1","data-emit-metadata":"0","data-theme":giscusTheme===null?"light":giscusTheme,"data-lang":"zh-CN",crossorigin:"anonymous","data-loading":"lazy",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([e,t])=>giscusScript.setAttribute(e,t));var article=document.getElementsByTagName("article")[0].appendChild(giscusScript);function changeGiscusTheme(){const e=localStorage.getItem("pref-theme")==="dark"?"light":"dark_dimmed";function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}const toggle=document.querySelector("#theme-toggle");toggle&&toggle.addEventListener("click",changeGiscusTheme)</script><script src=https://giscus.app/client.js data-repo=yicixin/blog_comment data-repo-id=R_kgDOIr6QyQ data-category=Announcements data-category-id=DIC_kwDOIr6Qyc4CTSs3 data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://www.yici.xin/>yicixin's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="ctrl\u002bc";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="ctrl\u002bc"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script src=https://code.jquery.com/jquery-1.12.4.min.js></script>
<script>$("code[class^=language] ").on("mouseover",function(){this.clientWidth<this.scrollWidth&&$(this).css("width","135%")}).on("mouseout",function(){$(this).css("width","100%"),$(".copy-code").css("right","4px")})</script></body></html>